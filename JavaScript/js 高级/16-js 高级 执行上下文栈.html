<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16-js 高级 执行上下文栈</title>
</head>

<body>
    <pre>
        1.在全局代码执行前,js 引擎会创建一个来储存管理所有的执行上下文对象
        2.在全局执行上下文(window)确定后,将其添加到栈中(压栈)
        3.在函数执行山下文创建后,将其添加到栈中(压栈)
        4.在函数执行完后,将栈顶的对象移除(出栈)
        5.当所有的代码执行完后,栈中值剩下winodw


        面试题
        1.依次输出什么?
         global begin:undefined
        foo() begin:1
        foo() begin:2
        foo() begin:3
        foo() end:3
        foo() end:2
        foo() end:1
        global end:1

        2整个过程产生了几个执行上下文?
        5个 
        foo 4(i==4时 return)
        foo 3
        foo 2
        foo 1
        window
        从下往上执行,在倒回执行入栈的console
    </pre>
</body>
<script>
    // var a = 10
    // var bar = function (x) {
    //     var b = 5
    //     foo(x + b)
    // }
    // var foo = function (y) {
    //     var c = 5
    //     console.log(a + c + y);
    // }
    // bar(10)


    //  面试题
    // console.log('面试题');
    // console.log('global begin:' + i);
    // var i = 1;
    // foo(1);
    // function foo(i) {
    //     if (i == 4) {
    //         return;
    //     }
    //     console.log('foo() begin:' + i);
    //     foo(i + 1);  //递归调用 在函数内部调用自己 循环执行完后再执行下面的代码
    //     //循环执行完,在倒回来执行输出下面的语句

    //     // 函数内部的foo() 递归调用开始,每递归一次,就开辟一个新的函数空间
    //     // 下面的console 进入新的栈中,不会立即执行,等i==4 时递归结束,开始出栈
    //     console.log('foo() end:' + i);
    // }

    // console.log('global end:' + i);

    // 测试题1
    // function a() { }
    // var a
    // console.log(typeof a);  //function
    // 由此可见函数提升要比变量提升的优先级要高一些，
    // 且不会被变量声明覆盖，但是会被变量赋值之后覆盖。
    // var a=function(){};
    // var a;
    // console.log(typeof a);


    // 测试题2
    // if (!(b in window)) {    //此时已经声明了b==> var b; b在window里面
    //     var b = 1;
    // }
    // console.log(b); //undefined


    // 测试题3
    // var c = 1
    // function c(c) {
    //     console.log(c);
    //     // var c = 3
    // }
    // c(2);       //报错  变量提升 c=1

    var d
    console.log(d); //undefined 未定义
    d = null
    console.log(d); //null 空对象
</script>

</html>