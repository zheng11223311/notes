### 1.对象的继承特性

**1.继承的特性**

1. 继承的格式:
   1. class 类名 extends 父类名{ 书写子类独有的方法和属性}
   
   2. 概念:
      1. 父类:被其他类继承的就是父类,也叫做基类
      2. 子类:继承其他类的类就是子类,也叫做派生类
      
   3. 特点:
      1. 子类继承父类中的所有成员属性和成员方法,私有的不能继承
      2. 子类继承父类之后可以具备子类独有的属性和方法
      3. 在继承时,子类中允许出现和父类同名的方法,这种情况不会冲突,而是子类方法会覆盖父类的方法(父类的方法将不会被执行),这种方式叫做重载(重新加载)
      4. 魔术方法也可以被子类继承
      5. 如果父类具有构造方法,子类也需要构造方法进行构造成员属性,此时需要在子类中重载父类的构造方法,并且在构造方法中使用关键字parent,  parent::__construct() 进行调用父类的构造方法,构造继承而来的父类的成员属性
      6. 也可以使用 类名::__construct() 来调用父类的构造方法,不推荐使用,类名改变这个也需要改变
      7. 继承代码的时候不要瞎继承,人类不要继承鸟类,不会变成鸟人,要有一定的逻辑关系
      
   4. PHP 继承的特点和其他语言略有不同
   
      1. PHP 是单继承的语言,一个子类只能继承一个父类
      2. 其他语言可能是多继承,一个子类可以继承多个父类
   
   5. ```php
      
      <?php
      class GrandFather{
          //成员属性(只能是确切的值,不能是一个随机值)
          var $sex=1;
          var $height;
          private $name='告罗凤';
         
          function eat(){
              echo '会吃饭';
          }
          function drink(){
              echo '喝水';
          }
          function __construct(){
              echo '1111';
          }
      }
      
      
      $obj=new GrandFather;
      var_dump($obj);
      
      
      // Father 继承 GrandFather
      class Father extends GrandFather{
          function drink(){
              echo '喝的更多';
          }
          function __construct(){
              echo '2222';
              //调用父类的构造方法
              //缺点:如果继承的父类改变时(class Father extends GrandFather11),这里就不能再调用父类的构造方法
              //替换成关键字  parent
              // GrandFather::__construct();
              parent::__construct();
          }
      }
      $fa=new Father;  
      // $fa=new Father('a'); 可以子类传值 'a' 给子类构造器,在由子类构造器传递给父类构造器  
      var_dump($fa);
      //调用继承过来的属性
      $fa->eat();
      // 子类重写父类的方法
      $fa->drink();   //喝的更多
      
      ?>
      
      ```
   
      

### 2.访问类型控制

**1.三个封装关键字:**

1. private 私有化封装
2. public 公共的封装
3. protected 受保护的封装
4. 子类同名的方法的封装等级必须大于等于父类的封装等级
5. var 是封装关键字,但是他不是一个标准的封装关键字,一般仅应用于测试和学习
6. var =50% 的public
7. 原因:var 只能修饰成员属性,不能修饰成员方法

| 关键字/位置 | 类外 | 类内部 | 子类 | 等级               |
| ----------- | ---- | ------ | ---- | ------------------ |
| private     | x    | v      | x    | 1                  |
| protected   | x    | v      | v    | 2                  |
| public      | v    | v      | v    | 3 (所有都可以访问) |

```php 

<?php
class LiuBei{
    //成员属性(只能是确切的值,不能是一个随机值)
    protected $fname='刘';
    private $lastName='备';
    public $horse='的卢';

    protected function say(){
        echo '正在说话';
    }
    private function cry(){
        echo '呜呜呜~';
    }
    public function zhandou(){
        echo '正在战斗中...';
    }
    function textVistit(){
        // 访问公开的马
        // 内部都可以访问
        echo $this->horse;
        echo $this->lastName;
        echo $this->fname;
    }
}


$obj=new LiuBei;
var_dump($obj);
// 在类外部访问成员属性
$obj->horse;
$obj->lastName;
$obj->fname;
// 不能访问私有属性,受保护的属性


// Father 继承 GrandFather
class ADou extends LiuBei{
    function __construct(){
        // 子类中不能访问私有的属性,其他都可以访问
        echo $this->horse;
        echo $this->lastName;
        echo $this->fname;
    }
     // 重载父类的各种方法,不能使用private 等级低于protected
    public function say(){
        echo '阿斗厉害了';
    }
}
$fa=new ADou;  
?>



```

### 常见的关键字

1. final 关键字 最终的,最后的
   1. 作用:用来修饰成员方法,禁止正在子类中重载父类的方法
   2. 用来修饰类,被final 修饰的类无法被继承
2. const 关键字
   1. 作用:用于在类中声明常量,这种常量是类中的常量
   2. 类中的常量不归对象所有,而是归类所有
   3. 在类中声明常量使用const 关键字
   4. 声明常量时需要给常量赋值
   5. 声明常量归类所有而不是归对象所有
   6. 类中常量的访问方式
      1. 类外部
         1. 类名::常量名
      2. 类内部
         1. 类名::常量名
         2. self::常量名
   7. 需要注意的是:
      1. self 表示当前类
      2. $this 表示当前的对象
3. static 关键字
   1. 在类中使用static 声明的成员都是静态成员(类只有一个(表示:单一,静态),而对象可以有很多个)
   2. 静态成员的特征是:不归对象所有,而是归类所有
   3. static 关键字,既可以修饰成员属性,也可以修饰成员方法
   4. static 声明的成员都是归类所有,而不是归对象所有,在没有对象的情况下,可以通过类来访问
   5. 能声明静态的成员就声明静态的成员,效率高,因为new 对象消耗资源,在调用,还不如直接使用类调用
   6. 具有动态成员的方法不可以声明静态成员方法(方法中不存在$this)
      1. 如果方法中没有$this 存在,那么这个方法,实际上已经是一个静态方法(PHP 5.3 之后需要使用static 关键字)
   7. 静态成员访问:
      1. 类内部
         1. 类名::$静态成员属性名
         2. self::静态成员属性名
         3. 类名::静态成员方法名()
         4. self::静态成员方法名()
      2. 类的外部:
         1. 类名::$静态成员属性名
         2. 类名::静态成员方法名()
         3. 对象->静态成员方法名()   =>一般不用

```php

<?php
// 修饰类之后,类不能被继承
final class Ma{
    //成员属性(只能是确切的值,不能是一个随机值)
    public $name='马';
    public $sex;

    final function xiazai(){
        echo '生崽了';
    }
     function pao(){
        echo '策马奔腾吧~';
    }
}


$obj=new Ma;
var_dump($obj);

// Father 继承 GrandFather
class LuoZi extends Ma{
   
    //骡子是不能下崽的.所以要在父类中使用final,
    // 终止子类重写父类方法,子类就不能重载父类的方法
    public function xaizai(){    //public使用public 可以重写父类的方法,所以要在父类使用final 终止重写
        echo '神奇了.骡子都能下崽了';
    }
}
$fa=new LuoZi;  
?>

```

```php

<?php
 class Mysql{
    //成员属性(只归类所有,不能使用对象访问)
    const DB_HOST='localhost';
    const DB_USER='root';
    const DB_PWD='123456';
    const DB_DBANE='lmonkey';
    var $a=1;

    function textConst(){
        //类中访问常量
        echo Mysql::DB_USER;
        //this 指代当前类new 出来的对象
        echo $this->a;
        // echo $this->DB_DBANE;   //报错
        // 使用self 指代当前的类,使用const 定义的变量
        echo self::DB_USER;
    }
}

//再类的外部访问
echo Mysql::DB_DBANE;

// 在类的内部访问
$m=new Mysql();
echo $m->textConst();

?>

```

```php
<?php
 class Computer{
    //成员属性(只归类所有,不能使用对象访问)
    public $type='mac pro';
    public $memory='16G';
    public $disk='1T';
    static public $cpu='I7 3.6HZ';
    static public $color='粉红色';




    function playGame(){
        echo '面对疾风ba~';
    }
    function seemovie(){
        echo '有信心一定成功;';
    }
    function liaotian(){
        echo '人生要活得漂亮';
    }
    static function zhuangx(){
        echo '我一直承受这个年纪不因该有的帅气,我好累';
    }
    function text(){
        echo Computer::$cpu;
        echo self::$cpu;
    }
}

//再类的外部访问静态变量
echo Computer::$color;
// 非静态方法也能使用类直接调用,但是不推荐,也会发出错误警告
// Computer::text();

$obj=new Computer;
//对象可以调用静态成员方法,但是不可以调用静态成员属性
//方法是引用地址的,可以使用对象来使用,而属性不行
$obj->zhuangx();
// echo $obj->$color;  //报错

?>
```

