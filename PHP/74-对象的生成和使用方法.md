### 1.对象的生成和使用方法

1. 对象的生成和使用方法
   1. 一般情况下,类是无法直接调用的,需要将类实例化对象之后才可以使用
   2. 当成员属性为static 时,才可以直接使用对象调用,比如调用Person 类中的静态方法say() Person::say() 
   3. 实例化对象的方法:
      1. 格式1:
         1. 对象变量=new 类名;
      2. 格式2
         1. 对象变量=new 类名();
2. 使用对象中的成员属性
   1. 对象->成员属性名
3. 使用对象中的成员方法
   1. 对象->成员方法名()
4. 修改成员属性
   1. 对象->成员=值
5. $this 关键字
   1. 作用:在当前对象中的成员方法中,调用当前对象中的成员属性
   2. $this 表示当前对象
   3. 如果代码中具有$this 的出现,那么该类必须实例化才能使用,不能使用对象直接调用带有$this 的静态方法

```php

<?php
class Person{
    //成员属性(只能是确切的值,不能是一个随机值)
    var $sex=1;
    var $height;
    var $name='告罗凤';
    // var $sex=mt_rand(0,1);x

    //成员方法
    function eat($a){
        echo '正好吃';
        return '我是你的优乐美';
    }
    function say(){
        echo '成就自己的只需一套精品';
        return $this;
    }
    //成员方法中使用成员属性.$this 指代当前类
    function run(){
        echo $this->name;
        
    }
    static function sleep(){
        echo $this->name;
        
    }
}

// 使用Person 类来实例化一个对象
$obj=new Person;
var_dump($obj);

//使用Person 来实例化Person 类
$obj=new Person();
var_dump($obj);

// 输出当前对象的成员属性
echo $obj->sex; 
echo $obj->name; 

//使用person 对象中的方法
$obj->say();
$obj->eat('上的的');

// 修改成员属性
$obj->sex='不男不女'; 
echo $obj->sex; 

//类直接调用方法,直接调用的成员方法或成员属性必须是静态的
//类不能调用带有$this 的静态方法
//Person::sleep();	
//Person::say()

//返回$this 可以实现链式调用
$obj->say()->run()
?>


```

### 2.构造方法及析构方法

1. 魔术方法
   1. 一种特殊的函数
   2. 构造方法  --构建和创造
      1. __construct()
      2. 触发时机:在对象实例化的时候自动触发
      3. 作用:初始化成员属性
      4. 参数:可以有,可以没有,取决于设定和逻辑
      5. 返回值:没有
      6. **注意:如果构造方法具有参数,却参数没有默认值,在实例化对象时,必须在类名后面的括号添加实参**
   3. 析构方法  --拆解构造
      1. __destruct()
      2. 触发时机:在销毁对象的时候自动触发(unset() 或者页面执行完毕)
      3. 作用:释放未释放的资源,回收对象使用过程中的资源
      4. 参数:没有
      5. 返回值:没有

```php

<?php
class Person{
    //成员属性(只能是确切的值,不能是一个随机值)
    var $sex=1;
    var $height;
    var $name='告罗凤';

    //创建一个与类一样的名称,实例化时会报错,但是函数会在自动执行
    //缺点,当类名改变时,这个方法就不会在被调用,使用 __construct()  代替
    function Person($a){
        echo '正好吃';
        echo $a;    //a
        return '我是你的优乐美';
    }
    function __construct($a){
        echo '被实例化时自动执行';
        // __construct 没有返回值,因为返回值new 实例化时,接收实例的变量接收不到这个返回值,
    }

    // 析构方法  --拆解构造
    function __destruct(){
        echo '@@@';
    }
  
   
}


//使用Person 来实例化Person 类
$obj=new Person('a');      //使用() new 出来的可以向内部同名方法传递值/向__construct 传参
var_dump($obj);

sleep(5);       //5 秒后对象变量被释放,执行析构函数

?>

```



