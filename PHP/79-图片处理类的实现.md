### 1.图片处理类的实现

​	**图片缩放类的实现**

```php
<?php

$th=new Image('./img/');
$re=$th->thumb('1.jpg',100,100);
var_dump($re);


//图像处理类
class Image{
    //成员属性
    //设置图片保存的路径
    private $path;
    //成员方法
    //实例化图像对象时传递一个路径,默认为当前路径
    function __construct($path='./'){
        $this->path=rtrim($path,'/').'/';
    }
    //对指定图片进行进行缩放的方法
    public function thumb($name,$width,$height,$qz='s_'){
        //获取图片宽度以及类型信息
        $imgInfo=$this->getInfo($name);
        // var_dump($data);
        //获取背景图片资源
        $srcImg=$this->getImg($name,$imgInfo);
        //获取图片的新尺寸
        $size=$this->getNewSize($name,$width,$height,$imgInfo);
        // var_dump($size);
        // 获取新的图片资源
        $newImg=$this->kidOfImage($srcImg,$size,$imgInfo);
        // var_dump($newImg);
        // 保存图片并且返回新缩略图的名称
        return $this->createNewImage($newImg,$qz.$name,$imgInfo);
    }
    //内部使用的方法,用来获取图片信息(宽度,高度,类型)
    private function getInfo($name,$path='.'){
        //定义一个路径
        $spath=$path=='.'?rtrim($this->path,'/').'/':$path.'/';
        // echo $spath.$name;
        // 1 = GIF，2 = JPG，3 =PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 =TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 =JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM
        $data=getimagesize($spath.$name);
        // var_dump($data);
        $imgInfo['width']=$data[0];
        $imgInfo['height']=$data[1];
        $imgInfo['type']=$data[2];
        // 返回图片相关信息的数组(宽度,高度,类型)
        return $imgInfo;
    }
    //内部使用方法,用于创建支持创建各种图片格式的资源
    private function getImg($name,$imgInfo,$path='.'){
        $spath=$path=='.'?rtrim($this->path,'/').'/':$path.'/';
        $srcPic=$spath.$name;
        //判断是什么类型的就是使用什么类型的函数创建
        //获取
        $suffix=ltrim(strrchr($srcPic,'.'),'.');   //后缀
        // echo $suffix;
        if($suffix=='jpg'){
            $suffix='jpeg';
        }
        $create='imagecreatefrom'.$suffix;
        $img=$create($srcPic);
        // var_dump($img);
       return $img;
    }
    //内部方法,返回等比例缩放图片的宽度和高度,注意,如果原图比缩放后的图片还小,则保持不变
    private function getNewSize($name,$width,$height,$imgInfo){
        $size['width']=$imgInfo['width'];
        $size['height']=$imgInfo['height'];
        //缩放的宽度如果小于原图的高度才设置新的宽度
        if($width<$imgInfo['width']){
            $size['width']=$width;
        }
        if($height<$imgInfo['height']){
            $size['height']=$height;
        }
        //等比例缩放算法
        if($imgInfo['width']*$size['width']>$imgInfo['height']*$size['height']){
            $size['height']=round($imgInfo['height']*$size['width']/$imgInfo['width']);
        }else{
            $size['width']=round($imgInfo['width']*$size['height']/$imgInfo['height']);
        } 
        return $size;
    }
    //内部使用方法,处理有透明度的图片
    private function kidOfImage($srcImg,$size,$imgInfo){
        // /创建画布
        $newImg=imagecreatetruecolor($size['width'],$size['height']);
        // 设置透明度
        imagesavealpha($newImg,true);
        // 127 透明度
        $back=imagecolorallocatealpha($newImg,255,255,255,127);
        imagefill($newImg,0,0,$back);//填充
        // 从采样拷贝
        imagecopyresampled($newImg,$srcImg,0,0,0,0,$size['width'],$size['height'],$imgInfo['width'],$imgInfo['height']);
        // 释放原图资源
        imagedestroy($srcImg);
        return $newImg;
    }
    // 内部使用的方法 用户保存图像 并且返回图像的名称
    private function createNewImage($newImg,$newName,$imgInfo){
        $this->path=rtrim($this->path,'/').'/';
        switch ($imgInfo['type']) {
            case 1:
                $result=imagegif($newImg,$this->path.$newName);
                break;
            case 2:
                $result=imagejpeg($newImg,$this->path.$newName);
                break;
            case 3:
                $result=imagepng($newImg,$this->path.$newName);
                break;
        }
        imagedestroy($newImg);
        return $newName;
    }

}
?>



```

**2.图片水印的实现**

```php
<?php
//返回水印的名称
$th=new Image('./img/');
// $re=$th->waterMark(原图名称,水印图名称,水印位置,水印前缀);
$re=$th->waterMark('1.jpg','3.png',9,'ss_');
var_dump($re);


//图像处理类
class Image{
    //成员属性
    //设置图片保存的路径
    private $path;
    //成员方法
    //实例化图像对象时传递一个路径,默认为当前路径
    function __construct($path='./'){
        $this->path=rtrim($path,'/').'/';
    }
    //对指定图片进行进行缩放的方法
    public function thumb($name,$width,$height,$qz='s_'){
        //获取图片宽度以及类型信息
        $imgInfo=$this->getInfo($name);
        // var_dump($data);
        //获取背景图片资源
        $srcImg=$this->getImg($name,$imgInfo);
        //获取图片的新尺寸
        $size=$this->getNewSize($name,$width,$height,$imgInfo);
        // var_dump($size);
        // 获取新的图片资源
        $newImg=$this->kidOfImage($srcImg,$size,$imgInfo);
        // var_dump($newImg);
        // 保存图片并且返回新缩略图的名称
        return $this->createNewImage($newImg,$qz.$name,$imgInfo);
    }
    //图片水印方法
    public function waterMark($groundName,$waterName,$waterPos=0,$qz='w_'){
        //获取水印图片和当前路径
        $curPath=rtrim($this->path,'/').'/';
        $dir=dirname($waterName);
        if($dir='.'){
            $wpath=$curPath;
        }else{
            $wpath=$dir.'/';
            $waterName=basename($waterName);     
        }
        //水印图片和背景图片必须都要存在
        if(file_exists($curPath.$groundName)&&file_exists($wpath.$waterName)){
            //获取背景图片信息 以及图片信息
            $groundInfo=$this->getInfo($groundName);
            $waterInfo=$this->getInfo($waterName);
            //如果背景图比水印图还小,就会被水印图全部覆盖
            if(!$this->position($groundInfo,$waterInfo,$waterPos)){
                echo '水印图的大小大于背景图的大小';
                return false;
            }
            //获取背景图片资源和水印图片资源
            $groundImg=$this->getImg($groundName,$groundInfo);
            $waterImg=$this->getImg($waterName,$groundInfo,$dir);
            //调用私有方法拷贝图片
            $groundImg=$this->copyImage($groundImg,$waterImg,$this->position($groundInfo,$waterInfo,$waterPos),$waterInfo);
            //保存
            return $this->createNewImage($groundImg,$qz.$groundName,$groundInfo);
        }else{
            echo '图片或水印图片不存在';
            return false;
        }
    }
    //内部使用方法 用于加水印复制图像
    private function copyImage($groundImg,$waterImg,$pos,$waterInfo){
        imagecopy($groundImg,$waterImg,$pos['posX'],$pos['posY'],0,0,$waterInfo['width'],$waterInfo['height']);
        imagedestroy($waterImg);
        return $groundImg;
    }
    //内部使用方法,用来确定水印图片的位置
    private function position($groundInfo,$waterInfo,$waterPos){
        //添加水印的图片的长度或或宽度比水印土拍你还小,无法生成水印
        if($groundInfo['width']<$waterInfo['width']||$groundInfo['height']<$waterInfo['height']){
            return false;
        }
        switch ($waterPos) {
            case 1:
                $posX=0;
                $posY=0;
                break;
            case 2:
                $posX=($groundInfo['width']-$waterInfo['width'])/2;
                $posY=0;
                break;
            case 3:
                $posX=($groundInfo['width']-$waterInfo['width']);
                $posY=0;
                break;
            case 4:
                $posX=0;
                $posY=($groundInfo['height']-$waterInfo['height'])/2;
                break;
            case 5:
                $posX=($groundInfo['width']-$waterInfo['width'])/2;
                $posY=($groundInfo['height']-$waterInfo['height'])/2;
                break;
            case 6:
                $posX=($groundInfo['width']-$waterInfo['width']);
                $posY=($groundInfo['height']-$waterInfo['height'])/2;
                break;
            case 7:
                $posX=0;
                $posY=($groundInfo['height']-$waterInfo['height']);
                break;
            case 8:
                $posX=($groundInfo['width']-$waterInfo['width'])/2;
                $posY=($groundInfo['height']-$waterInfo['height']);
                break;
            case 9:
                $posX=($groundInfo['width']-$waterInfo['width']);
                $posY=($groundInfo['height']-$waterInfo['height']);
                break;
            default:
                $posX=mt_rand(0,$groundInfo['width']-$waterInfo['width']);
                $posY=mt_rand(0,$groundInfo['height']-$waterInfo['height']);
                break;
        }
        return array('posX'=>$posX,'posY'=>$posY);
    }
    //内部使用的方法,用来获取图片信息(宽度,高度,类型)
    private function getInfo($name,$path='.'){
        //定义一个路径
        $spath=$path=='.'?rtrim($this->path,'/').'/':$path.'/';
        // echo $spath.$name;
        // 1 = GIF，2 = JPG，3 =PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 =TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 =JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM
        $data=getimagesize($spath.$name);
        // var_dump($data);
        $imgInfo['width']=$data[0];
        $imgInfo['height']=$data[1];
        $imgInfo['type']=$data[2];
        // 返回图片相关信息的数组(宽度,高度,类型)
        return $imgInfo;
    }
    //内部使用方法,用于创建支持创建各种图片格式的资源
    private function getImg($name,$imgInfo,$path='.'){
        $spath=$path=='.'?rtrim($this->path,'/').'/':$path.'/';
        $srcPic=$spath.$name;
        //判断是什么类型的就是使用什么类型的函数创建
        //获取
        $suffix=ltrim(strrchr($srcPic,'.'),'.');   //后缀
        // echo $suffix;
        if($suffix=='jpg'){
            $suffix='jpeg';
        }
        $create='imagecreatefrom'.$suffix;
        $img=$create($srcPic);
        // var_dump($img);
       return $img;
    }
    //内部方法,返回等比例缩放图片的宽度和高度,注意,如果原图比缩放后的图片还小,则保持不变
    private function getNewSize($name,$width,$height,$imgInfo){
        $size['width']=$imgInfo['width'];
        $size['height']=$imgInfo['height'];
        //缩放的宽度如果小于原图的高度才设置新的宽度
        if($width<$imgInfo['width']){
            $size['width']=$width;
        }
        if($height<$imgInfo['height']){
            $size['height']=$height;
        }
        //等比例缩放算法
        if($imgInfo['width']*$size['width']>$imgInfo['height']*$size['height']){
            $size['height']=round($imgInfo['height']*$size['width']/$imgInfo['width']);
        }else{
            $size['width']=round($imgInfo['width']*$size['height']/$imgInfo['height']);
        } 
        return $size;
    }
    //内部使用方法,处理有透明度的图片
    private function kidOfImage($srcImg,$size,$imgInfo){
        // /创建画布
        $newImg=imagecreatetruecolor($size['width'],$size['height']);
        // 设置透明度
        imagesavealpha($newImg,true);
        // 127 透明度
        $back=imagecolorallocatealpha($newImg,255,255,255,127);
        imagefill($newImg,0,0,$back);//填充
        // 从采样拷贝
        imagecopyresampled($newImg,$srcImg,0,0,0,0,$size['width'],$size['height'],$imgInfo['width'],$imgInfo['height']);
        // 释放原图资源
        imagedestroy($srcImg);
        return $newImg;
    }
    // 内部使用的方法 用户保存图像 并且返回图像的名称
    private function createNewImage($newImg,$newName,$imgInfo){
        $this->path=rtrim($this->path,'/').'/';
        switch ($imgInfo['type']) {
            case 1:
                $result=imagegif($newImg,$this->path.$newName);
                break;
            case 2:
                $result=imagejpeg($newImg,$this->path.$newName);
                break;
            case 3:
                $result=imagepng($newImg,$this->path.$newName);
                break;
        }
        imagedestroy($newImg);
        return $newName;
    }

}
?>



```

**3.图片裁剪类的实现**(包含上面全部功能)

```php
<?php
//返回裁剪的名称
$th=new Image('./img/');
$re=$th->cut('1.jpg',320,120,150,150);
var_dump($re);


//图像处理类
class Image{
    //成员属性
    //设置图片保存的路径
    private $path;
    //成员方法
    //实例化图像对象时传递一个路径,默认为当前路径
    function __construct($path='./'){
        $this->path=rtrim($path,'/').'/';
    }
    //对指定图片进行进行缩放的方法
    public function thumb($name,$width,$height,$qz='s_'){
        //获取图片宽度以及类型信息
        $imgInfo=$this->getInfo($name);
        // var_dump($data);
        //获取背景图片资源
        $srcImg=$this->getImg($name,$imgInfo);
        //获取图片的新尺寸
        $size=$this->getNewSize($name,$width,$height,$imgInfo);
        // var_dump($size);
        // 获取新的图片资源
        $newImg=$this->kidOfImage($srcImg,$size,$imgInfo);
        // var_dump($newImg);
        // 保存图片并且返回新缩略图的名称
        return $this->createNewImage($newImg,$qz.$name,$imgInfo);
    }
    //图片水印方法
    public function waterMark($groundName,$waterName,$waterPos=0,$qz='w_'){
        //获取水印图片和当前路径
        $curPath=rtrim($this->path,'/').'/';
        $dir=dirname($waterName);
        if($dir='.'){
            $wpath=$curPath;
        }else{
            $wpath=$dir.'/';
            $waterName=basename($waterName);     
        }
        //水印图片和背景图片必须都要存在
        if(file_exists($curPath.$groundName)&&file_exists($wpath.$waterName)){
            //获取背景图片信息 以及图片信息
            $groundInfo=$this->getInfo($groundName);
            $waterInfo=$this->getInfo($waterName);
            //如果背景图比水印图还小,就会被水印图全部覆盖
            if(!$this->position($groundInfo,$waterInfo,$waterPos)){
                echo '水印图的大小大于背景图的大小';
                return false;
            }
            //获取背景图片资源和水印图片资源
            $groundImg=$this->getImg($groundName,$groundInfo);
            $waterImg=$this->getImg($waterName,$groundInfo,$dir);
            //调用私有方法拷贝图片
            $groundImg=$this->copyImage($groundImg,$waterImg,$this->position($groundInfo,$waterInfo,$waterPos),$waterInfo);
            //保存
            return $this->createNewImage($groundImg,$qz.$groundName,$groundInfo);
        }else{
            echo '图片或水印图片不存在';
            return false;
        }
    }
    //裁剪方法的实现
    public function cut($name,$x,$y,$width,$height,$qz='cu_'){
        //获取原图的信息
        $imgInfo=$this->getInfo($name);
        //判断裁剪的位置不能超过背景图片范围
        if(($x+$width>$imgInfo['width'])||($y+$height>$imgInfo['height'])){
            echo '裁剪位置超出背景图片的范围';
            return false;
        }
        //获取背景图片资源
        $back=$this->getImg($name,$imgInfo);
        //创建一个新的保存裁剪后的资源
        $cutImg=imagecreatetruecolor($width,$height);
        //使用函数对图片进行裁剪
        imagecopyresampled($cutImg,$back,0,0,$x,$y,$width,$height,$width,$height);
        imagedestroy($back);
        //保存图像
        return $this->createNewImage($cutImg,$qz.$name,$imgInfo);

    }
    //内部使用方法 用于加水印复制图像
    private function copyImage($groundImg,$waterImg,$pos,$waterInfo){
        imagecopy($groundImg,$waterImg,$pos['posX'],$pos['posY'],0,0,$waterInfo['width'],$waterInfo['height']);
        imagedestroy($waterImg);
        return $groundImg;
    }
    //内部使用方法,用来确定水印图片的位置
    private function position($groundInfo,$waterInfo,$waterPos){
        //添加水印的图片的长度或或宽度比水印土拍你还小,无法生成水印
        if($groundInfo['width']<$waterInfo['width']||$groundInfo['height']<$waterInfo['height']){
            return false;
        }
        switch ($waterPos) {
            case 1:
                $posX=0;
                $posY=0;
                break;
            case 2:
                $posX=($groundInfo['width']-$waterInfo['width'])/2;
                $posY=0;
                break;
            case 3:
                $posX=($groundInfo['width']-$waterInfo['width']);
                $posY=0;
                break;
            case 4:
                $posX=0;
                $posY=($groundInfo['height']-$waterInfo['height'])/2;
                break;
            case 5:
                $posX=($groundInfo['width']-$waterInfo['width'])/2;
                $posY=($groundInfo['height']-$waterInfo['height'])/2;
                break;
            case 6:
                $posX=($groundInfo['width']-$waterInfo['width']);
                $posY=($groundInfo['height']-$waterInfo['height'])/2;
                break;
            case 7:
                $posX=0;
                $posY=($groundInfo['height']-$waterInfo['height']);
                break;
            case 8:
                $posX=($groundInfo['width']-$waterInfo['width'])/2;
                $posY=($groundInfo['height']-$waterInfo['height']);
                break;
            case 9:
                $posX=($groundInfo['width']-$waterInfo['width']);
                $posY=($groundInfo['height']-$waterInfo['height']);
                break;
            default:
                $posX=mt_rand(0,$groundInfo['width']-$waterInfo['width']);
                $posY=mt_rand(0,$groundInfo['height']-$waterInfo['height']);
                break;
        }
        return array('posX'=>$posX,'posY'=>$posY);
    }
    //内部使用的方法,用来获取图片信息(宽度,高度,类型)
    private function getInfo($name,$path='.'){
        //定义一个路径
        $spath=$path=='.'?rtrim($this->path,'/').'/':$path.'/';
        // echo $spath.$name;
        // 1 = GIF，2 = JPG，3 =PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 =TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 =JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM
        $data=getimagesize($spath.$name);
        // var_dump($data);
        $imgInfo['width']=$data[0];
        $imgInfo['height']=$data[1];
        $imgInfo['type']=$data[2];
        // 返回图片相关信息的数组(宽度,高度,类型)
        return $imgInfo;
    }
    //内部使用方法,用于创建支持创建各种图片格式的资源
    private function getImg($name,$imgInfo,$path='.'){
        $spath=$path=='.'?rtrim($this->path,'/').'/':$path.'/';
        $srcPic=$spath.$name;
        //判断是什么类型的就是使用什么类型的函数创建
        //获取
        $suffix=ltrim(strrchr($srcPic,'.'),'.');   //后缀
        // echo $suffix;
        if($suffix=='jpg'){
            $suffix='jpeg';
        }
        $create='imagecreatefrom'.$suffix;
        $img=$create($srcPic);
        // var_dump($img);
       return $img;
    }
    //内部方法,返回等比例缩放图片的宽度和高度,注意,如果原图比缩放后的图片还小,则保持不变
    private function getNewSize($name,$width,$height,$imgInfo){
        $size['width']=$imgInfo['width'];
        $size['height']=$imgInfo['height'];
        //缩放的宽度如果小于原图的高度才设置新的宽度
        if($width<$imgInfo['width']){
            $size['width']=$width;
        }
        if($height<$imgInfo['height']){
            $size['height']=$height;
        }
        //等比例缩放算法
        if($imgInfo['width']*$size['width']>$imgInfo['height']*$size['height']){
            $size['height']=round($imgInfo['height']*$size['width']/$imgInfo['width']);
        }else{
            $size['width']=round($imgInfo['width']*$size['height']/$imgInfo['height']);
        } 
        return $size;
    }
    //内部使用方法,处理有透明度的图片
    private function kidOfImage($srcImg,$size,$imgInfo){
        // /创建画布
        $newImg=imagecreatetruecolor($size['width'],$size['height']);
        // 设置透明度
        imagesavealpha($newImg,true);
        // 127 透明度
        $back=imagecolorallocatealpha($newImg,255,255,255,127);
        imagefill($newImg,0,0,$back);//填充
        // 从采样拷贝
        imagecopyresampled($newImg,$srcImg,0,0,0,0,$size['width'],$size['height'],$imgInfo['width'],$imgInfo['height']);
        // 释放原图资源
        imagedestroy($srcImg);
        return $newImg;
    }
    // 内部使用的方法 用户保存图像 并且返回图像的名称
    private function createNewImage($newImg,$newName,$imgInfo){
        $this->path=rtrim($this->path,'/').'/';
        switch ($imgInfo['type']) {
            case 1:
                $result=imagegif($newImg,$this->path.$newName);
                break;
            case 2:
                $result=imagejpeg($newImg,$this->path.$newName);
                break;
            case 3:
                $result=imagepng($newImg,$this->path.$newName);
                break;
        }
        imagedestroy($newImg);
        return $newName;
    }

}
?>



```

