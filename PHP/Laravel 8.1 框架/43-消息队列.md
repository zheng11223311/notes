# 消息队列

参考手册  [队列 | 继续深入 |《Laravel 9 中文文档 9.x》| Laravel China 社区 (learnku.com)](https://learnku.com/docs/laravel/9.x/queues/12236) 

**掌握内容**

- 配置
- 创建任务
- 分发任务
- 守护进程



## 简介

在构建 Web 应用程序时，你可能需要执行一些任务（例如解析和存储上传的 CSV 文件），但这些任务在典型的 Web 请求中花费的时间太长。幸运的是，Laravel 允许你轻松地创建可在后台排队处理的任务作业。通过将耗时的任务移到队列中，你的应用程序可以以超快的速度响应 Web 请求，并为客户提供更好的用户体验。

 在 `config/queue.php` 配置文件中 

```
    // 使用什么存储队列里的内容
    'default' => env('QUEUE_CONNECTION', 'sync'),
    
    //驱动配置
    'connections' => [

        'sync' => [
            'driver' => 'sync',
        ],

        'database' => [
            'driver' => 'database',
            'table' => 'jobs',
            'queue' => 'default',
            'retry_after' => 90,
            'after_commit' => false,
        ],
        //...
```



## 驱动程序说明和先决条件

**数据库**
要使用 `database `队列驱动程序，你需要一个数据库表来保存任务。要生成创建此表的迁移，请运行 `queue:table `Artisan 命令。一旦迁移已经创建，你可以使用 `migrate `命令迁移你的数据库：

```powershell
php artisan queue:table		#创建关于队列的数据表的类文件
#Migration created successfully!

php artisan migrate		#执行迁移,创建数据表 队列工作表jobs 和队列失败的表failed_jobs
#Migrating: 2022_05_18_134819_create_jobs_table
#Migrated:  2022_05_18_134819_create_jobs_table (12.62ms)
```

 

## 队列的迁移类

`database\migrations\2022_05_18_134819_create_jobs_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateJobsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('jobs', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('queue')->index();
            $table->longText('payload');
            $table->unsignedTinyInteger('attempts');
            $table->unsignedInteger('reserved_at')->nullable();
            $table->unsignedInteger('available_at');
            $table->unsignedInteger('created_at');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('jobs');
    }
}

```



最后，请不要忘记通过修改`.env` 文件中的 `QUEUE_CONNECTION` 变量从而将 `database` 作为你的应用队列驱动程序: 

```powershell
QUEUE_CONNECTION=database
```





## 创建一个单函数控制器用于测试

```powershell
php artisan make:controller Test9Controller --invokable

#Controller created successfully.
```



`项目/routes/web.php`

```php
<?php
    
use App\Http\Controllers\Test9Controller;
use Illuminate\Support\Facades\Route;

Route::get('/test9',Test9Controller::class);
// Route::get('/test9/{id}',Test9Controller::class);
```



`项目/app/Http/Controllers/Test9Controller.php`

```php
<?php

namespace App\Http\Controllers;

use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;

class Test9Controller extends Controller
{

    public function __invoke(Request $request)
    {
        //模拟发送邮件,耗时3s
        // info 向日志写入信息
        // 日志位置 storage/logs/laravel.log,不存在info 时会自动创建
        // 将其放入到队列中
        // info('开始发送');
        // sleep(3);
        // info('邮件发送成功');
        // 此时浏览器会一直在转动,处于加载中

        // 使用队列发送邮件
        //这个任务将被推送到默认队列...,
        ProcessPodcast::dispatch();
        // 这个任务将被推送到 "emails" 队列...
        // ProcessPodcast::dispatch()->onQueue('emails');

        // 然后使用php artisan queue:work 命令 运行cmd
        // 再次请求 http://localhost:8000/test9 
        // 浏览器直接加载成功,任务交给队列处理,
        // cmd 会显示处理的队列信息
    }
}

```





## [创建任务](https://learnku.com/docs/laravel/9.x/queues/12236#6ef95f)

#### 生成任务类

默认情况下，应用程序的所有的可排队任务都被存储在了 `app/Jobs` 目录中。如果 `app/Jobs` 目录不存在，当您运行 `make:job` Artisan 命令时，将会自动创建该目录：

```powershell
php artisan make:job ProcessPodcast
#Job created successfully.
```

`app\Jobs\ProcessPodcast.php`

```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldBeUnique;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Create a new job instance.
     *
     * @return void
     */
    public function __construct()
    {
        // 被 ProcessPodcast::dispatch(); 时
        // __construct (初始化) 和 handle() 都会被执行
    }

    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {
        //处理队列的业务逻辑
        info('开始发送');
        sleep(3);
        info('邮件发送成功');
        
    }
}

```







## 运行队列工作者

queue:work 命令
Laravel 包含一个 Artisan 命令，该命令将启动队列进程并在新任务被推送到队列时处理它们。 您可以使用 `queue:work` Artisan 命令运行任务进程。请注意，一旦 `queue:work` 命令启动，它将继续运行，直到手动停止或关闭终端：

```
php artisan queue:work
```







## Supervisor 配置

在生产中，您需要一种方法来保持` queue:work `进程运行。` queue:work `进程可能会因多种原因停止运行，例如超过 `worker `超时或执行 `queue:restart` 命令。

出于这个原因，您需要配置一个进程监视器，它可以检测您的 `queue:work` 进程何时退出并自动重新启动它们。此外，进程监视器可以让您指定要同时运行多少个 `queue:work` 进程。`Supervisor `是 `Linux `环境中常用的进程监视器，我们将在下面的文档中讨论如何配置它。

**安装 Supervisor**
`Supervisor `是 `Linux `操作系统的进程监视器，如果它们失败，它将自动重新启动您的 `queue:work` 进程。要在 `Ubuntu `上安装 `Supervisor`，您可以使用以下命令：

```
sudo apt-get install supervisor
```



**配置 Supervisor**
`Supervisor `配置文件通常存储在` /etc/supervisor/conf.d` 目录中。在这个目录中，你可以创建任意数量的配置文件来指示 `Supervisor `应该如何监控你的进程

```shell
[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d	
command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600		#执行的命令
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=forge
numprocs=8
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log
stopwaitsecs=3600
```



**查看正在守护的进程**

```
sudo supervisorctl status
```



**开始 Supervisor**
创建配置文件后，您可以使用以下命令更新 `Supervisor `配置并启动进程：

```powershell
sudo supervisorctl reread

sudo supervisorctl update

sudo supervisorctl start laravel-worker:*
```

