# 缓存系统

参考手册  [缓存系统 | 继续深入 |《Laravel 8 中文文档 8.5》| Laravel China 社区 (learnku.com)](https://learnku.com/docs/laravel/8.5/cache/10383) 



**掌握内容**

- 存储数据
- 读取数据



## 简介

在某些应用中，一些查询数据或处理任务的操作会在某段时间里短时间内大量进行，或是一个操作花费好几秒钟。当出现这种情况时，通常会将检索到的数据缓存起来，从而为后面请求同一数据的请求迅速返回结果。这些缓存数据通常会储存在极快的存储系统中，例如 [Memcached](https://memcached.org/) 和 [Redis](https://redis.io/)。

Laravel 为各种缓存后端提供了富有表现力且统一的 API，以便你利用它们极快的查询数据来加快你的应用。



## 配置

缓存配置文件位于` config/cache.php`。在这个文件中，你可以指定应用默认使用哪个缓存驱动。Laravel 支持的缓存后端包括 `Memcached`、`Redis`、`DynamoDB`，以及现成的关系型数据库。此外，还支持基于文件的缓存驱动，以及方便自动化测试的缓存驱动 `array`、`null`。

缓存配置文件还包含其他各种选项，这些选项记录在文件中，因此请务必仔细阅读这些选项。**默认情况下，Laravel 配置为使用 `file `缓存驱动**，该驱动将序列化的缓存对象存储在服务器的文件系统上。对于较大的应用程序，建议您使用功能更强大的驱动，例如 `Memcached` 或 `Redis`。你甚至可以为同一驱动程序配置多个缓存配置。



**默认的file 缓存驱动的缓存文件的存储位置** :

 `项目/storage/framework/cache/data`



`项目/config/cache.php`

```php
<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Cache Store
    |--------------------------------------------------------------------------
    |
    | This option controls the default cache connection that gets used while
    | using this caching library. This connection is used when another is
    | not explicitly specified when executing a given caching function.
    |
    */

    // 默认使用给的缓存类型
    // env 使用环境变量中的值,如果没有则使用第二个值
    'default' => env('CACHE_DRIVER', 'file'),

    /*
    |--------------------------------------------------------------------------
    | Cache Stores
    |--------------------------------------------------------------------------
    |
    | Here you may define all of the cache "stores" for your application as
    | well as their drivers. You may even define multiple stores for the
    | same cache driver to group types of items stored in your caches.
    |
    | Supported drivers: "apc", "array", "database", "file",
    |         "memcached", "redis", "dynamodb", "octane", "null"
    |
    */

    //驱动的配置
    'stores' => [

        'apc' => [
            'driver' => 'apc',
        ],

        'array' => [
            'driver' => 'array',
            'serialize' => false,
        ],

        //数据库的配置
        'database' => [
            'driver' => 'database',
            'table' => 'cache',
            'connection' => null,
            'lock_connection' => null,
        ],

        // 本地文件的配置
        'file' => [
            'driver' => 'file',
            // 缓存文件的存储位置
            //  项目/storage/framework/cache/data
            'path' => storage_path('framework/cache/data'),
        ],

        'memcached' => [
            'driver' => 'memcached',
            'persistent_id' => env('MEMCACHED_PERSISTENT_ID'),
            'sasl' => [
                env('MEMCACHED_USERNAME'),
                env('MEMCACHED_PASSWORD'),
            ],
            'options' => [
                // Memcached::OPT_CONNECT_TIMEOUT => 2000,
            ],
            'servers' => [
                [
                    'host' => env('MEMCACHED_HOST', '127.0.0.1'),
                    'port' => env('MEMCACHED_PORT', 11211),
                    'weight' => 100,
                ],
            ],
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => 'cache',
            'lock_connection' => 'default',
        ],

        'dynamodb' => [
            'driver' => 'dynamodb',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
            'table' => env('DYNAMODB_CACHE_TABLE', 'cache'),
            'endpoint' => env('DYNAMODB_ENDPOINT'),
        ],

        'octane' => [
            'driver' => 'octane',
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Cache Key Prefix
    |--------------------------------------------------------------------------
    |
    | When utilizing a RAM based store such as APC or Memcached, there might
    | be other applications utilizing the same cache. So, we'll specify a
    | value to get prefixed to all our keys so we can avoid collisions.
    |
    */

    // 缓存的前缀
    'prefix' => env('CACHE_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_cache'),

];

```









**创建一个单函数控制器用于测试**

```
php artisan make:controller Test5Controller --invokable
```



`项目/routes/web.php`

```php
<?php
    
use App\Http\Controllers\Test5Controller;
use Illuminate\Support\Facades\Route;

Route::get('/test5',Test5Controller::class);
// Route::get('/test5/{id}',Test5Controller::class);
```



`项目/app/Http/Controllers/Test5Controller.php`

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

class Test5Controller extends Controller
{

    public function __invoke(Request $request)
    {
        // test();

        // 使用门面模式的cache 类
        // 获取缓存
        // $value = Cache::get('name');
        // dd($value); // 第一次访问 null
        // 不存在时,第二个参数为使用默认值
        // $value = Cache::get('name','这是name');
        // dd($value);

        // 检测是否存在
        // if (Cache::has('name')) {
        //     dd('存在name');
        // }


        // 缓存的字段递增递减,参数2 为递增的量
        // 如果不存在字段则会创建
        // 增加1
        // Cache::increment('key');
        // // 增加12
        // Cache::increment('key', 12);
        // // 减少1
        // Cache::decrement('key');
        // // 减少13
        // Cache::decrement('key', 13);
        // $value = Cache::get('key','这是name');
        // dd($value); //-1


        // 获取缓存,如果不存在,就是用闭包返回的数据
        // $value = Cache::get('a', function () {
        //     // return DB::table('users')->get();
        //     return '这是数据不存在时,返回的数据';
        // });
        // dd($value);  //'这是数据不存在时,返回的数据';
        // $value =Cache::get('a');
        // dd($value); //单独获取不存此数据,说明并没有缓存


        // 获取缓存,如果不存在,就是用闭包返回的数据,同时缓存闭包数据,且指定缓存时间,单位秒
        // 缓存时间到期之后就会清除缓存的文件
        // 30 缓存时间 30s
        // $value = Cache::remember('users', 30, function () {
        //     return '数据不存在,返回此数据,并进行缓存';
        // });
        // dd($value); 
        // 时间过期后,在没有使用get 获取数据的时候,缓存文件依然还是在的,只是打了个销毁标记
        // 在次get 访问的时候,执行删除文件,获取的数据为null
        // $value =Cache::get('users');
        // dd($value); 

        // 永久缓存
        // $value = Cache::rememberForever('users', function () {
        //     return DB::table('users')->get();
        // });
        // // 获取缓存数据并删除缓存中的数据
        // $value = Cache::pull('key');

        // 在缓存中存储数据
        //参数  key value 时间s
        // Cache::put('key', 'value', $seconds = 10);
        // // 永久缓存
        // Cache::put('key', 'value');
        // // 10分钟后过期
        // Cache::put('key', 'value', now()->addMinutes(10));
        // // 只存储没有的数据,有则不缓存
        // Cache::add('key', 'value', $seconds);
        // 数据永久存储
        // Cache::forever('key', 'value');
        // 从缓存中删除数据
        // Cache::forget('key');
        // 你也可以通过提供零或者负数过期秒数值来删除这些数据：
        // Cache::put('key', 'value', 0);
        // Cache::put('key', 'value', -5);
        // // 清空所有数据
        // Cache::flush();



        // Cache 辅助函数
        // 获取缓存
        // $value = cache('key');
        // 设置缓存
        // cache(['key' => 'value']);
        // cache(['key' => 'value'], 10);
        // cache(['key' => 'value'], now()->addMinutes(10));

        // 当 cache 函数在没有任何参数的情况下被调用，即cache()
        // 那么它返回的将是一个实现 Illuminate\Contracts\Cache\Factory 的实例，并且允许你调用其他的缓存方法,这个实例可以调用上方flush,put 等原生的方法
        // 获取缓存,不存在则缓存回调函数的值
        // cache()->remember('users', 10, function () {
        //     return DB::table('users')->get();
        // });


        

    }
}

```

