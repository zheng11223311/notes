### 1.数据库类的实现

魔术方法:__call()

1. 触发时机:调用类中不存在的方法时,自动触发

2. 功能:1.屏蔽错误, 2.为不存在的方法定义一个功能

3. 参数:2个.  一个时不存在的方法的方法名,另一个是不存在的方法的所有的实参列表

4. 返回值:可有可无

5. ```php
   <?php
    class Computer{
       
       function __toString(){
           return '这是对象.不能echo';
       }
       // 魔术方法 __call()
       // 当调用不存在的方法时,会触发call ,call屏蔽错误,参数为调用不存在方法名,和不存在方法的函数参数
       function __call($method,$args){
           echo $method;
           var_dump($args);
       }
   }
   
   $obj=new Computer;
   // echo $obj; 
   //调用不存在的方法
   $obj->hhh('a','b');
   $obj->xxx('a','b');
   
   
   ?>
   
   ```

**实现数据库连接的操作**

**父类**

```php
<?php
// 实现数据库操作类
 class Model{
    //  成员属性
    // 数据库连接地址
    private $host;
    // 数据库用户名
    private $user;
    // 数据库密码
    private $pwd;
    // 要操作的表名
    private $tabName;
    // 表前缀
    private $preFix;
    // 要操作的数据库名
    private $dbname;
    // 字符集
    private $charset;
    //数据库链接资源
    private $link=null;
    // 定义用户查看SQL 语句的成员
    private $sql;
    private $cache;
    // 定义一个允许存在的方法名
    private $method=array('limit','where','order','field');
    private $limit;
    private $where;
    private $order;
    private $field;
    // 成员方法
    // 构造方法,初始化成员属性 以及 连接数据库
    function __construct($tabName='',$cache='./cache/'){
        //初始化数据库的配置属性
        $this->host=DB_HOST;
        $this->user=DB_USER;
        $this->pwd=DB_PWD;
        $this->cahrset=CHARSET;
        $this->preFix=DB_PREFIX;
        $this->dbname=DB_NAME;
        $this->cache=rtrim($cache,'/').'/';
        //判断是否传入了表名,如果传入了表名则使用,如果没有传入表名,需要自己去获取表名
        if($tabName==''){
            //没有传入表名,需要自己来获取
            // var_dump(get_class($this)); //返回对象所属的类名
            // strtolower(substr(get_class($this),0,-5));
            $this->tabName=$this->preFix.strtolower(substr(get_class($this),0,-5));
        }else{
            // 使用传入的表名
            $this->tabName=$this->preFix.$tabName;
        }
        // 初始化数据库的连接
        $this->link=$this->connect();
    }
    //定义数据库的连接方法
    private function connect(){
        //连接数据库
        $link=@mysqli_connect($this->host,$this->user,$this->pwd,$this->dbname);
        if(!$link){
            return false;
        }
        // 设置字符集
        mysqli_set_charset($link,$this->charset);
        return $link;
    }
    // 获取数据表中合法字段(安全过滤)
    private function getField(){
        //设置缓存文件的路径
        $pathInfo=$this->cache.$this->tabName.'Cache.php';
        if(file_exists($pathInfo)){
            return include $pathInfo;
        }else{
            // 准备SQL 语句,去数据库中读取字段
            $sql="DESC ".$this->tabName;
            var_dump($sql);
            $result=$this->query($sql);
            // 将数据中的字段写入到文件中保存
            return $this->writeFile($result);

        }
    }
    //将查询的有效字段写入缓存文件保存
    private function writeFile(array $data){
        //1判断缓存的文件是否存在
        if(!file_exists($this->cache)){
            mkdir($this->cache,0777,true);
        }
        //2定义一个完整的路径
        $pathInfo=$this->cache.$this->tabName.'cache.php';
        //定义一个数组
        $fields=array();
        var_dump($data);
        //遍历数组,获取每一个数组中的字段名 和主键以及递增的字段名
        foreach ($data as $key => $value) {
            // 获取主键
            if($value['Key']=="PRI"){
                $fields['_pk']=$value['Field'];
            }
            //获取自增字段
            if($value['Key']=='auto_increment'){
                $fields['_auto']=$value['Field'];
            }
            //获取字段名
            $fields[]=$value['Field'];
        }
        //写入文件操作
        file_put_contents($pathInfo,"<?php\r\n return ".var_export($fields,true)."\r\n?>");
        return  $fields; 
    }
    //定义查询数据库的SQL 语句的方法
    private function query($sql){
        $this->sql=$sql;
        //清空条件
        $this->clearWhere();
        // 定义一个返回数据的数组
        $rows=array();
        $result=mysqli_query($this->link,$sql);
        if($result&&mysqli_num_rows($result)>0){
            while($row=mysqli_fetch_assoc($result)){
                $rows[]=$row;
            }
            //返回一个二维数组
            return $rows;
        }else{
            return false;
        }
    }
    //实现数据的添加方法
    public function insert(array $data){
        //获取合法字段
        $fields=$this->getField();
        $k='';
        $v='';
        // 遍历数据,组装sql
        foreach ($data as $key => $value) {
            $k.="`".$key."`".',';
            $v.="'".$value."'".',';
        }
        $k=rtrim($k,',');
        $v=rtrim($v,',');
        // var_dump($data);
        // 准备SQL 语句
        $sql="INSERT INTO {$this->tabName}({$k}) VALUES({$v})";
        // 调用执行发送sql 语句的方法
        return $this->exec($sql);

    }
    // 实现发送SQL 语句的方法(增删改,返回受影响的行)
    private function exec($sql){
        //保存要执行的SQL 语句 给用户查看
        $this->sql=$sql;
        //清空条件
        $this->clearWhere();
        $result=mysqli_query($this->link,$sql);
        if($result&&mysqli_affected_rows($this->link)>0){
            //成功 如果id 不存在则返回受影响的行
            return mysqli_insert_id($this->link)?mysqli_insert_id($this->link):mysqli_affected_rows($this->link);
        }else{
            return false;
        }
    }
    //定义一个魔术方法,为访问私有成员属性开一个后门
    public function __get($pro){
        if($pro=='sql'){
            echo $this->sql;
        }else{
            echo '不存在';
        }
    }
    //实现删除方法
    public function delete(){
        //检测是否调用了where 方法传入的删除条件
        echo !empty($this->where);
        if(!empty($this->where)){
            $where=' WHERE '.$this->where;
        }else{
            // 如果没有带调用传入的删除条件则自动上$_GET 中去检测是否传入了删除条件
            $where='';
            if(!empty($_GET)){
                //先获取缓存中的合法字符
                $field=$this->getField();
                $id=$field['_pk'];
                foreach ($_GET as $key => $value) {
                    if($id==$key){
                        $val=$value;
                    }
                }
                $where=' WHERE '.$id.'='.$val;
            }
        }
        $sql="DELETE FROM {$this->tabName}{$where}";
        echo $sql;
        return $this->exec($sql);
    }
    //实现修改数据方法
    public function update(array $data){
        //获取缓冲中的安全字段
        $field=$this->getField();
        $update='';
       
        //进行字段的过滤与拼接
        foreach ($data as $key => $value) {
            if(in_array($key,$field)&&$key!=$field['_pk']){
                $update.='`'.$key."`='".$value."',";
            }elseif($key==$field['_pk']){
                $con='`'.$key."`='".$value."'";
            }
        }
        //判断是否有where 条件
        if(!empty($this->where)){
            $where=' WHERE '.$this->where;
        }else{
            //没有调用where 方法
            $where=' WHERE '.$con;
        }
        $update=rtrim($update,',');
        $sql="UPDATE {$this->tabName} SET {$update} {$where}";
        // echo $sql;
        return $this->exec($sql);
    }
    //实现查询数据方法
    public function select(){
        $limit=$where=$order='';
         //获取合法验证的字段
         $field=$this->getField();
         //获取查询的字段
         $fields=$this->valadateFile($field);
        //判断是饭传入where 条件
        if(!empty($this->where)){
            $where=' WHERE '.$this->where;
        }
        //判断是饭传入order 条件
        if(!empty($this->order)){
            $order=' ORDER BY '.$this->order;
        }
        //判断是饭传入limit 条件
        if(!empty($this->limit)){
            $limit=' LIMIT '.$this->limit;
        }
       $sql="SELECT {$fields} FROM {$this->tabName} {$where} {$order} {$limit}";
       echo $sql;
       //返回二维数组
       return $this->query($sql);
    }
    // 清空条件的方法
    private function clearWhere()
    {
        $this->where='';
        $this->limit='';
        $this->order='';
        $this->field='';
    }
    //查询单条数据,返回一维数组
    public function find(){
        //获取安全字段
        $field=$this->getField();
        //判断是否传入条件
        $where='';
        if(!empty($this->where)){
            $where=' WHERE '.$this->where;
        }elseif(count($_GET)>0){
            foreach ($_GET as $key => $value) {
                # //检查get 数组中是否有主键
                if($key==$field['_pk']){
                    $where=' WHERE `'.$key.'`='.$value;
                }
            }
        }elseif (count($_POST)>0) {
            foreach ($_POST as $key => $value) {
                # //检查get 数组中是否有主键
                if($key==$field['_pk']){
                    $where=' WHERE `'.$key.'`='.$value;
                }
            }
        }
        //获取查询的字段
        $fields=$this->valadateFile($field);
        // 拼接SQL 语句
        $sql=" SELECT {$fields} FROM {$this->tabName} {$where} LIMIT 1";
        echo $sql;
        return $this->query($sql)[0];
    }
    //获取查询时用户的合法字段
    private function valadateFile($field)
    {
        if(!empty($this->field)){
            // 过滤安全字段
            $hefa=array_intersect($this->field,$field);
            $fields=implode(',',$hefa);
        }else{
            $fields=" * ";
        }
        return $fields;
    }
    //获取总条数
    public function total()
    {   
        $where='';
        if(!empty($this->where)){
            $where=' WHERE '.$this->where;
        }
        //获取主键
        $field=$this->getField();
        if(isset($field['_pk'])){
            $pk=$field['_pk'];
        }else{
            $pk=' * ';
        }
        $sql="SELECT COUNT({$pk}) AS total FROM  {$this->tabName}  {$where}";
        echo $sql;
        return intval($this->query($sql)[0]['total']);
    }
    
    // 魔术方法 __call()
    // 当调用不存在的方法时,会触发call ,call屏蔽错误,参数为调用不存在方法名,和不存在方法的函数参数
    function __call($method,$args){
        echo $method;
        // var_dump($args);
        // 验证用户调用的方法是否时预设允许的方法
        if(in_array($method,$this->method)){
            //判断用户是否调用了where 方法
            if($method=='where'){
                $this->where=isset($args[0])?$args[0]:'';
            }
            //判断用户是否查询指定字段
            elseif($method=='field'){
                $this->field=$args;
            }
            elseif($method=='limit'){
                // 判断用户是否调用limit 方法
                if(count($args)>1){
                    $this->limit=$args[0].','.$args[1];
                }else{
                    $this->limit=$args[0];
                }

            }
            elseif($method=='order'){
                $this->order=$args[0];
            }
        }
        //返回当前对象 因为在调用是为了做链式调用
        return $this;
    }
}


?>



```

**配置文件**

```php
<?php
//文件名为db.config.php
// 数据库配置文件
define('DB_HOST','localhost');
define('DB_USER', 'root');
define('DB_PWD', '');
define('DB_NAME', 'lmonkey');
define('DB_PREFIX', '');
define('CHARSET', 'utf8');
?>
```

**子类**

```php
<?php
//文件名为UserModel.class.php
// 子类文件
class UserModel extends Model{
    //可以写子类独有的方法
}
$m=new UserModel;
var_dump($m);
?>
```

**结合子类和父类**

```php
<?php
//文件名为userUserModel.php
include './1-php copy 70.php';
// 父类
include './1-php copy 69.php';
// 子类
include './1-php copy 72.php';
$m=new UserModel();
?>

```

**没有子类时，使用**

```php
<?php
// useUserModel.class.php 文件
//传入表名直接使用
//没有子类时
// 数据库配置文件
include './1-php copy 70.php';
// 父类
include './1-php copy 69.php';
$m=new Model('user');
// var_dump($m);

// 传入数据添加
// $data=array('name'=>'xx','age'=>'12');
// $result=$m->insert($data);
// var_dump($result);

// 调用了where 方法 则使用where 中的内容做删除条件
// $_GET=array('uid'=>'10');
// $result=$m->delete();   //自动检测$_get中是否有主键,如果有 删除,如果没有 全部删除
// // $result=$m->where('uid=12')->delete();
// var_dump($result);

//需要传入主键
// $_POST=array('name'=>'xx111','age'=>'12','uid'=>20);
// // $result=$m->update($_POST);   
// // 有where 可以不要主键
// $result=$m->where('uid=22')->update($_POST);
// var_dump($result);


// $_POST=array('name'=>'xx111','age'=>'12','uid'=>20);
// $result=$m->field('uid','sex','age')->limit(5)->select();
// // $result=$m->select();
// var_dump($result);

//查询单条语句
// $_POST=array('uid'=>30);
// $_GET=array('uid'=>31);
// $result=$m->where('uid=33')->field('uid','sex','age')->find();
// $result=$m->where('uid=33')->find();
// $result=$m->find();
// var_dump($result);
$m=new Model('user');
// $result=$m->where('uid=33')->total();    
$result=$m->total();    
var_dump($result);
?>
```

