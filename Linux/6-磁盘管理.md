# 一.基本分区

## 1.磁盘简介

- 名词
  - 磁盘/硬盘/disk 是同一个东西,不同于内存的是容量比较大
- 类型
  - 从工作原理区分
    - 机械
      - 机械硬盘既是传统普通硬盘,主要由:盘片,磁头,盘片转轴及控制电机,磁头控制器,数据转换器,接口,缓存等几个部分组成
    - 固态
      - 固态驱动器(Solid state disk 或 soild state drive,简称SSD),俗称固态硬盘,固态硬盘使用固态电子存储芯片阵列而制成的硬盘
- 尺寸
  - 3.5英寸	(按磁盘对角线长度计算)
  - 2.5 英寸
  - 1.8 英寸
- 接口
  - 早期IDE 
  - 现在SATA Ⅰ/Ⅱ/Ⅲ
- 转速
  - 5400rpm
  - 7200rpm
  - 10000rpm
  - 15000rpm
- 厂商
  - 西部数据
  - 希捷
  - 三星/日立/金士顿
- 术语
  - 盘片
    - 一块硬盘有若干盘片,每个盘片有可以存储数据的上,下两盘面(Side),这些盘面堆叠在主轴上高速旋转
  - 柱面
    - 所有盘面上的同一磁道构成一个圆柱,称作柱面
  - 扇区
    - 将一个盘面划分为若干内角相同的扇形,这样的盘面上的每个磁道就被分为若干段圆弧,每段圆弧叫做一个扇区
  - 磁道
    - 每个盘面被划分成许多同心圆,这些同心圆轨迹叫做磁道;磁道从外向内从0开始顺序编号
- 命名
  - kernel 对不同接口硬盘命名方式
    - RHEL7/CentOS7
      - IDE (并口)
        - /dev/hda
        - /dev/hdb
      - SATA (串口)
        - /dev/sda	
          - /dev 代表设备文件目录
          - sda 是一个文件
          - s 代表sata 就是串口
          - d 代表磁盘disk
          - a 代表第一块磁盘
          - /dev/sda1,/dev/sda2 表示的时同一块磁盘,1 表示分区1, 2表示分区2
        - /dev/sdb
          - //....
          - b 第2块
        - 超过26 块的,后续会进行阵列拼接,将多块硬盘拼接成一块
- 分区方式
  - MBR
    - 主引导记录(MBR ,Master Boot Record) 是位于磁盘最前边的一段引导代码
    - MBR 支持最大的磁盘容量是<2TB,设计时分配4个分区
    - 如果希望超过4个分区,需放弃主分区,改为扩展分区和逻辑分区
  - GPT
    - 全局唯一标识分区表(GUIDPartition Table,缩写:GPT)是一个实体硬盘的分区表的结构布局的标准
    - GPT 支持大于2T 的硬盘,支持128 个分区

## 2.管理磁盘

- 添加磁盘

  - VMWARE 增加磁盘
    - 1.点击 编辑虚拟机设置
    - 2.点击添加
    - 3.一路下一步,设备列表中多出新的一块硬盘
    - 注意,选择磁盘大小时,不要使用默认的20G,改为2-5G,因为越大格式化越慢,删除硬盘时,不要删除原来存在的硬盘,否则需要重装系统

- 管理磁盘流程三部曲

  - 新硬盘 : 分区(MBR 或GPT)---->格式化/文件系统 Filesystem ---->挂载mount
  - 像毛坯房: 隔间-------------------->放家具/打造格子柜----------------->加个门,可以进去/目录

- 查看磁盘信息

  - 方法一:

    - ```shell
      ll /dev/sd*
      # brw-rw----+  	#b 表示block 块,硬盘,以前的电脑很大,硬盘很大,一块一块的
      ```

  - 方法二:

    - ```shell
      lsblk		#列出块状设备
      #显示
      #NAME          MAJ:MIN		 RM  	SIZE	 RO 	TYPE MOUNTPOINT
      #名称 		设备类型:序号 是否可移动设备 大小 是否只读 磁盘或分区 挂载点
      sr0            11:0    1  7.9G  0 rom  /run/media/root/RHEL-8-2-0-BaseOS-x86_64
      nvme0n1       259:0    0   20G  0 disk 
      ├─nvme0n1p1   259:1    0    1G  0 part /boot
      └─nvme0n1p2   259:2    0   19G  0 part 
        ├─rhel-root 253:0    0   17G  0 lvm  /
        └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]
      
      ```

- 创建分区

  - MBR: 把房子分成卧室和客厅

  - 启动分区工具

    - ```shell
      fdisk /dev/sdb
      ```

  - 进入会话模式

    - **1.开始划分分区:** 按 n     // n 划分区
    - **2.划分分区:** 此时按p  划分主分区    (e 为扩展分区)
    - **3.选择分区号:** 按1
    - **4.起始扇区(从哪里到哪里是此扇区):**2048,  //默认开始扇区是上一个结束扇区后开始划分,2048大小为2048*512 个字节,\*512 是因为,磁盘几十亿过大,以512为单位划分进行管理,磁盘从0开始 ,2048 开始的原因,之前的留给系统记录分区的大小
    - **5.Last 扇区:** +2G     //选择磁盘分区结束的扇区,即分区大小,默认是剩下的全部磁盘空间,如果是划分第四个分区,则因该将剩下的空间都给它,因为分区最多只有4个(MBP 只能记录4个分区),如果有多余的空间将无法被使用. 实际环境根据磁盘划分,如4T 磁盘,可以500G 一个分区
      - 如果想要更多的分区,必须放弃一个主分区(一共4个主分区),将其改为扩展分区(不存放数据,数据存放在逻辑分区),再其中进行划分分区,即划分逻辑分区(任意个)
    - **6.已经完成2G 大小分区记录,但未生效:** w 确认进行分区,此时硬盘中的数据会进行擦除,自动退出分区工具,q 是退出操作,之前都不生效

  - 创建逻辑分区(当需要创建逻辑分区时,不需要时,跳过)

    - 一块硬盘,使用MBR ,划分分区,数量上只能由如下选择

      - 4个主分区
      - 3个主分区+1个扩展(N 个逻辑分区)   //扩展分区也占用一个主分区位置
      - N(N<=3)主+M 扩展,N+M<=4  (不建议多个扩展分区,因为主分区都没有分完)

    - 启动分区工具

      - ```shell
        fdisk /dev/sdb
        ```

    - 进入会话模式

      - 按d ,再按 4 ,  删除一个4分区(如果分配了4个主分区)
      - 按p 查看分区,4分区被删除,(按n 后再按p 时选择分区类型,主分区/扩展分区)
      - 按 n 创建分区,按e 选择创建扩展分区
      - 扩展分区一定会占用4号分区
      - 回车选择默认的起始扇区
      - Last 扇区:+200M
      - 需要继续划分一个新的逻辑分区时,按n ; 不在划分时,按w 确认划分

  - 刷新分区表

    - ```shell
      partprobe /dev/sdb	#part  probe 分区准备
      ```

  - 查看分区结果

    - ```
      fdisk -l /dev/sdb
      ```

- 创建文件系统(格式化)    //一般是划分好所有分区在格式化这些分区,而不是划分一个就格式化一下

  - 文件系统:房子里的格子柜

  - ```shell
    mkfs.ext4 /dev/sdb1		#make file system extension4第四代扩展  /dev/sdb1 第二个串口硬盘的第一个分区准备格式化
    
    mkfs -t ext4 /dev/sdb1		#也是格式化方式
    
    
    #新创建的分区,sdb2.sdb3 都要格式化
    ```
    

- 挂载mount(mount 挂载是临时的,但是其他操作都是存在的,永久挂载需要写入到/etc/fstab 文件中才行,开机即会挂载,此文件写着磁盘的挂载信息,多一个空格都会导致无法运行)

  - 手动挂载

    - ```shell
      #创建挂载点disk1,一个分区一个挂载点
      mkdir /mnt/disk1
      
      mount -t ext4   /dev/sdb1    /mnt/disk1
      
      umount /dev/sdb1		#卸载挂载点,把门关闭了,相当于拔掉u盘,重新挂载就有了,里面的数据不会消失,除非格式化
      ```

- 查看挂载信息

  - 方法一:

    - ```shell
      df -Th		#disk free	h 人性化显示数字 t 显示分区类型
      
      #文件系统              类型      容量  已用  可用 已用% 挂载点
      devtmpfs              devtmpfs  872M     0  872M    0% /dev
      tmpfs                 tmpfs     901M     0  901M    0% /dev/shm
      tmpfs                 tmpfs     901M  9.6M  891M    2% /run
      tmpfs                 tmpfs     901M     0  901M    0% /sys/fs/cgroup
      /dev/mapper/rhel-root xfs        17G  4.4G   13G   26% /
      /dev/nvme0n1p1        xfs      1014M  229M  786M   23% /boot
      tmpfs                 tmpfs     181M  1.2M  179M    1% /run/user/42
      tmpfs                 tmpfs     181M  4.6M  176M    3% /run/user/0
      /dev/sr0              iso9660   7.9G  7.9G     0  100% /run/media/root/RHEL-8-2-0-BaseOS-x86_64
      
      ```

  - 方法二:

    - ```shell
      mount
      ```

# 二.逻辑卷LVM

重启电脑的方式

```shell
reboot 
#或
init 6	
```

dd 抄写一个文件到另一个文件中

```shell
dd if=/dev/zero of=/mnt/disk4/1.txt  bs=1M count=1000		# if= 指定抄写路径, of= 指定写入文件 bs block 指定抄写多大的空间 count 指定抄写多少次,即向1.txt 写入1000M 大小的空间
```

一个/mnt/disk1 挂载点只能挂载一个分区,如果在挂上另一个分区,那么第一个分区将会失效,而且

物理磁盘的空间是限定的,不便于管理(拷贝,删除,授权)

单靠物理磁盘,是解决不了空间需求增长的问题的

逻辑卷就能解决这个问题

目的:管理磁盘的一种方式,性质与基本磁盘无异

特点:随意扩张大小,缩减大小,快照备份

## 1.术语:

- PV:物理卷(Physical volume)
- VG: 卷组(Volume Group)
- LV: 逻辑卷(Logical Volume)

步骤:

- 买物理硬盘
- 变成物理卷
- 加入卷组
- 在卷组中,抽调空间,制作逻辑卷
- 格式化
  - (格式化的目的都是为创建文件系统,创建文件系统决定文件的放入与取出的格式)
  - 文件准确的放到磁盘的某个位置 和文件在磁盘中快速定位读取都是依靠文件系统
- 挂载

## 2.创建LVM

**准备物理磁盘**

```shell
ll /dev/sd*
```

**pv**

```shell
#将物理磁盘,转换成新的物理卷-pv
pvcreate /dev/sdf 
```

**创建卷组-VG**

```shell
vgcreate vg1 /dev/sdf		#起名卷组的名字为vg1
```

**lv**	(与磁盘中分区一样)

```shell
lvcreate -L 200M -n lv2 vg1		# -L 指定大小,单位M,G ,-n name 卷的名字 ,从vg1 卷组中拿东西
```

**创建文件系统并挂载**

```shell
mksf.ext4 /dev/vg1/lv1		#格式化,格式化形式 /dev/卷组名/逻辑卷名,不能格式化/dev/sdf 因为sdf 变成了一个卷组

#创建挂载点
mkdir /mnt/lv1

#挂载
mount /dev/vg1/lv1 /mnt/lv1

#查看卷组信息
df-hT
#/dev/mapper/vg1-lv1  ...
```

## 3.VG 管理

**扩大VG vgextend**

```shell
#环境:/dev/vg1 容量由4G 扩容到6G

#步骤1:创建PV ,而后使用第二步,将PV 增加到VG 中
pvcreate /dev/sdd1

#步骤2:扩展VG,同时包含方法一
vgextend vg1 /dev/sdd1

#查看卷组空间
vgs
#显示
  VG  		 #PV  		#LV 	#SN 	 Attr   	VSize	   VFree
#卷组名    物理卷个数,	逻辑卷个数 	编号		属性		 总空间	实际剩余空间
  rhel   1   2   0 wz--n- <19.00g    0 		#rhel 系统创建的

```

## 4.LV 扩容

### **扩大LV lvextend**

#### 1.lv 扩容

```shell
#1.查看VG 空间,观察VG 是否有剩余空间
vgs

#2.扩容LV
lvextend -L +200M /dev/vg1/lv1		#增加200M 空间,给LV1

```

#### 2.FS 扩容(文件系统扩容)

```shell
#先观察文件系统当前容量,大小没有发生改变
df-Th

#再次观察df-hT 的分区大小,和上次对比一下,大小已经发生改变,增加200M 空间
resize2fs /dev/vg1/lv2		#刷新容量,硬盘的容量会上传到文件夹

#再次观察df-hT 的分区大小
df-Th
```



# 三.交换分区管理Swap

作用:'提升' 内存的容量,防止OOM (out of memory 内存溢出) 

swap 大小: 

推荐: 设置交换分区大小为内存的2倍

生产环境下:

大于4GB 而小于16 GB 内存的系统,最小需要4 GB 的交换空间; 

大于16GB 而小于64 GB 内存的系统,最小需要8 GB 的交换空间; 

大于64GB 而小于256 GB 内存的系统,最小需要16 GB 的交换空间; 

## 1.查看当前的交换分区

free

```shell
free -m

#              total        used        free      shared  buff/cache   available
Mem:           1800        1437          88           6         274         205
Swap:          2047         267        1780

```

## 2.增加交换分区

### 1.准备分区

准备将/dev/sde 磁盘,划分为1G 分区为例

```shell
fdisk /dev/sde
```

按n 划分分区

按 p 划分主分区

分区号:1

起始扇区: 默认

Last 扇区:+1G

按 p 查看分区

划分分区后,将类型设置为82 (按t),也可以不设置类型

按w 保存

```shell
lsblk #查看分区
partprobe  /dev/sde    #刷 新,刷磁盘时,不要刷分区,partprobe  /dev/sde 不要写成partprobe  /dev/sde1
ll /dev/sde*	#查看磁盘
```

### 2.格式化

```shell
mkswap /dev/sde1		#显示的UUID 为磁盘的身份证号
```

### 3.挂载

```shell
swapon /dev/sde1		#挂载到虚拟内存中
swapoff /dev/sde1		#取消挂载
```

### 4.验证

```shell
free -m		#查看增加后的分区变大了
```

### 5.问题

**/dev/sda 下有**

- /
  - /home
  - /usr
  - /mnt
    - /mnt/disk1
    - /mnt/disk2
  - /root
  - /boot
  - /var
  - /proc

**/dev/sdb5 挂载到了 /dev/sda 下的/mnt/disk1 下**

在/mnt/disk1 下 , 创建了一个新的文件1,文件1属于/dev/sdb5 磁盘

**卸载/dev/sdb5**, 在 /mnt/disk1 下创建了一个新的文件2,文件2属于/dev/sda 磁盘的/mnt/disk1 下

再次将 **/dev/sdb5 挂载到了 /dev/sda 下的/mnt/disk1 下** ,/mnt/disk1  只有 文件1 存在

**卸载/dev/sdb5**, 只有 文件2  存在

相当于一个U 盘的插入与拔出

**如果想要两个文件都看到,只需要重新挂载时挂载到其他地方下.比如挂载到 /mnt/disk2 下**

/mnt/disk2 下的lost+found 文件夹是一个回收站

# 四.存储管理高级课程

## 1.文件系统详解

**文件系统类型:**

Windows: FAT16 ( 过时), FAT32( 过时) ,NTFS

LINUX :EXT3, EXT4 , XFS

### 1.EXT3/4 文件系统

#### 1.简介

**类型:**

索引(index)文件系统(类似超市的储物柜)

**系统限制:**

EXT3:文件系统最大16TB

EXT4:文件系统最大16TB

XFS:文件系统最大100TB

**名词:**

inode:

- 记录文件的属性(文件的元数据metadate)
  - 元数据:文件的属性,大小,权限,属组,属主,连接数,块的数量,块的编号
- 一个文件占用一个inode, 同时记录此文件数据所在的block number
- inode 大小为 128bytes

block:

- 存储文件的实际数据
- 实际存储文件的内容,若文件较大,会占用多个block,多个文件不能占用同一个块,如果前面的块被清除,又添加新的文件,文件会占用被清除的块空间,数据大于清除块的空间,在向最后的空闲块中添加
- block 大小 为默认为4k

superblock:

- block 与inode 的总量(相当于描述一个超市有几个储物柜)
- 未使用与已使用的inode /block 数量

#### 2.示例

在/mnt/disk4(分区) 下创建一个文件,观察inode 信息

```shell
touch 1.txt  #创建文件,每创建一个文件,占用一个inode
ll -i 1.txt    # ll -i  文件名	-i inode

#	51503218 -rw-r--r--. 1 root root 0 3月  26 11:13 1.txt
#	inode 号

#查看分区有多少inode 可用
df -i
#
文件系统                Inode  	已用(I)   可用(I)     已用(I)    % 挂载点
devtmpfs               223207     359   222848       1%      /dev
tmpfs                  230479       1   230478       1%     /dev/shm


#当文件创建的个数大于可用的inode 时,就会报错没有空间
touch {1..222848}.txt	#创建222848 个文件
ls -l |wc -l     #wc 查看文件个数
df -hT 	#查看剩余空间
```

**结论:inode 决定文件系统中文件的数量**

**inode 虽然用完,但是可以在现有文件中写入内容,因为inode 占用很少空间,block 决定空间的大小**

**磁盘空间的限制根据inode 和block 两方面**

## 2.文件链接

### 1.符号链接

#### 1.名词解释

​	symbolic link /软链接

#### 2.示例

创建一个文件,并输入内容

```shell
echo 11 > 1.txt
```

创建一个软链接

```shell
ln -s /1.txt  /home/2.txt		#ln link ,  -s symbolic  文件路径  软连接路径
```

观察软链接

```shell
ll /home/2.txt		
#lrwxrwxrwx. 1 root root 7 3月  26 11:42 2.txt -> ./1.txt	
#l 软链接 权限:可读可写可执行

#软连接指向文件所在的位置,向文件中添加内容,软连接的内容也会被修改
#删除源文件后,软连接失效,且开始闪烁(ll 下查看)
```

**总结:**

**软连接像快捷方式,可以对文件和目录做软连接**

**软连接记录的只是源文件的绝对路径**

**软连接失去源文件时不可用**

### 2.硬链接

创建同分区硬链接成功,创建不同分区硬链接失败

```shell
echo 11 > 1.txt
```

创建一个硬链接

```shell
ln  /1.txt  /home/2.txt		#ln link  文件路径  硬连接路径
```

硬链接的inode 号相同,但并不占用block,使用df -k 或 ll 观察硬链接数量变化,删除一个硬连接,硬连接数量就会减少

```shell
 ln  /1.txt  /mnt/disk5/2.txt     #ln link  文件路径  硬连接路径
```

不允许将硬链接指向目录

删除源文件后,硬链接文件依然有效,保存着内容,与复制不一样,源文件和链接文件都同步保持同一内容



## 3.RAID(了解)

保障数据的安全,提高读写输速率

### 1.简介

**RAID: 廉价磁盘冗余阵列(Redundant Array of Independent Disks)**

**作用:容错,提升读写速率**

### 2.类型

**RAID0**

> RAID0 : 条带集 2块磁盘以上,读写速率块 100%*N ,但不容错
>
> 将数据分成2部分写入2个磁盘,读写速率提高1倍

**RAID1**

> RAID1 : 镜像集(镜像卷) 2 块磁盘(2块一起用),容量50%(同时写入,一个磁盘备份),读写速率一般,容错

**RAID5**

> RAID5 : 带奇偶校验条带集 3块磁盘以上,利用率(n-1)/n 读写速率快,容错
>
> 两块磁盘对半存储数据,根据算法得出校验存储在第三块磁盘(相当于1+1=2)
>
> 如果一块磁盘坏了,根据算法逆推出坏的磁盘的数据(2-1=1),如果损坏2快以上,将无法恢复
>
> 第四块磁盘为热备盘,如果有一块磁盘损坏,热备盘会替换顺坏的磁盘
>
> 磁盘越多,读写速率越快
>
> 利用率: n-1 块磁盘存储数据,1块磁盘存储校验

### 3.不同场景RAID 的使用

**硬RAID: **需要RAID 卡,有自己的CPU ,处理速度快,有电池和无电池

**软RAID: **通过操作系统实现,比如Windows,Linux

### 4.软RAID 示例

#### 1.准备4块硬盘

**查看磁盘**

```shell
ll /dev/sd*
```

**RAID5 (3块硬盘)+热备(1块硬盘),各1G**

#### 2.创建RAID

```shell
#安装命令
yum -y install mdadm   #确保mdadm 命令可用

mdadm -C /dev/md0	-l5 -n3 -x1 /dev/sd{d,e,g,f}
# -C 创建RAID
# /dev/md0 自定义第一个RAID 设备名词
# -l5 RAID5,  level 级别	0-5 代表 RAID0 - RAID5
#-n RAID 成员数量,n3 3块磁盘
#-x 热备磁盘的数量
#可用空间2G
```



#### 3.格式化,挂载

```shell
#格式化
mkfs.ext4 /dev/md0

#创建文件夹
mkdir /mnt/raid5

#挂载到文件夹
mount /dev/md0 /mnt/raid5

#拷点数据
cp -rf /etc/ /mnt/raid5/etc1

#检查磁盘
df-hT
#显示只有2G 空间, 因为2 个磁盘存储数据(2G),一个校验磁盘,一个热备磁盘
```



#### 4.查看RAID 信息

```shell
mdadm -D /dev/md0  # -D 查看详细信息
#显示
#...
Version		版本
Raid Level		raid 类型,raid5
Array Size	磁盘大小
Used Dev Size 已使用大小
Raid Devices 	几块磁盘 3 
Total Devices	一共几块磁盘 4
Active Devices		活跃存储数据磁盘数
Spare Devices		空闲磁盘数,热备磁盘
Failed Devices	损坏的磁盘个数
Working Devices 正在工作的磁盘数
```



#### 5.模拟一块硬盘损坏并移除

```shell
#终端1
watch -n0.5 'mdadm -D /dev/md0 |tail -10'	#watch 实时查看, -n 刷新时间 0.5s, -D 检查

#终端2
mdadm /dev/md0 -f /dev/sde -r  /dev/sde		#mdadm 要操作的Raid 设备名 -f 强制操作哪个磁盘 -r  删除磁盘   ,此时热备磁盘会自动使用,替换损坏的磁盘并保存数据
```



#### 6.设置RAID 开机生效

#### 参考

