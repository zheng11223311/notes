1. 安装脚手架

```bash
npm install -g electron-forge
```

1. 安装热更新

```
npm i nodemon
```

1. 使用 electron-forge 创建工程

```
electron-forge init 项目名称
```

1. 启动项目

```
npm start
```



index.js

```js
 //  此配置文件的修改需要重启app 才能使用修改后的配置
 const {
     app, //引用app
     BrowserWindow, //引用桌面窗口
     net, //自带请求模块
     globalShortcut, //快捷键设置模块
     BrowserView, //引用嵌套网页框架
     Menu, //菜单栏
     ipcMain,
     dialog, //主进程发送和接收事件的模块
 } = require('electron')

 var mainWindow = null //声明要打开的主窗口


//  监听新建文件的保存
 ipcMain.on('saveCreateNewFile', (event) => {
     dialog.showSaveDialog({
         title: "文件另存为",
         //  defaultPath:'文件1',       //默认文件名称
         filters: [{ //默认文件格式,name 保存类型的名称(All Files),extensions 保存类型的类型(*.*)
             name: 'All Files',
             extensions: ['*']
         }, {
             name: 'Text Files',
             extensions: ['txt']
         }]
     }).then(filename => {
         console.log(filename);
         mainWindow.webContents.send('saveOtherFile', filename)
     })
 })

 //  导航菜单栏
 let menuTmp = [{
         label: '文件', //主标签
         submenu: [{
                 label: "新建文件",
                 accelerator: 'ctrl+n',
                 click: () => {
                     mainWindow.webContents.send('createNewFile')
                 }
             },
             {
                 label: "打开文件",
                 accelerator: 'ctrl+o',
                 click: () => {

                     dialog.showOpenDialog({
                         properties: ['openFile'], //属性,打开文件
                     }).then(result => {
                         mainWindow.webContents.send('openFile', result.filePaths, result.canceled)
                         //    console.log(result.filePaths);     //文件路径
                         //    console.log(result.canceled);      //是否取消
                     })
                 }
             },
             {
                 label: "保存文件",
                 accelerator: 'ctrl+s',
                 click: () => {
                     mainWindow.webContents.send('saveFile')
                 }
             },
             {
                 label: "文件另存为",
                 accelerator: 'ctrl+s+shift',
                 click: () => {
                     dialog.showSaveDialog({
                         title: "文件另存为",
                         //  defaultPath:'文件1',       //默认文件名称
                        //  列出可选文件格式
                         filters: [{ //默认文件格式,name 保存类型的名称(All Files),extensions 保存类型的类型(*.*)
                             name: 'All Files',
                             extensions: ['*']
                         }, {
                             name: 'Text Files',
                             extensions: ['txt','js']
                         }]
                     }).then(filename => {
                         console.log(filename);
                         mainWindow.webContents.send('saveOtherFile', filename)
                     })

                 }
             },
             {
                label: "退出",
                accelerator: 'ctrl+alt+z',
                click: () => {
                   mainWindow.close()
                }
            },
         ]
     },
     {
         label: '编辑', //主标签
         submenu: [{
                 role: 'undo',
                 label: '撤回',
             }, //role 使用原生封装好的功能,撤回功能
             {
                 type: 'separator'
             },
             {
                 role: 'redo',
                 label: '反撤回',
             },
             {
                 role: 'paste',
                 label: '粘贴',
             },
             {
                 role: 'cut',
                 label: '剪切',
             },
             {
                 role: 'copy',
                 label: '复制',
             },
         ]
     },

     {
         label: '视图',
         submenu: [

         ]
     },
     {
         label: '帮助',
         submenu: [

         ]
     }
 ]


 //  替换掉原生的导航栏菜单
 var m = Menu.buildFromTemplate(menuTmp) //构建
 Menu.setApplicationMenu(m) //使用导航栏


 let createWindow = (url) => { //自定义 创建窗口函数
     let mainWindow1 = new BrowserWindow({
         width: 1300, //窗口的宽
         height: 600, //窗口的高
         webPreferences: {
             nodeIntegration: true, //允许所有的node 库运行,不写的话node 相关的库就无法使用,是否完整支持node. 默认为 true.
             contextIsolation: false, //同上一起配置,窗口的环境隔离
             enableRemoteModule: true, //允许使用多窗口remote
             webviewTag: true, //允许在html 上使用webview 标签(即使html 支持webview 标签),不设置webview 没有效果
         }
     })
     //  mainWindow1.loadFile('html/3-opennewwindow.html') //加载应用的界面
     mainWindow1.loadURL(url) //加载远程资源
     mainWindow1.on('closed', () => { //监听子窗口的关闭
         console.log('窗口关闭');
         mainWindow1 = null //销毁程序,否则每次打开都会生成占用内存空间
     })
     mainWindow1.webContents.openDevTools(); //打开调试工具
 }





 app.on('will-quit', () => { //当所有窗口已关闭并且应用程序都已经退出时发出

 })


 //  等同于 app.whenReady().then(createWindow)
 app.on('ready', () => { //生命周期函数,监听窗口准备

     mainWindow = new BrowserWindow({
         width: 1300, //窗口的宽
         height: 600, //窗口的高
         backgroundColor: '#ccc', //窗口的背景颜色
         //  icon:path.join(__dirname,'./img/favicon.ico'),   //窗口的图标
         icon: './img/favicon.ico', //窗口的图标
         webPreferences: {
             nodeIntegration: true, //允许所有的node 库运行,不写的话node 相关的库就无法使用,是否完整支持node. 默认为 true.
             contextIsolation: false, //同上一起配置,窗口的环境隔离
             enableRemoteModule: true, //允许使用多窗口
             webviewTag: true, //允许在html 上使用webview 标签(即使html 支持webview 标签),不设置webview 没有效果
         }
     })
     //  与子窗口保持通信,主进程与渲染进程通信必写
     require('@electron/remote/main').initialize()
     require("@electron/remote/main").enable(mainWindow.webContents)

     mainWindow.loadFile('index.html') //加载应用的界面
     mainWindow.on('closed', () => { //监听窗口的关闭
         console.log('窗口关闭');
         mainWindow = null //销毁程序,否则每次打开都会生成占用内存空间
     })
     mainWindow.webContents.openDevTools(); //打开调试工具

     //      setTimeout(()=>{ //延时,主进程创建之后就发送消息过快,页面还没有显示,所以会没有打印主进程发送的消息
     //         mainWindow.webContents.send('newindex', '主窗口发送事件111')
     //    },4000)


 })

 app.on('window-all-closed', () => { //  监听所有子程序都关闭时
     if (process.platform !== 'darwin') {
         app.quit() //app 退出
     }
 })

 app.on('activate', () => { //  监听激活程序,即点击了图标开启程序
     if (BrowserWindow.getAllWindows().length === 0) { //开启窗口

     }
 })
```

index.html

```js
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>郑先森的文本编辑器</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
        }

        #textarea {
            width: 100vw;
            height: 100vh;
            border: none;
            font-size: 25px;
            /* 禁止拉伸 */
            resize: none;
            outline: none;
            padding: 10px;
        }
    </style>
</head>

<body>

    <textarea name="" id="textarea" cols="30" rows="10"></textarea>
    <script>
        const {
            ipcRenderer,
            dialog, //主进程发送和接收事件的模块
        } = require('electron')
        const fs = require('fs')

        // const re = require('@electron/remote')
        // let BrowserWindow = re.BrowserWindow

        let filePath = ''
        let fileTitle = '郑先森的文本编辑器'
        let isSaveFile = true //文件是否已保存

        // 监听打开文件
        ipcRenderer.on('openFile', (event, path, canceled) => {
            // console.log(path, canceled);
            fs.readFile(path[0], (err, data) => {
                if (err) {
                    console.log(err);
                    alert('发生错误,请重试!!')
                    return
                }
                // for (const key in data.toString()) {   //是否存在换行
                //     if(data.toString().charAt(key)=='\n'){
                //     console.log('哈哈哈');
                // }
                // }
                filePath = path[0]
                let titleLength = path[0].split('\\')
                let title = titleLength[titleLength.length - 1]
                fileTitle = title
                document.title = '打开文件 - ' + title
                // console.log(data.toString());
                textarea.value = `${data.toString()}` //value 有换行和空格效果,innerText 没有


                // console.log(textarea.value);

                // 监听文本变化,显示是否修改过文本,标题带有*
                // textarea.oninput = () => {
                //     // console.log(textarea.value);
                //     // document.title = '文件未保存 - ' + title + '*'
                //     // isSaveFile = false //实现 窗口关闭时提示未保存
                // }
            })



        })

        // 监听保存文件
        ipcRenderer.on('saveFile', (event) => {
            if (filePath == '') { //不存在路径,新建文件
                ipcRenderer.send('saveCreateNewFile')
            } else { //存在路径,保存文件
                fs.writeFile(filePath, textarea.value, (err) => {
                    if (err) {
                        console.log(err);
                        alert('发生错误,请重试!!')
                        return
                    }
                    document.title = '文件已保存 - ' + fileTitle
                })
            }

        })
        // 监听文件另存为
        ipcRenderer.on('saveOtherFile', (event, file) => {
            // if (filePath == '') return //没有打开的文件,不能另存为
            // console.log(file);
            console.log(file.filePath);
            // if (filePath == '') {
            //     //如果没有打开的文件路径,则为新建文件

            // }
            if (file.filePath == '') {
                console.log('取消另存为');
                return //如果点击另存为时又退出
            }
            fs.writeFile(file.filePath, textarea.value, (err) => {
                if (err) {
                    console.log(err);
                    alert('发生错误,请重试!!')
                    return
                }
                document.title = '文件已另存至 - ' + file.filePath
            })
        })


        //监听新建文件
        ipcRenderer.on('createNewFile', () => {
            // 初始化
            document.title = '新建文件 - united*'
            filePath = ''
            isSaveFile = false
            textarea.value = ''
            fileTitle = ''

        })

        // 监听文本变化,显示是否修改过文本,标题带有*
        textarea.oninput = () => {
            // console.log(textarea.value);
            if (fileTitle != ''&&fileTitle!='郑先森的文本编辑器') {
                document.title = '文件未保存 - ' + fileTitle + '*'
            } else {
                document.title = '新文件未保存 - united*'
            }
            isSaveFile = false //实现 窗口关闭时提示未保存
        }

        //外部拖动文件进入
        textarea.addEventListener('drop', (e) => { //监听文件落下
            e.preventDefault(); //阻止默认事件
            e.stopPropagation() //阻止冒泡事件
            console.log(e.dataTransfer.files);
            // console.log(e.dataTransfer.files[0]);
            // console.log(typeof e.dataTransfer.files); //object
            // console.log(typeof e.dataTransfer.files[0]); //object
            for (const file of e.dataTransfer.files) {
                fs.readFile(file['path'], (err, data) => {
                    if (err) {
                        console.log(err);
                        alert('发生错误,请重试!!')
                        return
                    }
                    filePath = file.path
                    let title = file.name
                    fileTitle = title
                    document.title = '打开文件 - ' + title
                    textarea.value = `${data.toString()}` //value 有换行和空格效果,innerText 没有
                    textarea.oninput = () => {
                        // console.log(textarea.value);
                        document.title = '文件未保存 - ' + title + '*'
                        isSaveFile = false //实现 窗口关闭时提示未保存
                    }
                })
            }

        })

        textarea.addEventListener('dragover', (e) => {
            e.preventDefault(); //阻止默认事件
            e.stopPropagation() //阻止冒泡事件
        })
    </script>
</body>

</html>
```



# 编译打包

```
npm run make
```

该命令会将文件打包到当前项目目录下的`out`文件夹下,打包后发现,源码直接暴露在`[app 项目目录]\out\安装包名-win32-x64\resources\app\src`目录下

修改`package.json`,在`electronPackagerConfig`部分添加`"asar":true`

