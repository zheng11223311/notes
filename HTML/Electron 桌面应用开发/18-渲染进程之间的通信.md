# 渲染进程与渲染进程之间的通信(webContents)

进程:主进程

在 主进程与渲染进程 一文中,我提到了 依赖与chrome 内核的多进程架构,我们可以在Electron 的每个页面使用自己的线程,于是我们可能出现这样一种需求

我们需要在多个页面中进行通信,从前端的角度来讲,我们可以使用loaclStorage ,来保存会话

但是本文将以electron 的方式来解决这个问题



1.首先我们会将在渲染进程中利用inpRenderer 发送消息到主进程中

index.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文件拖动</title>
    <style>
        .wv {
            width: 640px;
            height: 480px;
        }
    </style>
</head>

<body>

    <button onclick="sendmsg()">向主进程发送消息</button>
    <script>
        let {
            ipcRenderer, //渲染进程的发射和监听事件的模块
            // BrowserWindow, //引用桌面窗口,子窗口使用的是主线程的返回窗口的BrowserWindow ,不能在子线程导入使用新的BrowserWindow
        } = require('electron')


        function sendmsg() {
            //  渲染进程向主进程发射事件
            ipcRenderer.send('openWindow', '打开新串口')
        }

        //监听新窗口发送的事件
        ipcRenderer.on('tonews', (event, data) => {
            console.log('新页面传递过来的消息: ' + data);
        })
    </script>
</body>

</html>
```

index.js

```js
 //  此配置文件的修改需要重启app 才能使用修改后的配置
 const {
     app, //引用app
     BrowserWindow, //引用桌面窗口
     net, //自带请求模块
     globalShortcut, //快捷键设置模块
     BrowserView, //引用嵌套网页框架
     Menu, //菜单栏
     ipcMain, //主进程发送和接收事件的模块
 } = require('electron')


 //  监听渲染进程传递过来的事件
 ipcMain.on('openWindow', (event, data) => {
     console.log('子窗口发送的消息: ', data);
     // 通过getFocuseWindow 静态方法,获取当前焦点窗口的指针ID
     let winId = BrowserWindow.getFocusedWindow().id
     console.log('id ' + winId);
     // 配置窗口
     const newsWindow = new BrowserWindow({
         width: 1000,
         height: 600,
         webPreferences: {
             nodeIntegration: true, //开启渲染进程中使用nodejs
             contextIsolation: false, //开启渲染进程中使用nodejs    In Electron 12, the default will bechanged to `true  
             enableRemoteModule: true //启用Remote模块
         }
     });
     //  与子窗口保持通信,主进程与渲染进程通信必写
     //  require('@electron/remote/main').initialize()  已经在其他地方初始化了
     require("@electron/remote/main").enable(newsWindow.webContents)
     newsWindow.loadFile('html/4-index-remote.html');
     // 监听新窗口加载
     newsWindow.webContents.on('did-finish-load', (event) => {     // (event,data) => { 传递参数就会使用参数 导致undefined
         newsWindow.webContents.send("tonews", data,winId);
     })

 })


 let createWindow = (url) => { //自定义 创建窗口函数
     let mainWindow1 = new BrowserWindow({
         width: 1300, //窗口的宽
         height: 600, //窗口的高
         webPreferences: {
             nodeIntegration: true, //允许所有的node 库运行,不写的话node 相关的库就无法使用,是否完整支持node. 默认为 true.
             contextIsolation: false, //同上一起配置,窗口的环境隔离
             enableRemoteModule: true, //允许使用多窗口remote
             webviewTag: true, //允许在html 上使用webview 标签(即使html 支持webview 标签),不设置webview 没有效果
         }
     })
     //  mainWindow1.loadFile('html/3-opennewwindow.html') //加载应用的界面
     mainWindow1.loadURL(url) //加载远程资源
     mainWindow1.on('closed', () => { //监听子窗口的关闭
         console.log('窗口关闭');
         mainWindow1 = null //销毁程序,否则每次打开都会生成占用内存空间
     })
     mainWindow1.webContents.openDevTools(); //打开调试工具
 }



 var mainWindow = null //声明要打开的主窗口

 app.on('will-quit', () => { //当所有窗口已关闭并且应用程序都已经退出时发出

 })


 //  等同于 app.whenReady().then(createWindow)
 app.on('ready', () => { //生命周期函数,监听窗口准备

     mainWindow = new BrowserWindow({
         width: 1300, //窗口的宽
         height: 600, //窗口的高
         backgroundColor: '#ccc', //窗口的背景颜色
         //  icon:path.join(__dirname,'./img/favicon.ico'),   //窗口的图标
         icon: './img/favicon.ico', //窗口的图标
         webPreferences: {
             nodeIntegration: true, //允许所有的node 库运行,不写的话node 相关的库就无法使用,是否完整支持node. 默认为 true.
             contextIsolation: false, //同上一起配置,窗口的环境隔离
             enableRemoteModule: true, //允许使用多窗口
             webviewTag: true, //允许在html 上使用webview 标签(即使html 支持webview 标签),不设置webview 没有效果
         }
     })
     //  与子窗口保持通信,主进程与渲染进程通信必写
     require('@electron/remote/main').initialize()
     require("@electron/remote/main").enable(mainWindow.webContents)

     mainWindow.loadFile('index.html') //加载应用的界面
     mainWindow.on('closed', () => { //监听窗口的关闭
         console.log('窗口关闭');
         mainWindow = null //销毁程序,否则每次打开都会生成占用内存空间
     })
     mainWindow.webContents.openDevTools(); //打开调试工具

     //      setTimeout(()=>{ //延时,主进程创建之后就发送消息过快,页面还没有显示,所以会没有打印主进程发送的消息
     //         mainWindow.webContents.send('newindex', '主窗口发送事件111')
     //    },4000)


 })

 app.on('window-all-closed', () => { //  监听所有子程序都关闭时
     if (process.platform !== 'darwin') {
         app.quit() //app 退出
     }
 })

 app.on('activate', () => { //  监听激活程序,即点击了图标开启程序
     if (BrowserWindow.getAllWindows().length === 0) { //开启窗口

     }
 })
```

html/4-index-remote.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>渲染线程之间通信的 新窗口</title>
</head>

<body>
    <script>
        const {
            ipcRenderer
        } = require("electron");

        const re = require('@electron/remote')
        let BrowserWindow = re.BrowserWindow
        console.log(re);
        console.log(BrowserWindow);


        // 监听新页面传递过来的newIndex 事件
        ipcRenderer.on('tonews', (event, data, id) => {
            console.log(`消息 ${data} 由 ${id} 窗口发送`);
            // console.log(BrowserWindow);
            //通过 id 返回 该窗口的BrowserWindow 对象
            // var id1 = BrowserWindow.fromId(id);
            // 通过webContents 向该窗口传递信息

            // 渲染进程和渲染进程之间的通信
            // id1.webContents.send('tonews111', 'this is new')
            

        })
    </script>
</body>

</html>
```

渲染1->主->渲染2->主->渲染1
