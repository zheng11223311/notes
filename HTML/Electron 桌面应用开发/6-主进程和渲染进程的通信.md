# 渲染进程与主进程的通信模块(ipcMain,ipcRenderer)

**ipcMain:主进程**

从主进程到渲染进程的异步通信

**ipcRenderer: 渲染进程**

从渲染进程到主进程的异步通信

**webContent**

广播式的发送事件 : 当有子进程触发了 主进程 事件,webContents 对象就会向每一个事件进程发送消息

指定式的发送事件 : 我们可以通过formId 去向一个指定的窗体发送消息



index.js

```js
 //  此配置文件的修改需要重启app 才能使用修改后的配置
 var electron = require('electron')

 var app = electron.app //引用app
 var BrowserWindow = electron.BrowserWindow //引用桌面窗口
 var ipcMain = electron.ipcMain //引用进程之间的通信模块


 //  监听渲染进程发送过来的事件
 ipcMain.on('one-message', (event, arg) => { //监听传递过来的通信事件,事件名自定义
     event.reply('one-replay', "这是主进程的答复") //回复事件,事件名自定义
     console.log(arg); //显示在cmd 命令行中,默认不是utf-8 字符,需要执行命令chcp 65001 (65001 为utf-8 编码),或在package.json scripts 下配置启动项
     //  "start":"chcp 65001&&eletron .",
 })

//自动返回消息.相当于上方的  event.reply
//接收子进程以 invoke 发送的消息
ipcMain.handle('one-open-new-window',async (event, data) => {
    console.log(data);
    return data		//将data 返回给子进程,
 })

 //  监听渲染进程发送过来打开新窗口的事件
 ipcMain.on('one-open-new-window', (event, arg) => {
    createWindow('http://www.baidu.com')
    createWindow('http://www.taobao.com')
 })

 ipcMain.on('one-open-new-window', (event, arg) => {
    //广播式的发送事件
     webcontents.getAllWebContents().forEach(item=>{
         item.send('one-open-new-window-reply',1111111111111111)
     })
     //指定式的发送消息
     webcontents.fromId(1).send('one-open-new-window-reply',1111111111111111)
     //fromId(1) 指定的id 为1,即每个窗体 mainWindow.webContents.id 设置的id
     //let id=mainWindow.webContents.id
 })


 let createWindow = (url) => {      //自定义 创建窗口函数
     let mainWindow1 = new BrowserWindow({
         width: 1300, //窗口的宽
         height: 600, //窗口的高
         webPreferences: {
             nodeIntegration: true, //允许所有的node 库运行,不写的话node 相关的库就无法使用,是否完整支持node. 默认为 true.
             contextIsolation: false, //同上一起配置,窗口的环境隔离
             enableRemoteModule: true, //允许使用多窗口
             webviewTag: true, //允许在html 上使用webview 标签(即使html 支持webview 标签),不设置webview 没有效果
         }
     })
    //  mainWindow1.loadFile('html/3-opennewwindow.html') //加载应用的界面
      mainWindow1.loadURL(url) //加载远程资源
     mainWindow1.on('closed', () => { //监听子窗口的关闭
         console.log('窗口关闭');
         mainWindow1 = null //销毁程序,否则每次打开都会生成占用内存空间
     })
     mainWindow1.webContents.openDevTools(); //打开调试工具
 }



 var mainWindow = null //声明要打开的主窗口


 app.on('ready', () => { //生命周期函数,监听窗口准备
     mainWindow = new BrowserWindow({
         width: 1300, //窗口的宽
         height: 600, //窗口的高
         webPreferences: {
             nodeIntegration: true, //允许所有的node 库运行,不写的话node 相关的库就无法使用,是否完整支持node. 默认为 true.
             contextIsolation: false, //同上一起配置,窗口的环境隔离
             enableRemoteModule: true, //允许使用多窗口
             webviewTag: true, //允许在html 上使用webview 标签(即使html 支持webview 标签),不设置webview 没有效果
         }
     })
     mainWindow.loadFile('index.html') //加载应用的界面
     mainWindow.on('closed', () => { //监听窗口的关闭
         console.log('窗口关闭');
         mainWindow = null //销毁程序,否则每次打开都会生成占用内存空间
     })
     mainWindow.webContents.openDevTools(); //打开调试工具

     setTimeout(() => { //延时,主进程创建之后就发送消息过快,页面还没有显示,所以会没有打印主进程发送的消息
         //  主动发送消息给渲染进程(子进程)
         mainWindow.webContents.send('index-message', '创建主进程后,主进程主动发送数据到渲染进程')
     }, 2000)
 })

 app.on('window-all-closed', () => { //  监听所有子程序都关闭时
     if (process.platform !== 'darwin') {
         app.quit() //app 退出
     }
 })

 app.on('activate', () => { //  监听激活程序,即点击了图标开启程序
     if (BrowserWindow.getAllWindows().length === 0) { //开启窗口
         // mainWindow = new BrowserWindow({
         //     width: 1300, //窗口的宽
         //     height: 600, //窗口的高
         //     webPreferences: {
         //         nodeIntegration: true, //允许所有的node 库运行,不写的话node 相关的库就无法使用,是否完整支持node. 默认为 true.
         //         contextIsolation: false, //同上一起配置,窗口的环境隔离
         //         enableRemoteModule: true, //允许使用多窗口
         //         webviewTag: true, //允许在html 上使用webview 标签(即使html 支持webview 标签),不设置webview 没有效果
         //     }
         // })
         // mainWindow.loadFile('index.html') //加载应用的界面
         // mainWindow.on('closed', () => { //监听窗口的关闭
         //     console.log('窗口关闭');
         //     mainWindow = null //销毁程序,否则每次打开都会生成占用内存空间
         // })
         // mainWindow.webContents.openDevTools(); //打开调试工具
     }
 })
```

index.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文件拖动</title>
    <style>
        .wv {
            width: 640px;
            height: 480px;
        }
    </style>
</head>

<body>

    <button>点击开启新窗口</button>









    <script>
        //   渲染线程监听事件
        let {
            ipcRenderer
        } = require('electron')
        //   监听主进程发送的消息
        ipcRenderer.on('index-message', (event, arg) => {
            console.log(event);
            console.log(arg);
        })
        //向主进程的handle 发送消息
        ipcRenderer.invoke('index-message', '这是有返回消息的钩子').then(res=>{
            console.log(res)
        })
        //   监听主进程的答复
        ipcRenderer.on('one-replay', (event, arg) => {
            console.log(event);
            console.log(arg);
        })
        // 只触发一次
        ipcRenderer.once('one-replay1', (event, arg) => {
            console.log(event);
            console.log(arg);
        })
         ipcRenderer.on('one-replay', a)
        function a(){}
        //为特定事件,移除特定函数
         ipcRenderer.remove('one-replay1',a())
        //   渲染进程主动发送消息
        ipcRenderer.send('one-message', '这是渲染线程发送的消息')

        let btn = document.querySelector('button')
        btn.onclick = function () {
            //   渲染进程主动发送消息
            ipcRenderer.send('one-open-new-window') //消息内容可以为空,不填
        }
    </script>
</body>

</html>
```

html/3-opennewwindow.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>新打开的窗口</title>
</head>
<body>
    这是主进程监听子进程发送事件后创建出来的新窗口
</body>
</html>
```

package.json

```json
{
  "name": "firstelectron",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start":"chcp 65001&&eletron .",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "electron": "^18.1.0"
  }
}

```

