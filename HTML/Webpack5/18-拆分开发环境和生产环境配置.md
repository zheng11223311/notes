### 1.拆分开发环境和生产环境配置

**1.公共路径**

`publicPath`配置选项在各种场景中都非常有用,你可以通过它来指定应用程序中所有资源的基础路径

- 基础环境设置

  在开发环境中,我们通常有一个`assets/`文件夹,它与索引页面位于同一级别,这没太大问题,但是,如果我们将所有静态资源托管至CDN,然后想在生产环境中使用呢?

  想要解决这个问题,可以直接使用一个`environment variable(环境变量)`,假设我们有一个变量

  `ASSET_PATH`:

  ```js
  import webpack form 'webpack'
  
  //尝试使用环境变量,否者使用根路径
  const ASSET_PATH=process.env.ASSET_PATH||'/'
  
  export default{
      output:{
          //publicPath:'http://localhost:8080/'
          publicPath:ASSET_PATH
      },
      plugins:{
          //这可以帮助我们在代码中安全的使用环境变量
          new webpack.DefinePlugin({
          'process.env.ASSET_PATH':JSON.stringify(ASSET_PATH)
      })
      }
  }
  ```

**2.环境变量**

想要消除`wenbpack.config.js`在 开发环境 和 生产环境 之间的差异,你可能需要环境变量(environment variable)

webpack 命令行 环境配置 的`--env` 参数,可以允许你传入任意数量的环境变量,而在`webpack.config.js`中可以访问到这些环境变量.例如,`--env production`或`--env goal=local`

```
使用--env 传递键值对
npx webpack --env goal=local --env production  --process
```

```
npx webpack --env production 
```

对于我们的webpack 配置	,有一个必要修改之处,通常,`module.exports`指向配置对象,要使用`env`变量,你必须将`module.exports`转换成一个函数:

webpack 配置

```js
module.exports=(env)=>{
    console.log(env)
    return {
        //webpack.config.js 的其他配置...
        //根据命令行参数 env 来设置不同环境变量的 mode
        mode:env.production?'production':'development'
    }
}
```

**压缩插件**

```
npm install terser-webpack-plugin -D
```

webpack 配置:

```js
const TerserPlugin=require('terser-webpack-plugin')

module.exports=(env)=>{
    console.log(env)
    return {
        //webpack.config.js 的其他配置...
        //根据命令行参数 env 来设置不同环境变量的 mode
        mode:env.production?'production':'development'
        optimization:{
        	minimizer:[
        		new TerserPlugin()
        	]
    	}
    }
}
```

**3.拆分配置文件**

目前,生产环境和开发环境使用的是一个配置文件,我们需要将这两个文件单独放到不同的配置文件中,如果`webpack.config.dev.js`(开发环境配置) 和 `webpack.config.prod.js`(生产配置环境). 在项目根目录下创建一个配置文件夹`config`来存放它们.

`webpack.config.dev.js`配置如下:

```js
//...
const TerserPlugin=require('terser-webpack-plugin')

module.exports={
        //除去生产环境下的压缩等配置 webpack.config.js 的其他配置...
        mode:'development'
        optimization:{
        	minimizer:[
    			//...
        		new TerserPlugin()
        	]
    	}
}
```

**使用配置文件**

```
npx webpack -C	./config/webpack.config.dev.js						//-c 为config 的缩写,指定配置文件的路径
```

打包后的文件在`config`中,这是因为`output`输出时在当前文件夹下`./dist`

```
npx webpack server -C ./config/webpack.config.dev.js		    //相当于使用webpack-dev-server
```

**4.npm 脚本**

每次打包或启动服务器时,都需要在命令行里输入一长串的命令,我们将父目录的`package.json`,`node_modules`与`package-lock.json`拷贝到当前目录下

配置 npm 脚本来简化命令行的输入,这时可以省略`npx`:因为本地已经有这个包了

配置`package.json`文件:

```json
{
    "scripts"{
    	"start":"webpack server -C ./config/webpack.config.dev.js",
    	"build":"webpack  -C ./config/webpack.config.prod.js"
	}
	
}
```

开发环境运行脚本:

```
npm run start
```

```
npm run build
```

有时候会出现打包文件过大的警告,`webpack.config.prod.js`可以使用添加以下配置去除警告

```js
module.exports={
    //....
    performance:{
        hints:false
    }
}
```

**5.提取公共配置**

这时,我们发现两个配置文件里存在大量的重复代码,可以手动的将这些重复的代码单独提取到一个文件里,创建`webpack.config.common.js`,配置公共的内容:

```js
const path=require('path')
const HtmlWebpackPlugin=require('html-webpack-plugin')

module.exports={
	entry:'./src/index.js',		//入口文件,./src/index.js 为项目下的文件
	output:{		//设置出口文件
		filename:'bundle.js',		//指定输出文件名 
		path:path.resolve(__dirname,'./dist'),			//指定输出路径,为绝对路径
        clean:true,					//清除上一次打包的内容
	},
	plugins:{		//插件
		//new HtmlWebpackPlugin(),		//自动生成index.html 并引入打包后的js 文件
        new HtmlWebpackPlugin({			//根据自己的模板生成index.html 文件
        	template:'./index.html',	//根据当前目录下的index.html 为模板
        	filename:'app.html',		//输出的文件名
        	inject:'body',				//在body 标签内引入打包后的js 文件
    	}),
    		//new MiniCssExtractPlugin(),			//实例化抽离插件,将多个css 文件合并成一个文件,生成main.css  
        new MiniCssExtractPlugin({
    		filename:'style/[contenthash].css',		//输出的文件名			
		}),		
	},
    module:{
        rules:[
            {
                test:/\.png$/,
                type:"asset/resource"		//加载资源类型
        	},
            {
                est:/\.(css|less)$/i,		
                use:[MiniCssExtractPlugin.loader,'css-loader','less-loader']	//加载抽离插件,MiniCssExtractPlugin.loader 代替style-loader,style-loader 是将css 加载到html 中 ,而插件是将css 单独抽离出来,打包到main.css 文件中,HtmlWebpackPlugin 自动将main.css 引入到生成的html 中
        	}
        ]
	},
}
```

提取公共部分,同时删除 dev 和prod 配置文件的共有的部分

**6.合并配置文件**

配置文件拆分好后,新的问题来了.如何保证配置文件合并没有问题呢?`webpack-merge` 这个工具可以完美解决这个问题

安装`webpack-merge`:

```
npm install webpack-merge -D
```

创建`webpack.config.js`,合并代码:

```js
const {merge}=require('webpack-merge')

const comment=require('./webpack.config.common.js')
const prod=require('./webpack.config.prod.js')
const dev=require('./webpack.config.dev.js')

module.exports=(env)=>{
    switch(true){
        case env.developement:
            return merge(comment,dev)
        case env.production:
            return merge(comment,prod)
        default:
            return new Error('没有匹配到的config 配置')
    }
}
```

配置`package.json`文件:

```json
{
    "scripts"{
    	"start":"webpack server -C ./config/webpack.config.js --env developement",
    	"build":"webpack  -C ./config/webpack.config.js --env production"
	}
	
}
```

