### 1.模块解析

webpack 通过reaolver 实现了模块之间的依赖和引用,举个例子:

```js
import _ from 'lodash'
//或者
const add=require('./utils/add')
```

所引用的模块可以是来自应用程序的代码,也可以是第三方库,resolver 帮助webpack 从每个require/import 语句中,找到需要引入到bundle 中的模块代码.当打包模块时,webpack 使用enhanced-resolve 来解析文件路径

(webpack_resolver 的代码实现很有思想,webpack 基于此进行treeshaking,这个概念我们后面会讲到)

**1.webpack 中的模块路径解析规则**

通过内置的enhanced-resolve, webpack 能解析三种文件路径:

- **绝对路径**

  ```js
  import '/home/me/file'
  import 'C:\\Users\\me\\file'
  ```

  由于已经获得文件的绝对路径,因此不需要再做进一步的解析

- **相对路径**

  ```js
  import '../utils/reqFetch'
  import './style.css'
  ```

  这种情况下,使用import 或require 的资源文件所处的目录,被认为是上下文目录,在import/require 中给定的相对路径,enhanced-resolve 会拼接此上下文路径,来生成模块的绝对路径(path.resolve(__dirname,RelativePath)).这也是我们在写代码时最常用的方式之一,另一种最常用的方式则是模块路径

- **模块解析**

  ```js
  import 'module'
  import 'module/lib/file'
  import _ from 'lodash'
  ```

  配置webpack.config.js

  ```js
  const path=require('path')
  
  module.exports={
      mode:'development',
      entry:"./src/app.js",
      
      resolve:{
          alias:{	//对文件位置起别名
              '@':path.reslove(__dirname,'./src')		//将src 目录位置起别名为@
          },
          extensions:['.json','.js','.vue']		//配置require('add') 时,默认读取的扩展名文件,识别顺序从左到右
      }
  }
  ```

  app.js

  ```js
  const add =require('@/add.js')
  ```

  