### 1.常用的代码分离方法

1. 入口起点
   1. 使用`entry`配置手动分离代码
2. 防止重复
   1. 使用`Entry dependencies`或者`SplitChunksPlugin` 去重和分离代码
3. 动态导入
   1. 通过模块的内联函数`import`调用来分离代码

### 2.入口起点

这是迄今为止最简单直观的分离代码的方式,不过,这种方式手动配置较多,并有一些安全隐患,我们将会解决这些问题,先来看看如何从`main bundle`中分离`another module(另一个模块)`:

在`src`目录下创建`another-module.js`文件:

```js
import _ from 'lodash'

console.log(_.join(['Another','nodule','lodash!'],' '))
```

这个模块依赖了`lodash`,需要安装一下:

```
npm i lodash --save-dev
```

修改配置文件:

```js
module.exports={
	entry:{    //配置多入口
        index:'./src/index.js',
        another:'./src/another-module.js'
    },
    output:{
        filename:'[name].bundle.js'		//同步入口的多出口文件,name 为入口的key(index和another)
    }
}
```

缺点:多个`js`文件使用同一个包时,每个文件都会引入相同的包,造成空间的浪费

### 3.防止重复

- 入口依赖

  配置`dependOn option`选项,这样可以在多个`chunk `之间共享模块

  ```js
  module.export={
      entry:{
          index:{
              import:'./src/index.js',
  	        dependOn:'shared',			//定义共享文件
          },
          another:{
              import:'./src/another-module.js',
              dependOn:'shared',
          },
          shared:'lodash'				//共享的文件,当这两个模块中含有lodash 模块,lodash 就会抽离出来共享,shared 和indexanthor 一样也是一个入口文件,也会被打包
      },
      
  }
  ```

也可以通过`splitChunks` 来防止重复

配置

```js
module.export={
    entry:{
        index:'./src/index.js',
        another:'./src/another-module.js',
    },
    optimization:{
        splitChunks:{		//代码抽离
            chunks:"all"    	
        }
    }
}
```

### 4.动态导入

当涉及到动态代码拆分时,`webpack`提供了两个类似的技术,第一种,也是推荐选择的方式是,使用符合`ECMAScript`提案的`import()`语法来实现动态导入,第二种,则是`webpack`的遗留功能,使用`webpack`特定的`require.ensure`,让我们尝试使用第一种......

创建`async-module.js`文件:

```js
function getComponetnt(){
    //import 返回的是promise 对象
    return import('lodash')
    //结构出default 对象
    .then(({default:_})=>{
        const element=dpcument.createElement('div')
        element.innerHTML=_.join(['hello','webpack'],' ')
        return element
    })
}

getComponetnt.then((element)=>{
    document.body.appendChild(element)
})
```

动态导入不能和静态文件一起导入,否则失效

### 5.懒加载

懒加载或者按需加载,是一种很好的优化网页或应用的方式,这种方式实际上是先把你的代码在一些逻辑断点处分离开,然后在一些代码块中完成某些操作后,立即引用或即将引用另一些新的代码块,这样加快了应用的初始加载速度,减轻了它的总体体积,因为某些代码块可能永远不会被加载

创建一个`math.js`文件,在	主页面中通过点击按钮调用其中的函数:

```js
export const add=()=>{
    return x+y
}
export const minus=()=>{
    return x-y
}
```

编辑`index.js`文件:

```js
const button=document.createElement('button')
button.textContent="点击执行加法运算"
button.onclick=()=>{
    import(/* webpackChunkName:'math' */ './math.boundle.js').then(({add})=>{
        console.log(add(4,5))
    })
}
document.body.appendChild(button)
```

这里有句注释,我们把它称为`webpack`魔法注释:`webpackChunkName:'math'`,告诉`webpack`打包生成的文件名为`math`,根据上次`webpack`的`output`设置,打包后的名字为`math.boundle.js`

```js
output:{
        filename:'[name].bundle.js'		
}
```

### 6.	预获取/预加载模块

`webpack v4.6.0+`增加了对预获取和预加载的支持

在声明`import`时,使用下面这些内置指令,可以让`webpack`输出`"resource hint(资源提示)"`,来告知浏览器:

- `prefetch(预获取)`:将来某些导航下可能需要的资源
- `preload(预加载)`:当前导航下可能需要资源

下面这个`prefetch`的简单示例中,编辑`index.js`文件:

```js
const button=document.createElement('button')
button.textContent="点击执行加法运算"
button.onclick=()=>{
    import(/* webpackChunkName:'math', webpackPrefetch:true */ './math.js').then(({add})=>{
        console.log(add(4,5))
    })
}
document.body.appendChild(button)
```

添加第二句魔法注释:`webpackPrefetch:true`

告诉`webpack`执行预获取,这回生成`<link ref="prefetch" href="math,js">`并追加到页面头部,指示着浏览器在闲置时间预取`main.js`文件

`webpackPreload:true`

