### 1.八个通用构建优化

**三个环境提升构建性能**

- 通用环境

  1. 更新到最新版本(webpack,node)

  2. 将loader 应用于最少数量的必要模块

  3. 引导(bootstrap)

     1. 每个额外的loader/plugin 都有启动时间,尽量的少使用工具

  4. 解析

     1. 以下步骤可以提高解析速度
        1. 减少reslove.modules,resolve.extensions,reslove.mainFiles,reslove.descriptionFiles 中条目数量,因为它们会增加文件系统调用的次数
        2. 如果你不使用symlinks(例如 npm link 或者yarn link),可以设置resolve.symlinks:false
        3. 如果你使用自定义reslove.plugin 规则,并没有指定context 上下文,可以设置reslove.cacheWithContext:false

  5. 小就是快(smaller=faster)

     1. 减少编译结果的整体大小,以提高构建性能,尽量保持chunk 体积小
        1. 使用数量更少/体积更小的library
        2. 在多页面应用程序中使用SplitChunksPlugin
        3. 在多页面应用程序中使用SplitChunksPlugin,并开启async 模式
        4. 移除未引用代码
        5. 只编译你当前正在开发的那些代码

  6. 持久化缓存

     1. 在webpack 配置中使用cache 选项,使用package.json 中的"postinstall"清除缓存目录

     2. 将cache 类型设置为内存或者文件系统,memory 选项很简单,他告诉webpack 在内存中存储缓存,不允许额外的配置:

        ```js
        module.exports={
        	//...
            cache:{
                type:'memory'
            }
        }
        ```

  7. 自定义plugin/loader

     1. 对它们进行概要分析,以免在此处引入性能问题

  8. process plugin

     1. 将ProcessPlugin 从webpack 中删除,可以缩短构建时间,请注意,ProcessPlugin 可能不会为快速构建提供太多价值,因此,请权衡利弊在使用

  9. dll

     1. 使用DllPlugin 为更改不频繁的代码生成单独的编译结果,这可以提高应用程序的编译速度,尽管它增加了构建过程的复杂度
     
        根目录下创建`webpack.dll.config.js`
     
        ```js
        const path=require('path')
        const webpack=require('webpack')
        
        module.exports={
        	mode:'production',
            entry:{
                jquery:['jquery']
            }
            output:{
            	filename:'[name].js',
            	path:path.resolve(__dirname,'dll'),
                library:'[name]_[hash]',		//导出为第三方的包名
        	},
            plugins:[
                new webpack.DllPlugin({
                    name:'[name]_[hash]',
                    path:path.resolve(__dirname,'dll/manifest.json')
                })
            ]
        }
        ```
     
        `package.json`
     
        ```json
        {
            //..
            "scripts":{
                "dll":"webpack --config ./webapck.dll.config.js"
            }
        }
        ```
     
        执行`npm run dll`
     
        安装add-asset-html-plugin
     
        ```
        npm install add-asset-html-webpack-plugin -D
        ```
     
        `webpack.config.js`
     
        ```js
        const webpack=require('webpack')
        const HtmlWebpackPlugin=require('html-webpack-plugin')
        const AddAssetHtmlPlugin=require('add-asset-html-webpack-plugin')
        
        module.exports={
        	mode:'production',
            entry:'./src/index.js',
            plugins:[
                new webpack.DllReferencePlugin({
                    //./dll/manifest.json 是执行npm run dll 时生成的
                    manifest:path.resolve(__dirname,'./dll/manifest.json')
                }),
                new HtmlWebpackPlugin(),
                new AddAssetHtmlPlugin({	//将juqery 提取出来并引入打包后的html 文件中
                    filepath:path.resolve(__dirname,'./dll/jquery.js'),
                    publicPath:'./'
                })
            ]
        }
        ```
     
        执行`npm webpack`
     
  10. worker 池(worker pool)

      1. thread-loader 可以将非常消耗资源的loader 分流给一个worker pool 

         以下打包花费700ms,thread-loader 启动花费600ms

         > 不要使用太多的worker,因为NodeJS 的runtime 和loader 都有启动开销,最小化worker 和main process(主进程) 之间的模块传输,进程间通讯(IPC,inter process communication) 是非常消耗资源的

         安装thread-loader

         ```
         npm install thread-loader -D
         ```

         `webpack.config.js`

         ```js
         
         module.exports={
         	mode:'production',
             entry:'./src/index.js',
           	
             module:{
                 rules:[
                     {
                         test:'\.js$',
                         exclude:/node_modules/,
                         use:[
                             {
                                 loader:'babel-loader',
                                 options:{
                                     presets:['@babel/preset-env']
                                 }
                             },
                             {
                                 loader:'babel-loader',
                                 options:{
                                     workers:2, 		//cpu 的数量
                                 }
                             }
                         ]
                     }
                 ]
             }
         }
         ```

         `index.js`

         ```js
         class A{
             constructor(){
                 this.a=100
             }
             printA(){
                 console.log(this.a)
             }
         }
         
         const a=new A()
         a.printA()
         ```

         执行`npm webpack`

- 开发环境

- 生产环境

### 1.开发环境提升构建性能

- 增量编译

  使用webpack 的watch mode(监听模式),而不使用其他工具来watch 文件和调用webpack, 内置到的watch mode 会记录时间戳并将此信息传递给compilation 以使缓存失效

  在某些配置环境中,watch mode 会回退到poll mode (轮询模式),监听许多文件会导致CPU 大量负载,在这种情况下,可以使用watchOptions.poll 来增加轮询的间隔时间

- 在内存中编译

  下面几个工具通过在内存中(而不是写入磁盘)编译和serve 资源来提高性能:

  1. webpack-dev-server
  2. webpack-hot-middleware
  3. webpack-dev-middleware

- stats.toJson 加速

  webpack 4 默认使用stats.toJson() 输出大量的数据,除非在增量步骤中做必要的统计,否则请避免获取stats 对象的部分内容

  webpack-dev-server 在v3.13 以后的版本,包含一个重要的性能修复,即最小化每个增量构建步骤中,从stats 对象获取的数据量

- Devtool

  需要注意的是不同的devtool 设置,会导致性能差异

  1. `eval`具有最好的性能,但并不能帮助你转译代码
  2. 如果你接受稍微差一些的map 质量,可以使用cheap-source-map 变体配置来提高性能
  3. 使用eval-source-map 变体进行增量编译

  在大多数情况下,最佳选择是`eval-cheap-module-source-map`

- 避免在生产环境才用到的工具

  某些untility,plugin 和loader 都只是用于生产环境,例如,在开发环境下使用TerserPlugin 来minify(压缩) 和mangle (混淆破坏)代码是没有意义的,通常在开发环境下,应该排除以下这些工具:

  - TerserPlugin
  - [fullhash]/[chunkhash]/[contenthash]
  - AggressiveSplittingPlugin
  - AggressiveMergingPlugin
  - ModuleConcatenationPlugin

- 最小化 entry chunk

  webpack 只会在文件系统中输出已经更新的chunk,某些配置选项(HRM ,output.chunkFilename 的[name]/[chunkhash]/[contenthash],[fullhash]) 来说,除了已经更新的chunk 无效之外,对于entry chunk 也不会生效

  确保在生成entry chunk 时,尽量减少其体积以提高性能,下面的配置为运行时代码创建了一个额外的chunk,所以它的生成代价较低:

  ```js
  module.exports={
      //...
      optimization:{
          runtimeChunk:true,
      }
  }
  ```

- 避免额外的优化步骤

  webpack 通过执行额外的算法任务,来优化输出结果的体积和加载性能,这些优化适用于小型代码库,但是在大型代码库中却非常耗费性能:

  ```js
  module.exports={
  	//...
      optimization:{
          removeAvailableModules:false,
          removeEmptyChunks:false,
          SplitChunks:false,
      }
  }
  ```

- 输出结果不携带路径信息

  webpack 会在输出的bundle 中生成路径信息,然而,在打包数千个模块项目中,这会导致造成垃圾回收性能压力.在options.output.pathinfo 设置中关闭:

  ```js
  module.exports={
  	//...
      output:{
          pathinfo:false,
      }
  }
  ```

- NodeJS 版本8.9.10-9.11.1

  NodeJS v8.9.10-v9.11.1 中的ES2015 Map 和Set 实现,存在性能回退,webpack 大量的使用这些数据结构,因此这次回退也会影响编译时间.

  之前和之后的NodeJS 版本不受影响

- TypeScript Loader

  你可以为loader 传入transPileOnly 选项,以缩短使用ts-loader 时的构建时间,使用此项,会关闭类型检测,如果要再次开启类型检查,请使用ForkTsCheckerWebpackPlugin 使用此插件会将检查过程移至单独的进程,可以加快TypeScript 的类型检查和ESLint 插入的速度

  ```js
  module.exports={
      ///...
      test:/\.tsx?$/,
      use:[
          {
              laoder:'ts-loader',
              options:{
                  transpileOnly:true
              }
          }
      ]
  }
  ```

- 不启用sourceMap

  source map 相当消耗资源,开发环境模式不要设置source map

