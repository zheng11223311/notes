# 组件的创建与引用

### 创建组件

1. 在项目的根目录中,鼠标右键,新建文件夹,创建`components->test` 文件夹 
2. 在新建的`components->test` 文件夹上,鼠标右键,点击`新建Component`
3. 键入组件的名称之后回车,会自动生成组件对应的4 个文件,后缀名分别为 .js , .json , .wxml , .wxss

**注意:为了保证目录结构的清晰,建议把不同的组件,存放到单独目录猴中,例如:**

![](D:\学习\wanye\HTML\微信小程序\笔记\img\29-1.png)





### 引用组件

组件的引用方式分为`局部引用` 和`全局引用`,顾名思义;

- 局部组件:组件只能在当前被引用的页面内使用
- 全局组件:组件可以在每个小程序页面中使用





### 局部引用组件

在页面的 .json 配置文件中引用组件的方式,叫做`局部引用`,示例代码如下:

```json
//在页面的 .json 文件中,引入组件
{
    "usingComponents":{
        "my-test1":"/components/test1/test1"
    }
}
```

```html
<!-- 在页面的 .wxml 文件中,使用组件-->
<my-test1></my-test1>
```





### 全局引用组件

在app.josn 全局配置文件中引入组件的方式,叫做`全局引用`,示例代码如下:

```json
//在app.json 文件中,引入组件
{
    "pages":{},
    "window":{},
    "usingComponents":{
        "my-test1":"/components/test1/test1"
    }
}
```

```html
<!-- 在页面的 .wxml 文件中,使用组件-->
<my-test1></my-test1>
```





### 全局引用 VS 局部引用

根据组件的`使用频率`和`范围`,来选择合适的引用方式:

- 如果某组件`在多个页面中经常被用到`,建议进行`全局引用`
- 如果某组件只是`在特定的页面中被用到`,建议进行`局部引用`





### 组件和页面的区别

从表面来看,组件和页面都是有 .js ,.wxml , .json  , .wxss  这四个文件组成的,但是,组件和页面的 .js 与 .josn 文件有明显的不同:

- 组件的 .json 文件需要声明 `Component:true` 属性
- 组件的 .js 文件中调用的是`Component() `函数
- 组件的事件处理函数需要定义到`.js 文件中的 methods` 节点中





# 样式

### 组件样式隔离

默认情况下, 自定义组件的样式只能对当前组件生效,不会影响到组件之外的UI 结构,如图所示:

- 组件A 的样式`不会影响`组件C 的样式
- 组件A 的样式`不会影响`小程序页面的样式
- 小程序页面的样式`不会影响`组件A 和C 的样式

好处:

1. 防止外界的样式影响组件内部的样式
2. 防止组件的样式破坏外界的样式

![](D:\学习\wanye\HTML\微信小程序\笔记\img\29-2.png)

### 组件样式隔离的注意点

- app.wxss 中的全局样式对组件无效
- 只有class 选择器会有样式隔离效果,id 选择器,属性选择器,标签选择器 不受样式隔离的影响

建议:在`组件`和`引用组件的页面`中建议使用class 选择器,`不要使用id ,属性,标签选择器`





### 修改组件的样式隔离选项

默认情况下,自定义组件的`样式隔离特性`能够`防止组件内外样式互相干扰的问题`,但有时,我们希望在外界能够控制组件内部的样式,此时,可以通过`stylesolation`修改组件的样式隔离选项,用法如下:

```js
//在组件 .js 文件中新增如下配置
Component({
    options:{
        stylesolation:'isolated'
    }
})
```

```json
//或在组件的 .json 文件中新增如下配置
{
    "stylesolation":'isolated'
}
```





### stylesolation 的可选值

| 可选值       | 默认值 | 描述                                                         |
| ------------ | ------ | ------------------------------------------------------------ |
| isolated     | 是     | 表示`启用样式隔离`,在自定义组件内外,使用class 指定的样式将`不会互相影响` |
| apply-shared | 否     | 表示`页面wxss 样式将影响到自定义组件`,但自定义组件wxss 中指定的样式不会影响页面 |
| shared       | 否     | 表示页面wxss 样式将影响到自定义组件,自定义组件wxss 中指定的样式也会影响页面和其他设置了apply-shared 或shared 的自定义组件 |





# 数据,方法 和属性

### data 数据

在小程序组件中,`用于组件模板渲染`的`私有数据`,需要定义到`data 节点`中,示例如下:

```js
Component({
    //组件的初始数据
    data:{
        count:0
    }
})
```



### methods 方法

在小程序组件中,`事件处理函数`和`自定义方法`需要定义到`methods 节点`中.示例代码如下;

```js
Component({
    methods:{	//组件的方法列表[包含事件处理函数和自定义函数]
        addCount(){	//事件处理函数
            this.setData({count:this.data.count+1})	
            this._showCount()	//通过this 直接调用自定义方法
        },
        _showCount(){	//自定义方法建议以 _ 开头
            wx.showToast({
                title:'count 的值 :'+this.data.count,
                icon:'none'
            })
        }
    }
})
```





### properties 属性

在小程序组件中,prperties 是组件的对外属性,`用来接收外界传递到组件中的数据`,示例代码如下:

```js
Components({
    //属性定义
    properties:{
        max:{	//完整定义属性的方式[当需要指定属性的默认值时,建议使用此方式]
            type:Number,	//属性值的数据类型
            value:10		//属性默认值
        },
        max:Number,	//简化定义属性的方式[不需要指定属性默认值时,可以使用简化的方式]
    },
	methods:{
         addCount(){	//事件处理函数
           console.log(this.properties.max)
        },
	}
})
```

```html
<my-test max="10"></my-test>
```





### data 和properties 的区别

在小程序的组件中,properties 属性和data 数据的用法相同,他们都是`可读可写`的,(而vue 的props 不可写),只不过:

- data 更倾向于`存储组件的私有数据`
- properties 更倾向于`存储外界传递到组件中的数据`

```js
Components({
	methods:{
         showInfo(){	
             console.log(this.data)		//{count:1}
             console.log(this.properties)	//{count:1}
           console.log(this.properties===this.data)  //true 证明本质上都是一样的,都是可读可写的
        },
	}
})
```





### 使用setData 修改properties 的值

由于`data 数据`和`properties 属性`在本质上没有任何的区别,因此properties 属性的值也可以用于页面渲染,或使用setData 为properties 中的属性重新赋值,示例代码如下:

```js
Components({
	properties:{ max:Number },		//定义属性
	methods:{
         addCount(){	
             
         this.setData({
             max:this.properties.max+1  //使用setData 修改属性的值
         })
        },
	}
})
```

```html
<!-- 在组件的 .wxml 文件中使用properties 属性的值-->
<view>max 属性值为:{{max}}</view>
```





# 数据监听器

### 什么是数据监听器

数据监听器用于`监听和响应任何属性和数据字段的变化,从而执行特定的操作`,他的作用类似与vue 中的watch 侦听器,在小程序组件中,数据监听器的基本语法格式如下:

```js
Component({
    observers:{
        //可以同时监听多个字段
        '字段A ,字段B':function(字段A的新值,字段B 的新值){
            // ...
        }
    }
})
```





### 数据监听器的基本用法

组件的UI 结构如下:

```html
<!-- 组件的UI 结构如下-->
<view>{{n1}}+{{n2}}={{sum}}</view>
<button size="mini" bindtap="addN1">n1 自增</button>
<button size="mini" bindtap="addN2">n2 自增</button>
```

组件的 .js 文件代码如下:

```js
Component({
    data:{n1:0,n2:0,sum:0},	//数据节点
    methods:{	//方法列表
        addN1(){this.setData({n1:this.data.n1+1})}
        addN2(){this.setData({n2:this.data.n2+1})}
    },
	observers:{	//数据监听结点
        'n1,n2':function(newn1,newn2){	//监听n1 和 n2 数据的变化
            this.setData({sum:newn1+newn2})	// 通过监听器,自动计算 sum 的值
        }
    }
})
```





### 监听对象属性的变化

数据监听器支持监听对象中`单个`或`多个属性`的变化,示例语法如下:

```js
Component({
    observers:{
        //可以同时监听多个字段
        '对象.属性A,对象.属性B':function(属性A的新值,属性B 的新值){
            //触发此监听器的 3 种情况:
            //[为属性A 赋值] 使用setData 设置this.data.对象.属性A 时触发
            //[为属性B 赋值] 使用setData 设置this.data.对象.属性B 时触发
            //[直接为对象赋值] 使用setData 设置 this.data.对象 时触发
            // ...
        }
    }
})
```





# 数据监听-案例

### 案例效果

```js
Component({
    data:{
        rgb:{	//rgb 的颜色值对象
            r:0,
            g:0,
            b:0
        },
        fullColor:'0,0,0'	//根据rgb 对象的三个属性,动态计算fullColor 的值 
    },
})
```

![](D:\学习\wanye\HTML\微信小程序\笔记\img\29-3.png)







### 渲染UI 结构

```html
<!-- .wxml 结构-->
<view style="background-color:rgb({{fullColor}})" class="colorBox">颜色值: {{fullColor}}</view>
<button size="mini" bindtap="changeR" type="default">R</button>
<button size="mini" bindtap="changeG" type="primary">G</button>
<button size="mini" bindtap="changeB" type="warn">B</button>
```

```css
// .wxss 样式
.colorBox{
    line-height:200rpx;
    font-size:24rpx;
    color:white;
    text-shadow:0rpx 0rpx 2rpx black;
    text-align:center;
}
```





### 定义button 的事件处理函数

```js
methods:{
    changeR:function(){	//修改rgb 对象上r 属性值
        this.setData({
            'rgb.r':this.data.rgb.r+5>255?255:this.data.rgb.r+5
        })
    },
    changeG:function(){	//修改rgb 对象上g 属性值
        this.setData({
            'rgb.g':this.data.rgb.g+5>255?255:this.data.rgb.g+5
        })
    },
    changeB:function(){	//修改rgb 对象上b 属性值
        this.setData({
            'rgb.b':this.data.rgb.b+5>255?255:this.data.rgb.b+5
        })
    },
}
```





### 监听对象中指定属性的变化

```js
observers:{
    // 监听rgb 对象上r,g,b 三个子属性的变化
    'rgb.r,rgb.g,rgb.b':function(r,g,b){
        this.setData({
            //为data 中的fullColor 重新赋值
            fullColor:`${r},${g},${b}`
        })
    }
}
```





### 监听对象中所有属性的变化

如果某个对象中需要被监听的属性太多,为了方便,可以使用`通配符**` 来监听对象中`所有属性的变化`,示例代码如下:

```js
observers:{
    //使用通配符 ** 监听对象上所有属性的变化
    'rgb.**':function(obj){
        this.setData({
            //为data 中的fullColor 重新赋值
            fullColor:`${obj.r},${obj.g},${obj.b}`
        })
    }
}
```

不能使用对象直接监听

```js
'rgb':function(obj){}   //错误
```





### 代码

message.wxml

```html
<!--pages/message/message.wxml-->
<test2></test2>

```



message.json

```json
{
  "usingComponents": {
    "test2":"/components/test2/test2"
  }
}
```



test2.wxml

```html
<!--components/test2/test2.wxml-->
<view style="background-color:rgb({{fullColor}})" class="colorBox">颜色值: {{fullColor}}</view>
<button size="mini" bindtap="changeR" type="default">R</button>
<button size="mini" bindtap="changeG" type="primary">G</button>
<button size="mini" bindtap="changeB" type="warn">B</button>
<view>{{rgb.r}}</view>
```



test2.wxss

```css
/* components/test2/test2.wxss */
.colorBox{
  line-height:200rpx;
  font-size:24rpx;
  color:white;
  text-shadow:0rpx 0rpx 2rpx black;
  text-align:center;
}
```



test2.js

```js
// components/test2/test2.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data:{
    rgb:{	//rgb 的颜色值对象
        r:0,
        g:0,
        b:0
    },
    fullColor:'0,0,0'	//根据rgb 对象的三个属性,动态计算fullColor 的值 
},

  /**
   * 组件的方法列表
   */
  methods: {
    changeR:function(){	//修改rgb 对象上r 属性值
      this.setData({
          'rgb.r':this.data.rgb.r+5>255?255:this.data.rgb.r+5
      })
  },
  changeG:function(){	//修改rgb 对象上g 属性值
      this.setData({
          'rgb.g':this.data.rgb.g+5>255?255:this.data.rgb.g+5
      })
  },
  changeB:function(){	//修改rgb 对象上b 属性值
      this.setData({
          'rgb.b':this.data.rgb.b+5>255?255:this.data.rgb.b+5
      })
  },
  },
  observers:{
    // 监听rgb 对象上r,g,b 三个子属性的变化
    'rgb.r,rgb.g,rgb.b':function(r,g,b){
        this.setData({
            //为data 中的fullColor 重新赋值
            fullColor:`${r},${g},${b}`
        })
    },
}
})

```







# 纯数据字段

### 什么是纯数据字段

概念:`纯数据字段`指的是那些`不用于界面渲染的data 字段`

应用场景:例如有些情况下,某些data 中的字段`既不会展示在界面上,也不会传递给其他组件`,仅仅在当前组件内部使用,带有这种特性的data 字段适合被设置为纯数据字段

好处:纯数据字段`有助于提升页面更新的性能`





### 使用规则

在Component 构造器的options 节点中,指定`pureDatapattern`为一个`正则表达式`,字段名符合这个正则表达式的字段将成为纯数据字段,示例代码如下:

```js
Component({
    options:{
        // 指定所有 _ 开头的数据字段为纯数据字段
        pureDataPattern:/^_/
    },
    data:{
        a:true,	//普通数据字段
        _a:true,	//纯数据字段
    }
})
```





### 使用纯数据字段改造数据监听器案例

```js
Component({
    data:{
    options:{
        // 指定所有 _ 开头的数据字段为纯数据字段
        pureDataPattern:/^_/
    },
        //将rgb 改造为以 _ 开头的纯数据字段
        _rgb:{	//rgb 的颜色值对象
            r:0,
            g:0,
            b:0
        },
        fullColor:'0,0,0'	//根据_rgb 对象的三个属性,动态计算fullColor 的值 
    },
})
```







# 组件的生命周期

### 组件全部的生命周期函数

| 生命周期函数 | 参数         | 描述说明                                   |
| ------------ | ------------ | ------------------------------------------ |
| created      | 无           | 在组件实例刚刚被创建时执行                 |
| attached     | 无           | 在组件实例进入页面节点树时执行             |
| ready        | 无           | 在组件在视图层布局完成后执行               |
| moved        | 无           | 在组件实例被从移动到节点树另一个位置时执行 |
| detached     | 无无         | 在组件实例被从页面节点树移除时执行         |
| error        | Object Error | 每当组件方法抛出错误时执行                 |





### 组件主要的生命周期函数

在小程序组件中,最重要的生命周期函数有3 个,分别是`created,attached,detached`,它们各自的特点如下:

1. 组件实例`刚刚被创建好`的时候,created 生命周期函数就会被触发
   1. 此时还不能调用setData
   2. 通常在这个生命周期函数中,只应该用于给组件的this 添加一些自定义的属性字段
2. 在组件`完全初始化完毕,进入页面节点树后`,attached 生命周期函数会被触发
   1. 此时,this.setData 已被初始化完毕
   2. 这个生命周期很有用,绝大多数初始化的工作可以在这个时机进行(例如发起请求获取初始数据)
3. 在组件`离开页面节点树后`,detached 生命周期函数会被触发
   1. 退出一个页面时,会触发页面内每个自定义组件的detached 生命周期函数
   2. 此时适合做一些清理性质的工作



### lifetimes 节点

在小程序组件中,生命周期函数可以直接定义在Component 构造器中的第一级参数中,可以在`lifetimes`字段内进行声明(`这是推荐的方式,其优先级最高`),示例代码如下:

```js
Component({
    //推荐用法
    lifetimes:{
        attached(){},	//在组件实例进入页面节点树时执行
        detached(){},	// 在组件实例被从页面节点树移除时执行
    },
    //以下是旧式的定义方式
    attached(){},	//在组件实例进入页面节点树时执行
	detached(){},	// 在组件实例被从页面节点树移除时执行
})
```





### 什么是组件所在页面的生命周期

有时,`自定义组件的行为依赖于页面状态的变化`,此时就需要用到`组件所在页面的生命周期`

例如:每当触发页面的show 生命周期函数的时候,我们希望能够重新生成一个随机的RGB 颜色值

在自定义组件中,组件所在页面的生命周期函数有如下3 个 ,分别是:

| 生命周期函数 | 参数        | 描述                         |
| ------------ | ----------- | ---------------------------- |
| show         | 无          | 组件所在的页面被展示时执行   |
| hide         | 无          | 组件所在的页面被隐藏时执行   |
| resize       | Object Size | 组件所在的页面尺寸变化时执行 |





### pageLifetimes 节点

组件所在页面的生命周期函数,需要定义在pageLifetimes 节点中,示例代码如下:

```js
Component({
    //推荐用法
    pageLifetimes:{
        show(){},	
        hide(){},	
    },
})
```





# 插槽

### 什么是插槽

在自定义组件的wxml 结构中,可以提供一个\<slot> 节点(插槽), `用于承载组件使用者提供的wxml 结构`

![](D:\学习\wanye\HTML\微信小程序\笔记\img\29-4.png)





### 单个插槽

在小程序中.默认每个自定义组件中只允许使用一个\<slot> 进行占位,这种个数上的限制叫做单个插槽

```html
<!--组件的封装者-->
<view>
    <!--对于不确定的内容,可以使用<slot> 进行占位,具体内容有组件的使用者决定-->
	<slot></slot>
</view>
    
<!--组件的使用者-->
<component-tag-name>
	<!--这部分内容将被放置在组件<slot> 的位置上-->
    <view>这里是插入到slot 的内容</view>
</component-tag-name>
```





### 启用多个插槽

在小程序的自定义组件中,需要使用多个\<slot> 插槽时,可以在组件的 .js 文件中,通过如下方式进行启用,示例代码如下:

```js
Component({
    options:{
        multipleSlots:true,	//在组件定义时的选项中启用多 slot 支持
    }
})
```

 





### 定义多个插槽

可以在组件的 wxml 中使用多个\<slot> 标签,以不同的 `name` 来区分不同的插槽,示例代码如下:

```html
<view>
    <!--对于不确定的内容,可以使用<slot> 进行占位,具体内容有组件的使用者决定-->
	<slot name="before"></slot>
    <slot name="hhh"></slot>
    <slot name="after"></slot>
</view>
```



### 使用多个插槽

在使用`带多个插槽的自定义组件`时,需要用`slot 属性`来将节点插入到不同的\<slot> 中,示例代码如下:

```html
<component-tag-name>
	<!--这部分内容将被放置在组件<slot> 的位置上-->
    <view slot="before">这里是插入到slot 的内容</view>
    <view  slot="hhh">这里是插入到slot 的内容</view>
    <view  slot="after">这里是插入到slot 的after 上</view>
</component-tag-name>
```





# 父子组件之间的通信

### 父子组件之间通信的3 种方式

- **属性绑定**
  - 用于父组件向子组件的指定属性设置数据,仅能设置JSON 兼容的数据
- **事件绑定**
  - 用于子组件向父组件传递数据,可以传递任意数据
- **获取组件实例**
  - 父组件还可以通过this.selectComponent() 获取子组件实例对象
  - 这样就可以直接访问子组件的任意数据和方法



### 属性绑定

`属性绑定`用于实现`父向子传值`,而且`只能传递普通类型的数据`,无法将方法传递给子组件,父组件的示例代码如下:

```js

```

```html

```

