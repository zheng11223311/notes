- CPU 运行需要大量内存的程序

- GPU 运行需要少量内存的程序,拥有更好的的处理图像计算能力

- ```
  vec2  i=vec2(2); //创建二维长度都为2的向量, i.x=2,i.y=2
  vec3  i=vec3(2); //创建三维长度都为2的向量, i.x=2,i.y=2,i.z=2
  vec4  i=vec4(2); //创建四维长度都为2的向量, i.x=2,i.y=2,i.z=2,i.w=2
  
  vec2  i=vec2(2,3); //创建二维的向量, i.x=2,i.y=3
  vec3  i=vec3(2,3,4); //创建三维的向量, i.x=2,i.y=3,i.z=4
  ```

- ```
  ivec2 i=ivec2(2)  //创建二维长度都为整型数 2的向量, i.x=2,i.y=2,其他维度同理
  bvec2 i=bvec2(2)  //创建二维布尔型的向量, i.x=2,i.y=2
  ```

- `if `等语法与`javascript`一致,`for`循环需要计数变量需要使用`const`,

  ```
  const int a=10;
  for(let i=0;i<a;i++){
  	
  }
  ```

- `GLSL `严格使用分号`;` 变量使用需要声明类型,像 `浮点型*整型` 是不允许的

- 在`JavaScript`中创建函数时需要先编译,函数需要指明返回类型,如果GLSL 中函数有不同的返回类型或不同参数,那么他是一个不同的函数,即重载

  ```
  bool inRect(vec2 pt,vec4 rect){
  	bool result=false;
  	return result;
  }
  ```

  `main`函数首先将被自动调用,且没有返回值

  ```
  void main(){
  	
  }
  ```

- `gl_FragCoord`内置变量,四维向量,x 屏幕的x轴,y 屏幕的y 轴,z,w,

- `varying` 是片元着色器(fragment shader)的uv,等同于顶点着色器(vertex shader)的uv, `varying`类型变量是 vertex shader 与 fragment shader 之间的信使,一般我们在 vertex shader 中修改它然后在fragment shader使用它,但不能在  fragment shader 中修改它. 

