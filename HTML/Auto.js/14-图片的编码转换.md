### 1.图片的编码转换

地址:[图片与颜色 - Images (autojs.org)](https://pro.autojs.org/docs/#/zh-cn/images?id=imagesfrombase64base64)

## [images.save(image, path[, format = "png", quality = 100\])](https://pro.autojs.org/docs/#/zh-cn/images?id=imagessaveimage-path-format-quotpngquot-quality-100)

- `image` {Image} 图片

- `path` {string} 路径

- ```
  format
  ```

   

  {string} 图片格式，可选的值为:

  - `png`
  - `jpeg`/`jpg`
  - `webp`

- `quality` {number} 图片质量，为0~100的整数值

把图片image以PNG格式保存到path中。如果文件不存在会被创建；文件存在会被覆盖。

```
// 把图片压缩为原来的一半质量并保存
var img = images.read("/sdcard/1.png");
images.save(img, "/sdcard/1.jpg", "jpg", 50);
app.viewFile("/sdcard/1.jpg");
```

## [images.fromBase64(base64)](https://pro.autojs.org/docs/#/zh-cn/images?id=imagesfrombase64base64)

- `base64` {string} 图片的Base64数据
- 返回 {Image}

解码Base64数据并返回解码后的图片Image对象。如果base64无法解码则返回`null`。

## [images.toBase64(img[, format = "png", quality = 100\])](https://pro.autojs.org/docs/#/zh-cn/images?id=imagestobase64img-format-quotpngquot-quality-100)

- `image` {image} 图片

- ```
  format
  ```

   

  {string} 图片格式，可选的值为:

  - `png`
  - `jpeg`/`jpg`
  - `webp`

- `quality` {number} 图片质量，为0~100的整数值

- 返回 {string}

把图片编码为base64数据并返回。

## [images.fromBytes(bytes)](https://pro.autojs.org/docs/#/zh-cn/images?id=imagesfrombytesbytes)

- `bytes` {byte[]} 字节数组

解码字节数组bytes并返回解码后的图片Image对象。如果bytes无法解码则返回`null`。

## [images.toBytes(img[, format = "png", quality = 100\])](https://pro.autojs.org/docs/#/zh-cn/images?id=imagestobytesimg-format-quotpngquot-quality-100)

- `image` {image} 图片

- ```
  format
  ```

   

  {string} 图片格式，可选的值为:

  - `png`
  - `jpeg`/`jpg`
  - `webp`

- `quality` {number} 图片质量，为0~100的整数值

- 返回 {byte[]}

把图片编码为字节数组并返回。

**示例:**

```js

// base64 编码成一个txt 文本,传输块
// var img = images.load("https://i2.hdslb.com/bfs/face/38415d3e45f4b85f5ae8675687ae6751f2456b11.jpg@45w_45h_1c_100q.webp");
// toast('获取图片');
// // 编码成base64
// var dtaa=images.toBase64(img)
// // log(dtaa)
// // formBase64() 参数 编码后的图片数据
// var realimg=images.fromBase64(dtaa)
// realimg.saveTo("/storage/emulated/0/3.png")

// realimg.recycle();
// img.recycle();


// var res=http.get("https://i2.hdslb.com/bfs/face/38415d3e45f4b85f5ae8675687ae6751f2456b11.jpg@45w_45h_1c_100q.webp")
// // log(res)
// // log(res.body)
// // log(res.body.bytes())
// // 只能调用一次,一次后就关闭字节流,再次调用res.body.bytes() 报错
// var b=res.body.bytes()
// var img=images.fromBytes(b)
// // images.toBytes(img)  转换成字节流
// img.saveTo("/storage/emulated/0/字节.png")

// img.recycle();

// 好像能跨域请求,因为不是在浏览器上执行,没有同源策略的限制
var res1=http.get("https://www.bilibili.com/video/BV1pQ4y1R7Us?p=32&spm_id_from=pageDriver")
log(res1.body.string())


```

