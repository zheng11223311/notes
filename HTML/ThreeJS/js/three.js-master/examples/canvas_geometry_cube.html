<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js canvas - geometry - cube</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>

	<script src="../build/three.js"></script>

	<script src="js/renderers/Projector.js"></script>
	<script src="js/renderers/CanvasRenderer.js"></script>

	<script src="js/libs/stats.min.js"></script>

	<script>
		var container, stats;

		var camera, scene, renderer;

		var cube, plane;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;

		var mouseX = 0;
		var mouseXOnMouseDown = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		init();
		animate();

		function init() {

			// 创建容器
			container = document.createElement('div');
			document.body.appendChild(container);

			// 创建标题
			var info = document.createElement('div');
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			// info.innerHTML = 'Drag to spin the cube';
			info.innerHTML = '拖动以旋转立方体';
			container.appendChild(info);

			// 创建透视相机
			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.y = 150;
			camera.position.z = 500;

			// 创建场景
			scene = new THREE.Scene();
			// 设置场景的背景颜色
			scene.background = new THREE.Color(0xf0f0f0);


			// Cube

			var geometry = new THREE.BoxGeometry(200, 200, 200);
			console.log(geometry);
			//  geometry.faces.length   //12
			//  一个正方形面 需要2个 三角形面 , 正方体6个面 需要12个三角形  
			for (var i = 0; i < geometry.faces.length; i += 2) {

				var hex = Math.random() * 0xffffff;
				// 两个三角形面 设置成统一颜色
				geometry.faces[i].color.setHex(hex);
				geometry.faces[i + 1].color.setHex(hex);

			}

			// 材质
			var material = new THREE.MeshBasicMaterial({
				vertexColors: THREE.FaceColors,
				// 过度描绘
				// 当使用THREE.CanvasRenderer画布渲染器绘制对象的时候，物体之间可能会有空隙，
				// 这时设置该值为true，多边形会被渲染的稍微大一点，
				overdraw: 0.5
			});
			// 创建立方体
			cube = new THREE.Mesh(geometry, material);
			cube.position.y = 150;
			scene.add(cube);

			// Plane

			var geometry = new THREE.PlaneBufferGeometry(200, 200);
			geometry.rotateX(-Math.PI / 2);

			var material = new THREE.MeshBasicMaterial({
				color: 0xe0e0e0,
				// 过度描绘
				// 当使用THREE.CanvasRenderer画布渲染器绘制对象的时候，物体之间可能会有空隙，
				// 这时设置该值为true，多边形会被渲染的稍微大一点，
				overdraw: 0.5
			});

			plane = new THREE.Mesh(geometry, material);
			scene.add(plane);

			// 创建渲染器
			// WebGLRenderer 和 CanvasRenderer 都是使用HTML5的 <canvas> 直接内嵌在网页中。
			// Canvas渲染器使用相对较慢的Canvas 2D Context API来绘制场景。
			// three.js已经将CanvasRenderer移除了。
			renderer = new THREE.CanvasRenderer();
			//  设置设备像素比。通常用于HiDPI设备防止模糊输出canvas。
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);

			document.addEventListener('mousedown', onDocumentMouseDown, false);
			document.addEventListener('touchstart', onDocumentTouchStart, false);
			document.addEventListener('touchmove', onDocumentTouchMove, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			// 重新设置宽高比例
			camera.aspect = window.innerWidth / window.innerHeight;
			// 更新矩阵
			camera.updateProjectionMatrix();
			// 重新设置渲染大小
			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function onDocumentMouseDown(event) {

			event.preventDefault();

			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mouseup', onDocumentMouseUp, false);
			document.addEventListener('mouseout', onDocumentMouseOut, false);

			mouseXOnMouseDown = event.clientX - windowHalfX;
			targetRotationOnMouseDown = targetRotation;

		}

		function onDocumentMouseMove(event) {

			mouseX = event.clientX - windowHalfX;

			targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;

		}

		function onDocumentMouseUp(event) {

			document.removeEventListener('mousemove', onDocumentMouseMove, false);
			document.removeEventListener('mouseup', onDocumentMouseUp, false);
			document.removeEventListener('mouseout', onDocumentMouseOut, false);

		}

		function onDocumentMouseOut(event) {

			document.removeEventListener('mousemove', onDocumentMouseMove, false);
			document.removeEventListener('mouseup', onDocumentMouseUp, false);
			document.removeEventListener('mouseout', onDocumentMouseOut, false);

		}

		function onDocumentTouchStart(event) {

			if (event.touches.length === 1) {

				event.preventDefault();

				mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

		}

		function onDocumentTouchMove(event) {

			if (event.touches.length === 1) {

				event.preventDefault();

				mouseX = event.touches[0].pageX - windowHalfX;
				targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;

			}

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			stats.begin();
			render();
			stats.end();

		}

		function render() {

			plane.rotation.y = cube.rotation.y += (targetRotation - cube.rotation.y) * 0.05;
			renderer.render(scene, camera);

		}
	</script>

</body>

</html>