<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js canvas - geometry - earth</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #808080;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;

			background-color: #ffffff;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {

			color: #0080ff;
		}
	</style>
</head>

<body>

	<div id="container"></div>
	<!-- <div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - earth demo</div> -->
	<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - 案例-地球</div>

	<script src="../build/three.js"></script>

	<script src="js/renderers/Projector.js"></script>
	<script src="js/renderers/CanvasRenderer.js"></script>

	<script src="js/libs/stats.min.js"></script>

	<script>
		var container, stats;
		var camera, scene, renderer;
		var group;
		var mouseX = 0,
			mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		init();
		animate();

		function init() {

			// 获取容器
			container = document.getElementById('container');

			// 创建相机
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000);
			// 设置相机的z 轴大小
			camera.position.z = 500;

			// 创建场景
			scene = new THREE.Scene();
			// 设置场景的背景颜色
			scene.background = new THREE.Color(0xffffff);

			// 创建组 
			group = new THREE.Group();
			// 将组添加到场景中
			scene.add(group);

			// earth

			// 创建贴图
			var loader = new THREE.TextureLoader();
			// 加载贴图纹理
			loader.load('textures/land_ocean_ice_cloud_2048.jpg', function (texture) {
				//纹理加载成功后的回调
				// 创建球几何体
				var geometry = new THREE.SphereGeometry(200, 20, 20);

				// map 使用贴图
				// overdraw 过度描绘
				// 当使用THREE.CanvasRenderer画布渲染器绘制对象的时候，物体之间可能会有空隙，
				// 这时设置该值为true，多边形会被渲染的稍微大一点，
				var material = new THREE.MeshBasicMaterial({
					map: texture,
					overdraw: 0.5
				});
				// 合成骨架和材质
				var mesh = new THREE.Mesh(geometry, material);
				// 将球添加到组中
				group.add(mesh);

			});

			// shadow

			// 创建画布
			var canvas = document.createElement('canvas');
			canvas.width = 128;
			canvas.height = 128;

			var context = canvas.getContext('2d');
			// 使用圆形渐变色
			var gradient = context.createRadialGradient(
				canvas.width / 2,
				canvas.height / 2,
				0,
				canvas.width / 2,
				canvas.height / 2,
				canvas.width / 2
			);
			// 10% 位置添加颜色
			gradient.addColorStop(0.1, 'rgba(210,210,210,1)');
			gradient.addColorStop(1, 'rgba(255,255,255,1)');

			// 使用填充色为圆形渐变色
			context.fillStyle = gradient;
			// 画矩形
			context.fillRect(0, 0, canvas.width, canvas.height);
			// 创建画布贴图
			var texture = new THREE.CanvasTexture(canvas);

			var geometry = new THREE.PlaneBufferGeometry(300, 300, 3, 3);
			var material = new THREE.MeshBasicMaterial({
				map: texture,		//使用画布贴图
				overdraw: 0.5
			});
			// 创建平面
			var mesh = new THREE.Mesh(geometry, material);
			mesh.position.y = -250;
			mesh.rotation.x = -Math.PI / 2;
			// 将平面添加到组中
			// 平面和球组合成一体,相当于形成一个组合体
			group.add(mesh);

			// 创建渲染器
			// WebGLRenderer 和 CanvasRenderer 都是使用HTML5的 <canvas> 直接内嵌在网页中。
			// Canvas渲染器使用相对较慢的Canvas 2D Context API来绘制场景。
			// three.js已经将CanvasRenderer移除了。
			renderer = new THREE.CanvasRenderer();
			//  设置设备像素比。通常用于HiDPI设备防止模糊输出canvas。
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);

			document.addEventListener('mousemove', onDocumentMouseMove, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onDocumentMouseMove(event) {

			mouseX = (event.clientX - windowHalfX);
			mouseY = (event.clientY - windowHalfY);

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}

		function render() {

			camera.position.x += (mouseX - camera.position.x) * 0.05;
			camera.position.y += (-mouseY - camera.position.y) * 0.05;
			camera.lookAt(scene.position);

			group.rotation.y -= 0.005;

			renderer.render(scene, camera);

		}
	</script>

</body>

</html>