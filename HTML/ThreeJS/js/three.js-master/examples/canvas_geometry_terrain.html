<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js canvas - geometry - terrain</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #71544e;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;

			background-color: #bfd1e5;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {

			color: #b07861;
		}
	</style>
</head>

<body>

	<div id="container"><br /><br /><br /><br /><br />Generating...</div>
	<!-- <div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - terrain demo. <a href="canvas_geometry_terrain.html">generate another</a></div> -->
	<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - 案例-地势.</div>

	<script src="../build/three.js"></script>

	<script src="js/renderers/Projector.js"></script>
	<script src="js/renderers/CanvasRenderer.js"></script>

	<script src="js/libs/stats.min.js"></script>

	<script src="js/ImprovedNoise.js"></script>

	<script>
		var container, stats;

		var camera, scene, renderer;

		var mesh;

		var mouseX = 0,
			mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		init();
		animate();

		function init() {

			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.z = 500;

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xbfd1e5);

			var data = generateHeight(1024, 1024);
			var texture = new THREE.CanvasTexture(generateTexture(data, 1024, 1024));
			var material = new THREE.MeshBasicMaterial({
				map: texture,
				overdraw: 0.5,
			});

			var quality = 16,
				step = 1024 / quality;

			var geometry = new THREE.PlaneGeometry(2000, 2000, quality - 1, quality - 1);
			geometry.rotateX(-Math.PI / 2);

			for (var i = 0, l = geometry.vertices.length; i < l; i++) {

				var x = i % quality,
					y = Math.floor(i / quality);
				geometry.vertices[i].y = data[(x * step) + (y * step) * 1024] * 2 - 128;

			}

			mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);

			renderer = new THREE.CanvasRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			container.innerHTML = "";

			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);

			document.addEventListener('mousemove', onDocumentMouseMove, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}
		// console.log(new Uint8Array( ));
		// console.log(ImprovedNoise);
		// 地形高度数据生成
		function generateHeight(width, height) {

			// Uint8Array 数组类型表示一个 8 位无符号整型数组，创建时内容被初始化为 0。
			// 创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。
			// new Uint8Array(length); // 创建初始化为 0 的，包含 length 个元素的无符号整型数组
			var data = new Uint8Array(width * height),
				// ImprovedNoise 实现地形高度数据的随机生成。
				perlin = new ImprovedNoise(),
				//  width，heigh 分别表示行列两个方向顶点数据量。总的顶点数据量width * height
				size = width * height,
				// 控制地面显示效果  可以尝试0.01  0.1  1等不值
				// 0.1凹凸不平的地面效果  1山脉地形效果
				quality = 2,
				// z值不同每次执行随机出来的地形效果不同
				z = Math.random() * 100;

			for (var j = 0; j < 4; j++) {

				quality *= 4;

				for (var i = 0; i < size; i++) {
					// x的值0 1 2 3 4 5 6...
					var x = i % width,
						// ~表示按位取反 两个~就是按位取反后再取反
						// ~~相当于Math.floor(),效率高一点
						// y重复若干个值
						y = ~~(i / width);
					// 通过噪声生成数据
					data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * 0.5) * quality + 10;

				}

			}
			console.log(data); //[ ......]
			return data;

		}

		function generateTexture(data, width, height) {

			var canvas, context, image, imageData,
				level, diff, vector3, sun, shade;

			vector3 = new THREE.Vector3(0, 0, 0);

			sun = new THREE.Vector3(1, 1, 1);
			sun.normalize();

			canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;

			context = canvas.getContext('2d');
			context.fillStyle = '#000';
			context.fillRect(0, 0, width, height);

			// 获取画布图画像素点
			image = context.getImageData(0, 0, width, height);
			// console.log(image);
			imageData = image.data;

			// console.log( vector3.dot);
			// ƒ ( v ) {
			// 	return this.x * v.x + this.y * v.y + this.z * v.z;
			// 	}
			// 将 地形高度数据 填充到 画布image 中
			for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {

				vector3.x = data[j - 1] - data[j + 1];
				vector3.y = 2;
				vector3.z = data[j - width] - data[j + width];
				vector3.normalize();

				shade = vector3.dot(sun);

				imageData[i] = (96 + shade * 128) * (data[j] * 0.007);
				imageData[i + 1] = (32 + shade * 96) * (data[j] * 0.007);
				imageData[i + 2] = (shade * 96) * (data[j] * 0.007);

			}
			// 将image 像素写入到canvas
			context.putImageData(image, 0, 0);

			return canvas;

		}

		function onDocumentMouseMove(event) {

			mouseX = event.clientX - windowHalfX;
			mouseY = event.clientY - windowHalfY;

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}

		function render() {

			camera.position.x += (mouseX - camera.position.x) * 0.05;
			camera.position.y += (-mouseY - camera.position.y) * 0.05 + 15;
			camera.lookAt(scene.position);

			renderer.render(scene, camera);

		}
	</script>

</body>

</html>