<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
        promise 是异步编程的一种解决方案

        什么时候我们会来处理异步事件呢?
        一种很常见的场景是网络请求
    
</body>
<script>
    // 将setTimeout 看成一次网络请求

    // 使用setTimeout
    // setTimeout(()=>{
    //     console.log('hello');
    // },1000)

    // Promise 传的参数本省就是一个函数
    // resolve 解决        reject 拒绝  两个也是函数
    // 链式编程

    new Promise((resolve,reject)=>{
        // 1.第一次网络请求的代码
         setTimeout(()=>{
            //  调用resolve 时会自动调用then 函数
        resolve()
    },1000)
    }).then(()=>{
         //第一次拿到结果的代码
        console.log('hello');
        console.log('hello');
        console.log('hello');
        console.log('hello');
        console.log('hello');
      
        return new Promise((resolve,reject)=>{
            // 1.第二次网络请求的代码
              setTimeout(()=>{
                  resolve()
        
    },1000)
        }).then(()=>{
            //第二次拿到结果的代码
            console.log('hello1111111111');
        console.log('hello1111111111');
        console.log('hello1111111111');
        console.log('hello1111111111');

     return new Promise((resolve,reject)=>{
         // 2.第三次网络请求的代码
         setTimeout(()=>{
             resolve()
         })
     }).then(()=>{
           //第三次拿到结果的代码
        console.log('hello2222');
        console.log('hello2222');
        console.log('hello2222');
        console.log('hello2222');
     })
        })
    })


    // 什么情况下会使用到Promise
    // 一般情况下是有异步操作进行封装

    // executor  exe 可执行文件  自动执行回调函数
    // new ->构造函数(1.保存了一些状态信息  2.执行传入的文件)
    // 在执行函数回调时,会传入两个参数,resolve,reject,本身又是函数

    new Promise((resolve,reject)=>{
        setTimeout(()=>{
            // 成功的时候调用resolve
            resolve('优雅永不过时')

            //失败的时候调用reject  来到catch
            reject('err message')
        },1000)
    }).then((data)=>{
        console.log(data);
        console.log(data);
        console.log(data);
    }).catch(err=>{
        console.log(err);
    })
</script>
</html>