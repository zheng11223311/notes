 安装路由
 npm i vue-router -S
 创建文件(vue create 项目)的时候安装路由
 name:'App'   路由的name 的属性值       //name: 'Home',
 在main.js 引入router

 router
 import { createRouter, createWebHistory } from 'vue-router'
import Home from '../views/Home.vue'

const routes = [
  {
    path: '/',
    name: 'Home',
    //component: Home     //使用组件前必须导入相应的组件
    components:{
      default:Home,  //,有3个<router-view/>时(默认值,没有指定路径) 页面左边
      About,      //中间
      user        //右边
    }
  },
  {
    path: '/about',
    name: 'About',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
  }
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
})

export default router

路由懒加载(点击时才显示组件)
component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')

路由的每个path 都打包到dist 文件夹下的js 文件夹里面,不同的path 有不同的js 

延迟加载动态导入和路由模式解析
路由是有多个URL 组成的,使用不同的URL 可以相应的导航到不同的位置
Vue-router 在切换页面时是没有重新进行请求的,使用起来好像页面时有状态的一样
借助了浏览器的history API 来实现的,这样可以使得页面跳转而不刷新,页面的状态就被维持在浏览器中
vue-router 中默认使用的是hash 模式,也就是会出现如URL:loaclhost:8080/#/ url 中带有#

有三种模式
Hash: 使用URL 的hash 值来作为路由,用来指导浏览器动作的,对服务端完全无用,支持所有浏览器
History: 以HTML5 History API 和服务器配置
Abstract: 支持所有javascript 运行模式.如果发现没有浏览器的API,路由会自动强制进入这个模式

    <router-link @click="$router.go(1)">返回</router-link>    //$router 为整个路由
    <router-link @click="$router.push('/')">返回</router-link>

<router-view name='App'><router-view/>

嵌套路由
{
    path: '/',
    name: 'Home',
    component: Home,
    children:[{
       path:'order',    //order 不要带/  默认直接拼接在父级的目录下  //以'/' 开头的嵌套路径会被当做根路径,所以子路由上不用加'/' ,载生成路由是,主路由上的path 会被自动添加到子路由之前,所以子路由上的path 不用再重新声明主路由上的path 了
       component:aaaa   //aaaa 为子路由

    },
    ]
<router-link to="/Home/order">子路由</router-link>

传递参数的方式(优点,多个路由(比如1000个)时可以用参数来切换)
传递参数主要有两种类型:params 和query
params 的类型:
配置路由格式:/user/:id(动态路由)
{
    path: '/',
    name: 'Home',
    component: Home,
    children:[{
       path:'order:id',    
       component:aaaa   

    },
    ]
传递的方式:在path 后面对应的值:to='"user/"+uid'
<router-link to='"/Home/order/"+id'>子路由</router-link>
传递后形成的路径:/user/9,/user/zs
接收参数:$router.params.id
query 的类型:
配置路由格式:/user,正常配置
传递的方式:对象中使用query 的key 作为传递方式:to={path:'/',query:{id:1,name:'abc'}}
传递后形成的路径:/user?id=9,/user?id=zs
接收参数:$router.query.name


重定向redirect  url 不会带有path 的属性值,重定向时name 不能是一样的
重定向:
重定向也在router 配置中完成,要重定向/a 到/b
const routers=[{path:'/home',redirect;'/'}]
const routers=[{path:'/home',redirect:{name:'homepage'}}]
path:'/search/:searchText',
  redirect:to=>{
    return{path:'/search',query:{q:to.params.searchText}}
  }
----------------------------------------------
{
    path: '/Home/:id',
    name: 'Home',
    redirect:to=>{
      return {path:'article',query:{name:'zs',age:to.params.id}}
    }

    }

  },


  别名:
  别名/as/home 表示用户访问时/home,URL 保持不变/home,但将被匹配,就像用户正在访问一样
  const routers=[{path:'/',component:Homepage,alias:'/home'}]   
  alias:['people','list']  //多个别名,url 输入别名也可以到达相应的路由
  alias:['home/:id','']   //有id 的起别名时要带上id


  导航守卫介绍(在router 下index.js 里设置)
  导航守卫主要用来通过跳转或取消的方式守卫导航
  前置守卫
  //to:Route:即将要进入的目标 路由对象,form:Route:当前导航正要离开的路由
  router.beforeEach(to,from)=>{
    //...return false     //拦截
  }
  后置钩子:
  router.afterEach(to,from)=>{
    
  }

  有多种机会植入路由导航过程中:全局的,单个路由独享的,或者组件级的
  全局导航守卫
  路由独享的守卫
  组件内的守卫


// 前置守卫guard(在跳转之前调用)
router.beforeEach((to,from,next)=>{
  // 从from 跳转到to 
  //更换meta 里面定义的title 标签,但是这样组件里面嵌套了子组件的话就显示undefined,这样只能获取到子组件的title
  // document.title=to.meta.title
  // 这样就不会
  document.title=to.matched[0].meta.title
  meta 元数据,添加在路由的index,js 文件下
  // console.log(to);
  // 里面必须调用next(),不然就不能继续运行下去
  next()
  //next('/home')
  // console.log('前置钩子++++');
  
})

// 后置钩子hook
router.afterEach((to,from,failure)=>{
  // 不需要主动调用next() 
  // console.log('后置钩子----');
})

keep-alive 和vue-router 结合使用




