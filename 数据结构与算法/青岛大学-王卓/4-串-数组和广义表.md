# 串,数组和广义表

- 串
- 数组
- 广义表

### 串(string) --- 零个或多个任意`字符组成的有限序列`

```
s="a1a2...an" (n>=0)
串名s
串值 "a1a2...an"
串长 n
空串 n=0 ,用∅ 表示
```

### 串的定义---几个术语

- 子串:串中任意个连续字符组成的子序列称为该串的子串
- 例如,"abcde" 的子串有:
  - "" , "a" , "ab" ,"abc" ,"abcd" 和"abcde" 等
  - `真子串` 是指不包含自身的所有子串
- 主串:包含子串的串相应的称为`主串`
- 字符位置:字符`在序列中的序号`为该字符在串中的位置
- 子串位置:`子串第一个字符`在主串中的位置
- 空格串:由一个或多个空格组成的串,`与空串不同`
  - 空格串包含空格(" "),空串不包含任何字符与空格("")
- 串相等:当且仅当两个串的长度相等并且各个对应位置上的字符都相同时,这两个串才是`相等`的
- 如:
  - "abcd" != "abc"
  - "abcd"!="abcde"
- 所有空串都是相等的



# 案例引入

串的应用非常广泛,计算机上的非数值处理的对象大部分是字符串数据,例如:文字编辑,符号处理,各种信息处理系统等等



### 案例:病毒感染检测

- 研究者将人的DNA 和病毒DNA 均表示成由一些字母组成的字符串序列
- 然后检测某种病毒DNA 序列是否在患者的DNA 序列中出现过,如果出现过,则此人感染了该病毒,否者没有感染
- 例如:假设病毒的DNA 序列为baa ,患者1 的DNA 序列为aaabbba,则感染,患者2 的DNA 序列为babbba ,则未感染
- (注意,人的DNA 序列是线性的,而病毒的DNA 序列是环状的)
- 即bba 是一个循环结构,bba 同aab ,aba 都是一样的
- ![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\4-1.png)



# 串的类型定义,存储结构及其运算

```c
ADT String{
    数据对象:D={ai |ai 属于CharacterSet,i=1,2,3, ... ,n , n>=0}
    数据关系:R1={<ai-1 , ai>|ai-1,ai属于D,i=1,2, ... ,n}
    基本操作:
    	StrAssign(&T,chars)	//串赋值
        StrCompare(S,T)		//串比较
        StrLength(S)		//求串长
        Concat(&T,S1,S2)	//串连接
		SubString(&Sub,S,pos,len)	//求子串
		StrCopy(&T,S)		//串拷贝
        StrEmpty(S)			//串判空
		ClearString(&S)		//清空串
        Index(S,T,pos)		//子串的位置
		Replace(&S,T,V)		//串替换
        StrInsert(&S,pos,T)	//子串插入
		StrDelete(&S,pos,T)	//子串删除
		DestroyString(&S)	//串销毁
}ADT String;
```

串中元素逻辑关系与线性表的相同,串可以采用与线性表相同的存储结构

- `串的顺序存储结构`

  ```c
  #define MAXLEN 255
  typedef struct{
      char ch[MAXLEN+1];	//存储串的一维数组
      int length;		//串的当前长度
  }SString;
  ```

- `串的链式存储结构`

  - 优点:
  - 操作方便
  - 缺点:
  - 存储密度较低
  - 存储密度=串值所占的存储/实际分配的存储

- 可以将多个字符放在一个结点中,以克服其缺点

- `串的链式存储结构--块链结构`

  ```C
  #define CHUNKSIZE 80 //块的大小可由用户定义
  typedef struct Chunk{
  	char ch[CHUNKSIZE];
  	struct Chunk *next;
  }Chunk;
  
  typedef struct{
      Chunk *head,*tail;	//串的头指针和尾指针
      int curlen;			//串的当前长度
  }LString;				//字符串的块链结构
  ```

  



### 串的模式匹配算法

- 算法目的:

确定`主串`中所含`子串(模式串)`第一次出现的位置(定位)

- 算法应用:

搜索引擎,拼音检查,语言翻译,数据压缩

- 算法种类:

1. `BF 算法(Brute-Force)`,又称古典的,经典的,朴素的,穷举的,即暴力破解法
2. KMP 算法(特点:速度快)



# 串的模式匹配算法----BF 算法

Brute-Force 简称为`BF算法`,亦称简单匹配算法,采用穷举法的思路

```
S: a b a c b c d 		//主串:正文串
T: a b c				//子串:模式  		

abc 与s 的aba 比较,不符合在向后与bac 比较,一直往下,直到匹配或失败
```

**算法的思路是从S 的每一个字符开始依次与T 的每个字符进行匹配**

匹配失败:回退(回溯)到开始比较的部分,在从其下一位开始依次比较



### BF 算法设计思想

**Index(S,T,pos)**

- 将主串的第pos 个字符和模式串的第一个字符比较
  - 若相等,继续逐个比较后续字符
  - 若不等,从主串的下一个字符起,重新与模式串的第一个字符比较
- 直到主串的一个连续子串字符序列与模式串相等,返回值为S 中与T 匹配的子序列第一个字符的序号,即匹配成功
- 否则,匹配失败,返回值0



### BF 算法描述

模式串是从1 开始存储,0 位置什么都没有存,其实也可以从0 开始存储

```c
int Index_BF(SString S,SString T){
    int i=1,j=1;	//0 号闲置
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[j]){++i;++j;} //主串和子串依次匹配下一个字符
        else {i=i-j+2;j=1;}	//主串与子串指针回溯重新开始下一次匹配
    }
    if(j>=T.length) return i-T.length;	//返回匹配的第一个字符的下标
    else return 0;	//模式匹配不成功
}
```



### BF 算法时间复杂度

最好的情况,只匹配一次模式串的所有字符的次数,即O(T.length)

```
例: S='00000000001' , T='0001' ,pos=1
```

若n 为主串的长度,m 为子串的长度,最坏情况是

- 主串前面n-m 个位置都部分匹配到子串的最后一位,即这n-m 为各比较了m 次
- 最后m 位也比较了1次

```
总次数为:(n-m)*m+m=(n-m+1)*m
若m<<n ,则算法复杂度O(n*m) 
```

由此看出这个算法的执行效率比较差



# KMP(Knuth Morris Pratt) 算法

KMP 算法是D.E.`K`nuth , J.H.`M`orris 和V.R.`P`ratt 共同提出的,简称`KMP 算法`

该算法较BF 有较大改进,从而使算法效率有了某种程度的提高



### KMP 算法设计思想

利用已经`部分匹配`的结果而加快模式串的滑动速度?

且主串S 的指针`i 不必回溯`!,可提速到`O(n+m)`!

```c
S 指针为i T 指针为j
S=' a b a b c a b c a c b a b'
T=' a b c a c'		// 匹配了最前面的 a b

S=' a b a b c a b c a c b a b'
	T=' a b c a c'	// 匹配正确的(a b)不用在匹配,开始匹配下一个
	
S=' a b a b c a b c a c b a b'
		T=' a b c a c'		//倒数第二个a 在上一步也是匹配成功的,也与第一个a 相同(称为公共前后缀),所以第一个a 也不需要再次匹配,直接从第二个b 开始匹配,即前缀a 移动到后缀a 的位置
    
如果有多个公共前后缀,取最长的前后缀,如果有多个相同的公共前后缀,取最前的和最后的
公共前后缀不包含模式子串已经匹配到的整个长度,即 如果模式子串 ababccc 中abab 被匹配到,公共前缀与后缀不能是abab ,只能是ab ,即至少比匹配的少一个字符
即公共前后缀的长度要小于匹配字符的长度
结论:如果最大公共前后缀长度为n , 就得到n+1 为与主串当前位作比较,即等于最大公共前后缀+1
```

为此,定义`next[j]`函数,表明当模式中第j 个字符与主串中相应字符"失配"时,在模式中需要重新和主串中该字符进行比较的字符的位置

```c
		| max{K| 1<K<j , 且" p1, ... ,pk-1 " = " pj-k+1 , ... , pj-1 "}	(当有公共前后缀时)
next[j]=| 0 	当j=1 时(即当开始比较第一个时)
		| 1		其他情况(即没有公共前后缀)
		
" p1, ... ,pk-1 "  			 => 	模式串中,从头开始的k-1 个元素
" pj-k+1 , ... , pj-1 "		 => 	模式串中,j 前面的k-1 个元素
            
max{K| 1<K<j , 且" p1, ... ,pk-1 " = " pj-k+1 , ... , pj-1 "}	理解为模式串中,从头开始的k-1 个元素 等于 j 前面的k-1 个元素,则next[j]=k ,k 的范围 1<K<j  , 即T 串中的a 与 尾部的 a 相同的意思
            
j为 匹配字符的长度
k 为最大公共前后缀+1,即模式串回溯到第几位
```



**附加:**动画易懂演示

 [「天勤公开课」KMP算法易懂版_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jb411V78H?spm_id_from=333.337.search-card.all.click&vd_source=070ffddf09233e186f58521cebea78fb) 

<video src="D:\学习\wanye\数据结构与算法\青岛大学-王卓\video\KMP 算法-简易版.mp4"></video>

### KMP 算法

```c
int Index KMP(SString S,SString T,int pos){
    i=pos,j=1;
    while(i<S.length &&j<T.length){
        if(j==0||S.ch[i]==T.ch[j]){i++;j++;}
        else
            j=next[j];	//i 不变,j 后退
    }
    if(j>T.length) return i-T.length;	//匹配成功
    else return 0;	// 返回不匹配标志
}
```

```c
void get_index(SString T,int &next[]){
	i=1;next[1]=0;j=0;
	while(i<T.length){
        if(j==0||T.ch[i]==T.ch[j]){
            ++i;++j;
            next[i]=j;
        }
        else
            j=next[j];
    }
}
```



**优点:有的文件比较大,我们可以一边读一边找,比较方便**



### next 函数的改进

```
S: a a a b a a a a b
P: a a a a  <= j=4,next[j]=3,即回溯到3位置与主串当前位置比较
1.   a a a  <= j=3
2.	   a a	<= j=2
3.		 a	<= j=1,next[j]=0,即没有值可以与主串比较,主串下移一位,模式串指针从新开始(1开始),即i++;j=1
```

```
查看next
j		1 2 3 4 5
模式 	   a a a a b
next[j] 0 1 2 3 4
```

由此可知,此时j 一直在回溯,直到回溯到头,主串才下移一位



**修正next 后的值为nextval**

```
模式串		   a b a a b c a c
next 值		0 1 1 2 2 3 1 2
nextval 值	0 1 0 2 1 3 0 2
```

1. 第一位的nextval 的值必定为0 , 第二位如果与第一位相同则为0 ,如果不同则为1
2. 第三位的next 值为1,那么将第三位和第一位(即第三位next 指向)进行比较,均为a ,相同, 则第三位的nextval 值为第一位的next 值,为0
3. 第四位的next 值为2,那么将第四位和第二位进行比较,不同,则第四位的nextval 值为其next 值,为2
4. 第五位的next 值为2,那么将第五位和第二位进行比较,相同,第二位的next 值为1,则继续将第二位与第一位进行比较,不同,则将第五位的nextval 值为第二位的next 值,为1
   1. 理解: 第5 位的b 与第2 位的b 是等效的, 第5 位的b 匹配不成功就会跳转到next 指向的 第2 位的b
   2.  第2 位的b 如果匹配不成功就会跳到next 指向的第1 位,如果第2 位的b 与 next 指向的第1 位 相同,则 第2 位的b 无意义,也是同第1位 一样匹配不成功
   3. 所以 第5 位的b 跳转到 第2 位的b 也无意义,所以不用next 回溯,直接为0
   4. 如果 第2 位的b 有意义,那么 第5 位的b 的next 回溯也有意义,回溯到 第2 位的b  ,但是 第2 位的b  也是b 字符,匹配失败, 第2 位的b 再次回溯到next 指向的第1位, 第2 位的b 与 next 指向的第1 位 不相同,即有意义,所以 第5 位的b 最终回溯到 第2 位的b 的next指向
5. 第六位的next 值为3,那么将第六位和第三位进行比较,不同,则将第六位的nextval 值为其next 值,为3
6. 第七位的next 值为1,那么将第七位和第一位进行比较,相同,则第七位的nextval 值,为0
7. 第八位的next 值为2,那么将第八位和第二位进行比较,不同,则第八位的nextval 值为其next 值,为2



# 数组

`数组`:按照一定格式排列起来的,具有`相同类型`的数据元素的集合

### `一维数组:`

若线性表中地数据元素为非结构的简单元素,则称为一维数组

`一维数组的逻辑结构:`   `线性结构`,定长的线性表

`声明格式:`

```c
数据类型 变量名称[长度];
例: 
int num[5]={0,1,2,3,4};
```



### `二维数组:`

若一维数组中的数据元素又是一维数组结构,则称为二维数组

`二维数组的逻辑结构:`

- 非线性结构
  - 每一个数据元素即在一和行表中,又在一个列表中
- 线性结构(定长的线性表)
  - 该线性表的每个数据元素也是一个定长的线性表

`声明格式:`

```c
 数据类型 变量名称[行数][列数];
 例:
 int num[5][8];
```

在C 语言中,一个二维数组类型也可以定义为一维数组类型(其分量类型为一维数组类型),即:

```c
typedef elemtype array2[m][n];
```

`等价于:`

```c
typedef elemtype array1[n];
typedef array1 array2[m];
```



### `三维数组:`

若二维数组中的元素又是一个一维数组,则称为三维数组

`n 维数组:`若n-1 维数组中的元素又是一个一维数组结构,则称作n 维数组



### 结论

线性表结构是数组结构的一个特例,

而数组结构又是线性结构的扩展



### 数组的特点

`结构固定`   -------   定义后,维数和维界不在改变



### 数组的基本操作

除了结构的初始化和销毁之外,

只有取元素和修改元素值的操作





# 数组的抽象数据类型定义

### n 维数组的抽象数据类型

```c
ADT Array{
    数据对象:ji=0 , ... , bi-1 , i=1,2, ... ,n		// n 为数组的维数,bi 为数组第i 维的长度 , ji 为数组第i 维的下标 
        	D={aj1j2 ... jn |aj1j2 ... jn 属于 ElemSet }   //aj1j2 ... jn 为a 下标j1 *j2 * ... jn
    数据关系:
    	R1={<aj1...ji...jn , aj1...ji+1...jn > | 0<= jk <= bk-1 ,1<= K <= n , 且K!=i, 0<= ji <= bk-2, aj1...ji...jn,aj1...ji+1...jn 属于D, i=2, ... , n }
}
```



例:`二维数组`的抽象数据类型的数据对象和数据关系的定义

```
n=2(维数为2,二维数组)
b1 :第一维长度(行数) 	b2:第2维长度(列数)
aj1j2: 第1 维下标为j1 ,第2 维下标为j2

二维数组:
a00 a01 ... a0(b2 - 1)
a10 a11 ... a1(b2 - 1)
a(b1 - 1)0 a(b1 - 1)1 ... a(b1 - 1)(b2 - 1) 
```



### 基本操作

```c
1. InitArray(&A,n,bound1, ... ,boundn)  //构造数组A
2. DestroyArray(&A)						//销毁数组A
3. Value(A,&e,index1, ... , indexn)		//取数组元素值
4. Assign(A,&e,index1, ... ,indexn)		//给数组元素赋值
```



# 数组的顺序存储

数组特点:`结构固定`   -------   定义后,维数和维界不在改变

数组基本操作: 初始化,销毁,取元素,修改元素值,一般不做插入和删除操作

正因以上原因:所以一般都是采用`顺序存储结构`来表示数组

**注意:数组可以是多维的,但存储数据元素的内存单元地址是一维的,因此,在存储数据结构之前,需要解决将多维关系映射到一维关系的问题**



### 一维数组

例:有数组定义:

```c
int a[5];
```

每个元素占用4 个字节,假设a[0] 存储在2000 单元,a[3] 地址是多少?

> LOC(0)= a =2000   L=4
>
> LOC(3)=2000+ L*3 =2012

> LOC(i)=LOC(0)=a,	i=0
>
> LOC(i)=LOC(i-1)+L =a+i*L , i>0



### 二维数组

两种顺序存储方式

- 以行序为主序(低下标优先)BASIC ,COBOL 和PASCAL (java 和c 也是这样的)
- 以列序为主序(高下标优先)FORTRAN



存储单元是`一维结构`,而数组是个多维结构,则用一组连续存储单元存放数组的数据元素就有个`次序约定`问题

- 以行序为主序
  - C , PASCAL , JAVA , Basic
- 以列序为主序
  - FORTRAN



### 二维数组的行序优先表示

有二维数组

```
A[m][n](A[0...m-1][0...n-1])
```

`以行序为主序:`

设数组开始存储位置LOC(0,0),存储每个元素需要L 个存储单元

数组元素a[i]\[j] 的存储位置是:`LOC(i,j)=LOC(0,0)+(n*i+j)*L` 

`n*i+j` 为在a[i]\[j] 前面所有元素个数



### 三维数组

按 页/行/列 存放,页优先的顺序存储

```
a[m1][m2][m3] 各维元素个数为 m1 ,m2 ,m3

下标为i1, i2, i3 的数组元素的存储位置:
LOC(i1,i2,i3)=a+i1*m2*m3 +i2*m2 +i3

i1*m2*m3	前i1 页总元素个数
i2*m2		第i1 页前i2 行总元素个数
i3 			第i2 行前i3 列元素个数
```



### n 维数组

- 各维元素个数为 m1,m2, m3, ... ,mn
- 下标为 i1, i2, i3, ... ,in 的数组元素的存储位置:

```
LOC(i1,i2, ... ,in)=a+ i1*m2*m3* ... *mn + i2*m3*m4* ... *mn +i3*m4*m5* ...*mn + ... + in-1 * mn  +in 
```

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\4-2.png)



例:设有一个二维数组A[m]\[n] `按行优先` 顺序存储,假设A[0]\[0] 存放位置在644(10) ,A[2]\[2] 存放位置在676(10) ,每个元素占一个空间,问A[3]\[3](10) 存放在什么位置? (脚注(10) 表示用10进制表示)

> 2n+2=676-644=32 
>
> =>  n=15
>
> 3*15+3 + 644=48+644 =692



# 特殊矩阵的压缩存储

`矩阵:`

一个由m*n 个元素排成的m 行 n 列 的表

`矩阵的常规存储:`

将矩阵描述为一个二维数组

`矩阵的常规存储的特点:`

可以对其元素进行随机存取;

矩阵运算非常简单;

存储密度为1

`不适宜常规存储的矩阵:`

值相同的元素很多且呈某种规律分布;零元素多

`矩阵的压缩存储:`

为多个相同的非零元素只分配一个存储空间;

对零元素不分配空间



### 什么是压缩存储?

若多个数据元素的`值都相同`,则只分配一个元素值的存储空间,且零元素不占用存储空间

### 什么样的矩阵能够压缩?

一些特殊矩阵,如:对称矩阵,对角矩阵,三角矩阵,稀疏矩阵等

### 什么叫稀疏矩阵?

矩阵中非零元素的个数较少(一般少于5%)



# 对称矩阵

`特点`

在n*n 的矩阵a 中,满足如下性质:

aij=aji(1<=i,j<=n)

即沿着对角线(左上到右下)对称的矩阵

`存储方法`

只存储下(或者上)三角(包括主对角线)的数据元素,共占用n(n+1)/2 个元素空间, 即对称元素的个数+对称线上的个数

```
n(n+1)/2 =1+2+3+ ... +n   //三角形头部到底部的元素
```



### 对称矩阵的存储结构:

对称矩阵上下三角中的元素数均为:

```
n(n+1)/2
```

可以`以行序为主序`将元素存放在一个一维数组sa[n(n+1)/2] 中



# 三角矩阵

`特点:`对角线以下(或以上)的数据元素(不包含对角线)全部为常数C

`存储方法:`重复元素C 共享一个元素存储空间,共占用n(n+1)/2+1 个元素空间:sa[1...n(n+1)/2+1]

```
上三角矩阵
k=(i-1)*(2n-i+2)/2 +j-i+1  i<=j
k=n(n+1)/2+1				i>j
```

```
下三角矩阵
k=i*(i-1)/2+j	i>=j
k=n(n+1)/2+1	i<j
```



# 对角矩阵(带状矩阵)

`特点:`在n*n 的方阵中,所有非零元素都集中在以对角线为中心的带状区域中,区域外的值全部为0,则称为`对角矩阵`,常见的有三对角矩阵,五对角矩阵,器对角矩阵等

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\4-3.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\4-4.png)



# 稀疏矩阵存储

`稀疏矩阵:`设在m*n 的矩阵中有t 个非零元素

令  `a=t/(m*n)`

当a<=0.05	时称为`稀疏矩阵`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\4-5.png)



**注意:为更可靠描述,通常再加一个"总体" 信息:即总行数,总列数,非零元素总个数(即在三元组的第一个组,用来描述此矩阵)**



三元组顺序表又称`有序的双下标法`

三元组顺序表的`优点:`非零元在表中按行序有序存储,因此`便于进行依行顺序处理的矩阵运算`

三元组顺序表的`缺点:`不能随机存取,若按行号存取某一行中的非零元素,则需从头开始进行查找



### 稀疏矩阵的链式存储结构--十字链表

- `优点:`

  它能够`灵活的插入`因运算而产生的新的元素的非零元素,`删除`因运算而产生的新的零元素,实现矩阵的各种运算

- 在十字链表中,矩阵的每一个非零元素用一个结点表示,该结点除了(row,col,value) 以外,还要有两个域:

  - right: 用于链接同一行中的下一个非零元素;
  - down: 用于链接同一列中的下一个非零元素;

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\4-6.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\4-7.png)





# 广义表

`广义表(又称列表List)`是n>=0 个元素a0 ,a1 , ... ,an-1 的有限序列,其中每一个a1 可以是`原子`,也可以是一个`广义表`



例:中国举办的国际足球邀请赛,参赛队名单可表示如下:

(阿根廷,巴西,德国,法国, ( ) ,西班牙,意大利,英国,( 国家队,山东鲁能,广州恒大) )



在这个表中,叙利亚队应排在法国队后面,但未能参加,称为空表,国家队,山东鲁能,广州恒大均作为东道主的参赛队参加,构成一个小的线性表,成为原线性表的一个数据元素,这种`扩宽了的线性表就是广义表`



- `广义表`通常记作:

  ```
  LS=(a1 ,a2 , ... ,an)
  ```

  其中:LS 为`表名`, n 为`表的长度` ,每一个ai 为`表的元素`

- 习惯上,一般用`大写字母`表示`广义表`,`小写字母`表示`原子`

- `表头:`若LS 非空(n>=1),则其`第一个`元素a1 就是表头

  记作head(LS)=a1 ,

  **注:表头可以是原子,也可以是子表**

- `表尾:`除表头之外的`其他元素`组成的`表`

  记作 tail(LS)=(a2, ... , an)

  **注:表尾不是最后一个元素,而是一个子表**



例:

```
1. A=()		 空表,长度为0
2. B=(())	 长度为1,表头,表尾均为()
3. C=(a,(b,c))	长度为2,由原子a 和子表(b,c) 构成,表头为a ,表尾为((b,c))
4. D=(x,y,z)	长度为3,每一项都是原子,表头为x, 表尾为(y,z)
5. E=(C,D)		长度为2.每一项都是子表,表头为C ,表尾为(D)
6. F=(a,F)		长度为2,第一项为原子,第二项为它本身, 表头为a, 表尾为(F), F=(a,(a,(a, ...)))
```



### 广义表的性质

1. 广义表中的数据元素有相对`次序`;`一个直接前驱和一个直接后继`

2. 广义表的`长度`定义为最外层所包含元素的个数:

   如:C=(a,(b,c)) 是长度为2 的广义表

3. 广义表的`深度`定义为该广义表`展开后所含括号的重数`

   A=(b,c) 的深度为1,B=(A,d) 的深度为2,C=(f,B,h) 的深度为3

   **注意:"原子"的深度为0; "空表"的深度为1**

4. 广义表可以为其他广义表`共享`:如:广义表B 就共享表A,在B 中不必列出A 的值,而是通过名称来引用,B=(A)

5. 广义表可以是一个`递归的`表,如: F=(a,F)=(a,(a,(a, ...)))

   **注意:递归表的深度是无穷值,长度是有限值**

6. 广义表是`多层次`结构,广义表的元素可以是单元素,也可以是子表,而子表的元素还可以是子表, ...

   可以用图形象的表示

   例: D=(E,F)	 其中:E=(a,(b,c))  F=(d,(e))



### 广义表与线性表的区别?

`广义表`可以看成是`线性表的推广,线性表是广义表的特例`

广义表的结构相当灵活,在某种前提下,它可以兼容线性表,数组,树和有向图等各种常用的数据结构

当`二维数组的每行(或每列)作为子表处理时,二维数组即为一个广义表`

另外,树和有向图也可以用广义表来表示

由于广义表不仅集中了线性表,数组,树和有向图等常见数据结构的特点,而且可以有效利用存储空间,因此在计算机的许多领域都有成功使用广义表的实例



### 广义表的基本运算

- 求表头GetHead(L): 非空广义表的第一个元素,可以是一个原子,也可以是子表
- 求表尾GetTail(L): 非空广义表除去表头元素以外其他元素构成的表,表尾一定是一个表

例: D=(E,F)=((a,(b,c) ) , F)

GetHead(D)=E			GetTail(D)=(F)

GetHead(E)=a			GetTail(E)=((b,c))

GetHead( ((b,c))  )=(b,c)			GetTail( ((b,c))  )=( )

GetHead((c))=c			GetTail((c))=( )



### 案例(同前面的):病毒感染检测

**案例分析**

- 因为患者的DNA 和病毒DNA 均是由一些字母组成的字符串序列,要检测某种病毒DNA 序列是否在患者的DNA 序列中出现过,实际上就是字符串的模式匹配问题
- 可以利用BF 算法,也可以利用更高效的KMP 算法
- 但与一般的模式匹配问题不同的是,此案例中病毒的DNA 序列是环状的
- 这样需要对传统的BF 算法或KMP 算法进行改进



**案例实现**

- 对于每一个待检测的任务,假设病毒DNA 序列的长度是m ,因为病毒DNA 序列是环状的,为了线性取到每个可行的长度为 m  的模式串,可将存储病毒DNA 序列的字符串长度扩大为2m ,将病毒DNA 序列连续存储两次
- 然后循环m 次,依次取得每个长度为m 的环状字符串,将此字符串作为模式串,将人的DNA 序列作为主串,调用BF 算法进行模式匹配
- 只要匹配成功,即可终止循环,表明该人感染了对应的病毒;否则 ,循环 m 此结束循环,可通过BF 算法的返回值判断该人是否感染了对应的病毒



