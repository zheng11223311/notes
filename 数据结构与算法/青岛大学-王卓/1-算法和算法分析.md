# 算法的定义

- 对特定问题求解方法和步骤的一种描述,他是指令的有限序列,其中每个指令表示一个或多个操作



# 算法的描述

- 自然语言:英语,中文
- 流程图:传统流程图,NS 流程图
- 伪代码:类语言:类C 语言
- 程序代码:C 语言程序,JAVA 语言程序....



# 算法与程序

- `算法`是解决问题的一种方法或一个过程,考虑如何将输入转换成输出,一个问题可以有多种算法
- `程序`是用某种程序设计语言对算法的具体实现
- `程序=数据结构+算法`
  - 数据结构通过算法实现操作
  - 算法根据数据结构设计程序



# 算法特性:一个算法必须具备一下五个重要特性

- `有穷性:`一个算法必须总是在执行有穷步之后结束,且每一步都在有穷事件内完成
- `确定性:`算法中的每一条指令必须有确切的含义,没有二义性,在任何条件下,只有唯一的一条执行路径,即对于相同的输入只能得到相同的输出
- `可行性:`算法是可执行的,算法描述的操作可以通过已经实现的基本操作执行有限次来实现
- `输入:`一个算法有零个或多个输入
- `输出:`一个算法有一个或多个输出



# 算法设计的要求

- 正确性(Currectness)
  - 算法满足问题要求,能正确解决问题,算法转化为程序后要注意:
  - 程序中不含语法错误
  - 程序对于几组输入数据能够得出满足要求的结果
  - 程序对于精心选择的,典型,苛刻且带有刁难性的几组输入数据能够得出满足要求的结果(通常作为一个算法正确性的合格标准)
  - 程序对于一切合法的输入数据都能得出满足要求的结果
- 可读性(Readability)
  - 算法主要是为了人的阅读和交流,其次才是计算机执行,因此算法因该易于人的理解
  - 另一方面,晦涩难懂的算法易于隐藏较多的错误而难以调试
- 健壮性(Robustness)
  - 指当输入非法数据时,算法恰当的做出反应或进行相应处理,而不是产生莫名其妙的输出结果
  - 处理出错的方法,不应是中断程序的执行,而是应返回一个表示错误或错误性质的值,以便在更高的抽象层次上进行处理
- 高效性(Efficiency)
  - 要求花费尽量少的时间和尽量低的存储需求



# 算法和算法分析

一个好的算法首先要具备正确性,然后是健壮性,可读性,在几个方面都满足的情况下,主要考虑`算法的效率`,通过算法的效率高低来评判不同算法的优劣程度

算法效率由以下两个方面来考虑:

- `时间效率:`指的是算法所消耗的时间
- `空间效率:`指的是算法执行过程中所耗费的存储空间

**时间效率和空间效率有时候是矛盾的,有时候需要用空间换时间,有时候需要使用时间换空间,这根据实际的场景来使用**



# 算法时间效率的度量

- 算法时间效率可以依据该算法编制的程序在计算机上执行所消耗的时间来度量
- 两种度量方法:
  - 事后统计
    - 将算法实现,测算其时间和空间开销
    - 缺点:编写程序实现算法将花费较多的时间和精力;所得实验结果依赖于计算机的软硬件等环境因素,掩盖算法本省的优劣
  - 事前分析
    - 对算法所消耗资源的一种估算方法





一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作(如赋值,比较,移动等)所需的时间与算法中的进行的简单操作次数乘积

`算法运行时间=一个简单操作所需的时间x简单操作次数`

也即算法中每条语句的执行时间之和

**每条语句执行一次所需的时间,一般是随机器而异的,取决于机器的指令性能,速度以及编译的代码质量,是由机器本身软硬件环境决定的,它与算法无关**

**所以,我们可以假设执行每条语句所需要的时间均为单位时间,此时对算法的运行时间的讨论就可转化为该算法中所有语句的执行次数**

**这就可以独立于不同机器的软硬件环境来分析算法的时间性能了**

## 例如:两个nxn 矩阵相乘的算法可描述为:

```js
for(i=1;i<=n;i++){						//n+1 次
    for(j=1;j<=n;j++){					// n(n+1) 次
		c[i][j]=0;						//n*n 次
        for(k=1;k<=n;k++){				//n*n*(n+1) 次
			c[i][j]=c[i][j]+a[i][k]*b[k][j];	//n*n*n 次
        }
    }
}
```

我们把算法所消耗的时间定义为该算法中每条语句的频度之和,则上述算法的时间消耗为T(n) 为:

```js
T(n)=2n^3 +3n^2 +2n +1			//即上述所有次数相加
```



# 算法时间复杂度的渐进表示法

为了便于比较不同算法的时间效率,我们仅比较它们的数量级:

## 例如:两个不同的算法,消耗时间分别是:

```
T1(n)=10n^2		与   		T2(n)=5n^3
```

若有某个辅助函数f(n) ,使得当n 趋近于无穷大时,T(n)/f(n) 的极限值为不等于0 的常数,则称为f(n) 是T(n)的同数量级函数,记作T(n)=O(fn(n)),称O(f(n)) 为算法的渐进时间复杂度(O 是数量级的符号),简称`时间复杂度`

对于求解矩阵相乘问题,算法耗费时间:

```
T(n)=2n^3+3n^2+2n+1
```

n->正无穷时,T(n)/n^3 ->2,这表示n 充分大时,T(n)与n^3 是同阶或同数量级,引入大"O" 记号,则T(n) 可记作:

```
T(n)=O(n^3)		//这就是求解矩阵相乘问题的渐进时间复杂度
```

一般情况下,不必计算所有操作的执行次数,而只考虑算法中基本操作执行的次数,他是问题规模n 的某个函数,用T(n) 表示



# 算法时间复杂度定义

算法中基本语句重复执行的次数是问题规模n 的某个函数f(n),算法的时间量度记作:

```
T(n)=O(f(n))	//n 越大,算法执行的时间越长
```

它表示随着n 的增大,算法执行的时间的增长率和f(n)的增长率相同,称渐进时间复杂度



# 分析算法时间复杂度的基本方法

## 定理1.1

```
若f(n)=a^m *n^m a^(m-1) *n^(m-1) +... +an+a 是m 次多项式,则T(n)=O(n^m)
```

忽略所有第低次幂项和最高次幂系数,体现出增长率的含义

1. 找出语句频度最大的那条语句作为基本语句
2. 计算基本语句的频度得到问题规模n 的某个函数f(n)
3. 取其数量级用符号"O" 表示

```js
//1.
x=0;y=0;

//2.
for(int k=0;k<n;k++){
    x++;
}

//3. 时间复杂度最大,f(n)=n(n+1),T(n)=O(n^2)
for(int i=0;i<n;i++){			//n+1
    for(int y=0;y<n;y++){		//n*(n+1)
        j++;
    }
}

```



# 算法时间复杂度分析例题

```js
i=1;
while(i<=n){
    i=i*2;
}

//若循环执行1次: i=1*2=2
//若循环执行2次: i=2*2=2^2
//若循环执行3次: i=2^2 *2=2^3
//若循环执行x次: i=2^x
//设语句while 执行次数为x 次,由循环条件i<=n,
//2^x<=n
//x<=log2(n)

//2^ ( f(n) )<=n
//fn<=log2(n),取最大值f(n)=log2(n)
```



# 算法时间复杂度计算

请注意:有的情况下,算法中基本操作重复执行的次数还随问题的`输入数据集`不同而不同

[例] 顺序查找,在数组a[i] 中查找值等于e 的元素,返回其所在位置

```js
for(i=0;i<n;i++){
    if(a[i]==e) return i+1;		//找到,则返回是第几个元素
    return 0;
}

```

- 最好情况:1次
- 最坏情况:n
- 平均时间复杂度为:O(n)



# 算法时间复杂度

- `最坏时间复杂度:`指在最坏情况下,算法的时间复杂度
- `平均事件复杂度:`指在所有可能输入实例在等概率出现的情况下,算法的期望运行时间
- `最好时间复杂度:`指在最好情况下,算法的时间复杂度

**一般总是考虑在最坏情况下的时间复杂度,以保证算法的运行时间不会比它更长**

对于复杂的算法,可以将他分成几个容易估算的部分,然后利用大O 加加法法则和乘法法则,计算算法的时间复杂度:

- 加法法则

  ```
  T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O( max(f(n),g(n)) )
  ```

- 乘法法则

  ```
  T(n)=T1(n) x T2(n)=O(f(n)) x O(g(n))=O(f(n) x g(n))
  ```

  

# 算法时间效率的比较

当n 取得很大时,指数时间算法和多项式时间算法在所需时间上非常悬殊

**时间复杂度T(n) 按数量级递增顺序为:复杂度低------->复杂度高**

| 常数阶 | 对数阶     | 线性阶 | 线性对数阶  | 平方阶 | 立方阶 | ...  | K 次方阶 | 指数阶 |
| ------ | ---------- | ------ | ----------- | ------ | ------ | ---- | -------- | ------ |
| O(1)   | O(log2(n)) | O(n)   | O(nlog2(n)) | O(n^2) | O(n^3) |      | O(n^K)   | O(2^n) |





# 渐进空间复杂度

空间复杂度:算法所需存储空间的度量,记作:

```js
S(n)=O(f(n))		//其中n 为问题的规模(或大小)
```

算法要占据的空间

- 算法本身要占据的空间,输出/输入,指令,常数,变量等
- 算法要使用的`辅助空间`



# 算法空间复杂度分析例题

[例] 将一维数组a 中的n 个数逆序存放到原数组中

```js
//算法1
for(i=0;i<n/2;i++){
    t=a[i];				//S(n)=O(1),只为t 开辟空间
    a[i]=a[n-i-1];
    a[n-i-1]=t;
}
```

```js
//算法2
for(i=0;i<n;i++){
    b[i]=a[n-i-1];		//S(n)=O(n),根据a 数组的长度n,开辟等长度的空间n
}
for(i=0;i<n;i++){
	a[i]=b[i]		
}
```





# 设计好算法的过程

抽象数据类型=数据的逻辑结构+抽象运算(运算的功能描述)