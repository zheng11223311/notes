# 栈和队列

- 栈和队列的定义和特点
- 案例引入
- 栈的表示和操作的实现
- 栈的递归
- 队列的表示和操作的实现
- 案例分析与实现



# 栈和队列的定义和特点

- 栈和队列是两种常用的,重要的数据结构
- 栈和队列是限定插入和删除只能在表的`端点`进行的线性表
  - 栈和队列是线性表的子集(是插入和删除位置`受限制的`线性表)



### 栈

特点:后进先出,类似装弹夹



### 栈的应用

由于栈的操作具有后进先出的固有特性,使得栈称为程序设计中的有用工具,另外,如果问题求解的过程具有`后进先出`的天然特性的话,则求解的算法中也必然需要利用`栈`

- 数据转换
- 括号匹配的检验
- 行编辑程序
- 迷宫求解
- 表达式求值
- 八皇后问题
- 函数调用
- 递归调用的实现



### 队列

特点:先进先出,类似排队



### 队列的常见应用

由于队列的操作具有`先进先出`的特性,使得队列称为程序设计中解决类似排队问题的有用工具

- 脱机打印输出:按申请的先后顺序依次输出
- 多用户系统中,多个用户排成队,分时的循环使用CPU 和主存
- 按用户的优先级排成多个队,每个优先级一个队列
- 实时控制系统中,信号按接收的先后顺序依次处理
- 网络电文传输,按到达的时间先后顺序依次进行



# 栈的定义和特点

- `栈`(stack) 是一个比较特殊的线性表,是限定仅在一端(通常是尾表) 进行插入和删除操作的线性表
- 又称为`后进先出`(Last In First Out) 的线性表,简称`LIFO` 结构



### 栈的相关概念

`栈`是仅在表尾进行插入,删除操作的线性表

表尾(即an 端)称为`栈顶`Top; 表头(即a1 端) 称为`栈顶`Base

例如:

```
栈 s=(a1,a2,a3, ... ,an-1 , an)
a1 称为栈底元素 , an  称为栈顶元素
```

插入元素到`栈顶`(即表尾)的操作,称为`入栈`

从`栈顶`(即表尾)删除最后一个元素的操作,称为`出栈`

```
入=压入=PUSH(x)  出=弹出=POP(y)
```



1. 定义
   1. 限定只能在表的一端进行插入和删除运算的线性表(只能在栈顶操作)
2. 逻辑结构
   1. 与同线性表相同,仍为一对一关系
3. 存储结构
   1. 用顺序栈或链栈存储均可,但以顺序栈更常见
4. 运算规则
   1. 只能在栈顶运算,且访问结点时依照后进先出(LIFO) 的原则
5. 实现方式
   1. 关键是编写入栈和出栈函数,具体实现依顺序栈或链栈的不同而不同



### 栈与一般线性表有什么区别

栈与一般线性表的区别:`仅在于运算规则不同`

|          | 一般线性表  | 栈             |
| -------- | ----------- | -------------- |
| 逻辑结构 | 一对一      | 一对一         |
| 存储结构 | 顺序表,链表 | 顺序表,链表    |
| 运算规则 | 随机存取    | 后进先出(LIFO) |



# 队列的定义和特点

- `队列`(queue)是一种`先进先出`(First In First Out --- FIFO) 的线性表,在表一端插入(表尾),在另一端(表头)删除

  ```
  Q=(a1,a2,a3, ... ,an)
  
  a1,a2,a3, ... ,an <----入队列
  a1 队头 , an 队尾
  ```

  

1. 定义
   1. 只能在表的一端进行插入运算,在表的另一端进行删除运算的线性表(`头删尾插`)
2. 逻辑结构
   1. 与同线性表相同,仍为`一对一`的关系
3. 存储结构
   1. `顺序队`或`链队`,以循环顺序队列更常见
4. 运算规则
   1. 只能在队首和队尾运算,且访问结点时依照`先进先出(FIFO)`的原则
5. 实现方式
   1. 关键时掌握`入队`和`出队`操作,具体实现依顺序队或链队的不同而不同



# 案例引入

- 十进制整数N 向其他进制数d(二,八,十六)的转换是计算机实现计算的基本问题

- `转换法则:除以d 倒取余`

- 该转换法则对应于一个简单算法原理:

  ```
  n = (n div d) * d + n mod d
  ```

  其中:div 为整除运算,mod 为求余运算

**例:**把十进制数159 转换成八进制数

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\3-1.png)



**例:**括号匹配的检验

- 假设表达式中允许包括两种括号:圆括号和方括号
- 其嵌套的顺序随意,即:
  - ( [] () ) 或 [ ( [] [ ] ) ]  为正确格式
  - [ ( ] ) 为错误格式
  - ( [ ( ) ) 或( () ]) 为错误格式

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\3-2.png)

- 可以利用一个栈结构保存每个出现的左括号,当遇到右括号时,从栈中弹出左括号,检验匹配情况
- 在检验过程中,若遇到以下几种情况之一,就可以得处括号不匹配的结论
  - 当遇到某一个右括号时,栈已空,说明到目前为止,`右括号多于左括号`
  - 从栈中弹出的左括号与当前检验的右括号类型不同,说明出现了`括号交叉`情况
  - 算术表达式输入完毕,但栈中还有没有匹配的左括号,说明`左括号多于右括号`



**例:表达式求值**

- 表达式求值是程序设计语言编译中一个最基本的问题,他的实现也需要运用栈
- 这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法----`算符优先算法`
- 表达式的组成
  - 操作数(operand):常数,变量
  - 运算符(operator):算术运算符,关系运算符和逻辑运算符
  - 界限符(delimiter):左右括弧和表达式结束符
- 任何一个`算术表达式`都由`操作数`(常数,变量),`算术运算符`(+,-,*,/) 和`界限符`(括号,表达式结束符`#`,虚设的表达式起始符`#`)组成,后两者统称为算符
  - 例: # 3 * ( 7 - 2 ) #
- 为了实现表达式求值,需要设置两个栈:
  - `一个是算符栈OPTR,用于寄存运算符`
  - `另一个称为操作数栈OPND,用于寄存运算数和运算结果`
- 求值的处理过程是自左向右扫描表达式的每一个字符
  - 当扫描到的是运算数,则将其压入栈OPND
  - 当扫描到的是运算符时:
    - `若这个运算符比OPTR 栈顶运算符的优先级高,则入栈OPTR,继续向后处理`
    - `若这个运算符比OPTR 栈顶运算符优先级低,则从OPND 栈中弹出两个运算数,从栈顶OPTR 中弹出栈顶运算符进行运算,并将运算结果压入OPND`
  - 继续处理当前字符,知道遇到结束符为止



**例:舞伴问题**

- 假设在舞会上,男士和女士各自排成一队,舞会开始时,依次从男队和女队的队头各出一人配成舞伴,如果两队初始人数不相同,则较长的那一队中未配对者等待下一轮舞曲,现要求写一算法模拟上述舞伴配对问题
- 显然先入队的男士或女士先出队配成舞伴,因此该问题具有典型的先进先出特性,可以用队列作为算法的数据结构
- 首先构造两个队列
- 依次将队头元素出队配成舞伴
- 某队为空,则另外一队等待者则是下一舞曲第一个可获得舞伴的人



# 栈的表示和操作的实现

### 栈的抽象数据类型的类型定义

```
ADT Stack{
	数据对象:
		D={ai | ai 属于ElemSet,i=1,2, ... ,n ,n>=0}
	数据关系:
		R1={ <ai-1 , ai > | ai-1,ai 属于D, i=2, ... ,n}
		约定an 端为栈顶,a1 端为栈底
	基本操作:初始化,进栈,出栈,取栈顶元素等
} ADT Stack
```



- 由于栈本身就是线性表,于是栈也有顺序存储和链式存储两种方式
  - 栈的顺序存储---顺序栈
  - 栈的链式存储---链栈



### 顺序栈的表示和实现

存储方式:同一般线性表的顺序存储结构完全相同

利用地址连续的存储单元依次存放自栈底到栈顶的数据元素,栈底一般在低地址端

- 附设`top`指针,指示栈顶元素在顺序栈中的位置
- 另设`base`指针,指示栈底元素在顺序栈中的位置



**但是,为了方便操作,通常top 指示真正的栈顶元素之上的下标地址**

**另外,用stacksize 表示栈可使用的最大容量**



**空栈:base==top, 是栈空标志**

**栈满:top-base=stacksize**



**栈满时的处理方法:**

- `报错`,返回操作系统
- `分配更大的空间`,作为栈的存储空间,将原栈的内容移入新栈



### 使用数组作为顺序栈存储方式的特点:

简单,方便,但易产生溢出(数组大小固定)

- `上溢(overflow):`栈已满,又要压入元素
- `下溢(underflow):`栈已空,还要弹出元素

> 注:上溢是一种错误,使得问题的处理无法进行,而下溢一般认为是一种结束条件,即问题处理结束



### 顺序栈的入栈

1. 判断是否栈满,若满则出错(上溢)
2. 元素e 压入栈顶
3. 栈顶指针加1



### 顺序栈的出栈

1. 判断是否栈空,若空则出错(下溢)
2. 获取栈顶元素e
3. 栈顶指针减1



### 链栈的表示

- 链栈是`运算受限`的单链表,只能在`链表头部`进行操作

**注意:栈链中指针方向,由a1(栈底)->an(栈顶)**

- 链表的头指针就是栈顶
- 不需要头结点
- 基本不存在栈满的情况
- 空栈相当于头指针指向空
- 插入和删除仅在栈顶处执行



# 栈的递归

### 递归的定义

- 若一个对象部分的`包含它自己`,或用他`自己给自己定义`,则称为这个对象是递归的

- 若一个过程`直接地或间接地调用自己`,则称为这个过程是递归的过程

  - 例如:递归求n 的阶乘

- `以下三种情况下常常用到递归的方法`

  - 递归定义的数学函数
  - 具有递归特性的数据结构
  - 可递归求解的问题

- `递归定义的数学函数`

  - 阶乘函数

    ```
    Fact(n)=1 				若n=0
    Fact(n)=n * Fact(n-1)	若n>0
    ```

  - 2 阶Fibonaci 数列:

    ```
    Fib(n)=1					若n=2 或n=1	
    Fib(n)=Fib(n-1)+Fib(n-2)    其他
    ```

- `具有递归特性的数据结构`

  - 二叉树
  - 广义表

- `可递归求解的问题`

  - 迷宫问题
  - Hanoi 塔问题

- `递归问题---用分治法求解`

  - `分治法`:对于一个较为复杂的问题,能够分解成几个相对简单的且解法相同或类似的子问题来求解

  - `必备的三个条件`

  - 能将一个问题转变成一个新的问题,而新的问题与原问题的解法相同或类同,不同的仅是处理的对象,且这些处理是变化有规律的

  - 可以通过上述转化而使问题简化

  - 必须有一个明确的递归出口,或称为递归的边界

  - `分治法求解递归问题算法的一般形式:`

    ```c
    void p(参数表){
        if(递归结束条件) 可直接求解的步骤;  ---基本项
         else p(较小的参数);  -----归纳项
    }
    ```

    例如:

    ```c
    long Fact(long n){
        if(n==0) return 1;  //基本项
        else return n*Fact(n-1);	//归纳项
    }
    ```

- `函数调用过程`

  - 调用前,系统完成:
  - 将`实参,返回地址`等传递给被调用函数
  - 为被调用函数的`局部变量`分配存储区
  - 将控制转移到被调用函数的`入口`
  - 调用后,系统完成:
  - 保存被调用函数的计算`结果`
  - 释放被调用函数的`数据区`
  - 依照被调用函数保存的`返回地址`将控制转移到调用函数

- `递归的优缺点:`

  - 优点:
    - 结构清晰,程序易读
  - 缺点:
    - 每次调用要生成工作记录,保存状态信息,入栈
    - 返回时要出栈,恢复状态信息,时间开销大

- `单向递归->循环结构`

  虽然有一处以上的递归调用语句,但各次递归调用的语句的参数`只和主调函数`有关,相互之间参数无关,并且这些`递归调用语句处于算法的最后`

- `借助栈改写递归`

  - 递归程序在执行时需要系统提供栈来实现
  - 仿照递归算法执行过程中递归工作栈的状态变化可写出相应的非递归程序
  - 改写后的非递归算法与原来的递归算法相比,结构不够清晰,可读性较差,有的还需要经过一系列优化

- `借助栈改写递归的方法(了解)`

  - 设置一个工作栈存放递归工作记录(包含实参,返回地址即局部变量等)
  - 进入非递归调用入口(即被调用程序开始处)将调用程序传来的实在参数和返回地址入栈(递归程序不可以作为主程序,因而可认为初始是被某个调用程序调用)
  - 进入递归调用入口:当不满足递归结束条件时,逐层递归,将实参,返回地址即局部变量入栈,这一过程可用循环语句来实现----模拟递归分解的过程
  - 递归结束条件满足,将到达递归出口的给定常数作为当前的函数值
  - 返回处理结果:在栈不空的情况下,反复退出栈顶记录,根据记录中的返回地址进行题意规定的操作,即逐层计算当前函数值,直至栈空为止----模拟递归求值过程



# 队列的相关术语

- `列(Queue)`是仅在`表尾`进行插入操作,在`表头`进行删除操作的线性表
- 表尾即an 端,称为`队尾`; 表头即a1 端,称为`队头`
- 它是一种先进先出(FIFO) 的线性表
  - 例如:队列Q=(a1,a2,a3,  ...... , an-1, an)
- 插入元素称为`入队`;删除元素称为`出队`
- 队列的存储结构为`链队`或`顺序队`(常用循环顺序队)



### 队列的相关概念

1. 定义
   1. 只能在表的一端进行插入运算，在表的另一端进行删除运算的线性表(`头删尾插`)
2. 逻辑结构
   1. 与同线性表相同,仍为`一对一`关系
3. 存储结构
   1. `顺序对`或`链队`,以循环顺序队列更常见
4. 运算规则
   1. 只能在队首和队尾运算,且访问结点时依照`先进先出(FIFO)`的原则
5. 实现方式
   1. 关键是掌握`入队`和`出队`操作,具体实现依顺序队或链队的不同而不同



- 队列的物理存储可以用顺序存储结构,也可用链式存储结构,相应的,队列的存储方式也分为两种,即`顺序队列`和`链式队列`

- 队列的顺序表示----用一维数组base[MAXQSIZE]

  ```c
  #define MAXQSIZE 100 //最大队列长度
  Typedef struct {
      QElemType *base;	//初始化的动态分配存储空间
      int front;			//头指针
      int rear;			//尾指针
  }SqQueue;
  ```

  



### 思考:存在什么问题?

> 设数组大小为MAXQSIZE
>
> rear=MAXQSIZE 时,发生溢出
>
> 若front=0
>
> rear=MAXQSIZE 时,再入队---`真溢出`
>
> front !=0
>
> rear=MAXQSIZE 时,再入队--`假溢出`



### 解决假溢出的方法---引入循环队列

1. 将队中元素依次向队头方向移动
   1. 缺点:浪费时间,每移动依次,队中元素都要移动
2. 将队空间设想成一个循环的表,即分配给队列的m 个存储单元可以循环使用, 当rear 为`maxqsize`时,若向量的开始端空着,又可以从头使用空着的空间,当front 为`maxqsize`时,也是一样
3. 此时,会出现队空和队满都是指向同一个位置:front==rear
4. 解决方案:
   1. 另外设一个标志以区别队空,队满
   2. 另设一个变量,记录元素个数
   3. `少用一个元素空间`



### 循环队列解决队满时判断方法----少用一个元素空间:

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\3-3.png)



### 链队---队列的链式表示和实现

- 若用户无法估计所用队列的长度,则宜采用链队列