# 知识回顾

- 数据结构
  - 数据的逻辑结构
    - 线性结构(一对一)
      - 线性表
      - 栈(特殊线性表)
      - 队列(特殊线性表)
      - 字符串,数组,广义表
    - 非线性结构(一对多,多对多)
      - 树形结构(一对多)
      - 图形结构(多对多)
  - 数据的存储结构
    - 顺序存储
    - 链式存储
  - 数据的运算:检索,排序,插入,删除,修改等



# 线性表的定义和特点

线性表时具有相同的特性的数据元素的一个有限序列

```js
(a1,a2, ... ,a(i-1),ai, ... ,an)	
//() 内所有元素 为数据元素
// a1 为线性起点,起始结点
// an 为线性终点,中断结点
// a(i-1) 为ai 的 直接前趋
// a(i+1) 为ai 的 直接后继
//下标,是元素的序号,表示元素在表中的位置
// n 为元素的总个数,即表长,n=0 时称为空表
```

### 线性表(Linear List):

由n(n>=0) 个数据元素(结点)a1,a2, .... ,an 组成的有限序列

- 其中数据元素的个数n 定义为表的长度
- 当n=0 时称为空表
- 将非空的线性表(n>0) 记作:(a1,a2, ... , an)
- 这里的数据元素ai(1<=i<=n) 只是一个抽象的符号,其具体含义在不同的情况下可以不同



# 线性表的例子

[例] 分析26 个英文字母组成的英文表

```
(A,B,C,D, .... ,Z)
```

数据元素都是字母

元素间的关系是线性



[例] 分析学生情况登记表

| 学号      | 姓名   | 性别 | 年龄 | 班级        |
| --------- | ------ | ---- | ---- | ----------- |
| 023131231 | 于春梅 | 女   | 18   | 04计算机2班 |
| 121232133 | 何式鹏 | 男   | 19   | 04计算机2班 |
| 123123121 | 王爽   | 男   | 20   | 04计算机2班 |
| 233123121 | 王亚武 | 男   | 18   | 04计算机2班 |

数据元素都是记录

元素间的关系是线性

**例子:**

- 某单位历年拥有计算机的数量(6,17,28,50,92,188)
- 12 星座(白羊座,金牛座,双子座,巨蟹座,狮子座,处女座,天秤座,天蝎座.射手座,摩羯座,水瓶座,双鱼座)

**同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系 **



# 线性表的逻辑特征

从以上例子可以看出线性表的逻辑特征是：

- 在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2
- 有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋a(n-1)
- 其余的内部结点ai(2<=i<=n-1) 都有且仅有一个直接前趋a(i-1) 和一个直接后继a(i+1)

**线性表是一种典型的线性结构**



# 案例引入

**[案例1] 一元多项式的运算:实现两个多项式加,减,乘运算**

```
Pn(x)=P0+P1 * x+ P2 * x^2 +P3 * x^2+ ... +Pn * x^n
线性表P=(P0,P1,P2,...,Pn)
(每一项的指数i 隐藏在其系数Pi 的序号中)

P(x)=10+5x-4x^2+ 3x^3 + 2x^4
```

| 指数(下标i) | 0    | 1    | 2    | 3    | 4    |
| ----------- | ---- | ---- | ---- | ---- | ---- |
| 系数p[i]    | 10   | 5    | -4   | 3    | 2    |



**[案例2] 一元多项式的运算**

```
Rn(x)=Pn(x)+Qm(x)
线性表R=(p0+q0 , p1+q1 , ... , pn+qm,p(n+1))
```

稀疏多项式

```
S(x)=1+3x^10000 +2x^20000		
会导致存储系数空间0到20000,但是用到的下标只有0,10000,20000 3个,造成空间浪费
```



**[案例3] 稀疏多项式的运算**

多项式非零项的数组表示

```
A(x)=7+3x+9x^8+5x^17
```

| 下标i    | 0    | 1    | 2    | 3    |
| -------- | ---- | ---- | ---- | ---- |
| 系数a[i] | 7    | 3    | 9    | 5    |
| 指数     | 0    | 1    | 8    | 17   |

```
B(x)=8x+22x^7-9x^8
```

| 下标i    | 0    | 1    | 2    |
| -------- | ---- | ---- | ---- |
| 系数b[i] | 8    | 22   | -9   |
| 指数     | 1    | 7    | 8    |

```
Pn(x)=P0+P1 * x+ P2 * x^2 +P3 * x^2+ ... +Pn * x^n
线性表P=((p1,1),(p2,2), ... ,(pn,n))

计算:
线性表A=((7,0),(3,1),(9,8),(5,17))  //(指数,系数)
线性表B=((8,1),(22,7),(-9,8))
创建一个新数组C,有下标和系数c[i]
分别重头遍历比较a 和b 的每一项
指数相同,对应的系数相加,若其和不为0,则在C 中增加一个新项
指数不同,则将指数较小的项复制到C 中,指数大的项留着继续比较
一个多项式已遍历完毕时,将另一个多项式的剩余项依次复制到C 中即可
```

### 顺序存储结构存在问题:

- 存储空间分配不灵活
- 运算的空间复杂度高

解决方法:链式存储结构,不用一片连续的空间,需要用多少用多少



# 多项式相加

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\1-1.png)



### 案例2.3:图书信息管理系统

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\1-2.png)



**线性表与链表的选择:**

- 选择适当的存储结构
- 实现此存储结构上的基本操作
- 利用基本操作完成功能



### 总结:

- 线性表中数据元素的类型可以为`简单类型`,也可以为`复杂类型`(既有字符串,又有整数等)
- 许多实际应用问题所涉及的基本操作有很大相似性,不应该为每个具体应用单独编写一个程序
- 从具体应用中抽象出共性的`逻辑结构和基本操作`(抽象数据类型),然后实现其`存储结构和基本结构`



# 线性表的类型定义

- 抽象数据类型线性表的定义如下:

  ```c
  ADT List{
  	数据对象:D={ai|ai 属于Elemset,(i=1,2,3,...,n,n>=0)}
      数据关系:R={<ai-1 , ai>|ai-1 , ai 属于D, (i=2,3,...,n)}
      基本操作:
      InitList(&L);	DestroyList(&L);
      ListInsert(&L,i,e);	ListDelete(&L,i,&e);
      ......等等
  } ADT List
  ```



### 基本操作(一)

- InitList(&L)    (Initialization List)
  - 操作结果:构造一个空的线性表L
- DestroyList(&L)
  - 初始条件:线性表L 已经存在
  - 操作结果:销毁线性表L
- ClearList(&L)
  - 初始条件:线性表L 已经存在
  - 操作结果:将线性表L 重置为空表



### 基本操作(二)

- ListEmpty(L)
  - 操作结果:若线性表L 为空表,则返回TRUE;否则返回FALSE
- istLength(L)
  - 初始条件:线性表L 已经存在
  - 操作结果:返回线性表L 中的数据元素个数



### 基本操作(三)

- GetElem(L,i,&e)
  - 初始条件:线性表L 已经存在,1<=i<=ListLength(L)
  - 操作结果:用e 返回线性表L 中的第i 个数据元素的值
- LocateElem(L,e,compare())
  - 初始条件:线性表L 已经存在,compare() 是数据元素判定函数
  - 操作结果:返回L 中第1个与e 满足compare() 的数据元素位序,若这样的数据元素不存在则返回0



### 基本操作(四)

- PriorElem(L,cur_e,&pre_e)
  - 初始条件:线性表L 已经存在
  - 操作结果:若cur_e 是L 的数据元素,且不是第一个,则用pre_e 返回他的前驱,否则操作失败;pre_e 无意义
- NextElem(L,cur_e,&next_e)
  - 初始条件:线性表L 已经存在
  - 操作结果:若cur_e 是L 的数据元素,且不是第最后一个,则用next_e 返回他的后继,否则操作失败;next_e 无意义





### 基本操作(无)

- ListInsert(&L,i,e)
  - 初始条件:线性表L 已经存在,1<=i<=ListLength(L)+1
  - 操作结果:在L 的第i 个位置之前插入新的数据元素e,L 的长度加一
  - 插入元素e 之前(长度为n): (a1,a2,.....,ai-1,ai,......,an)
  - 插入元素e 之后(长度为n+1): (a1,a2,.....,ai-1,e,ai,......,an)





### 基本操作(六)

- ListDelete(&L,i,&e)
  - 初始条件:线性表L 已经存在,1<=i<=ListLength(L)
  - 操作结果:删除L 的第i 个数据元素,并用e 返回其值,L 的长度减一
  - 删除前(长度为n):
    - (a1,a2,.....,ai-1,ai,ai+1,......,an)
  - 删除后(长度为n-1):
    - (a1,a2,.....,ai-1,ai+1,......,an)
- ListTraverse(&L,visited())
  - 初始条件:线性表L 已经存在
  - 操作结果:依次对线性表中每个元素调用visited()



- 以上提及的运算是逻辑结构上定义的运算,只要给出这些运算功能是`做什么`,至于,`如何做`等细节实现,只有待确定了存储结构之后才考虑
- 后续课程中将学习线性表的存储及在存储结构上各种操作的实现
  - 线性表的顺序表示和实现
  - 线性表的链式表示和现实





# 线性表的顺序和实现

### 线性表的存储结构

- 在计算机内,线性表有两种基本的存储结构:

  `顺序存储结构`和`链式存储结构`

- 接下来我们分别讨论这两种存储结构,以及对应存储结构下实现各操作的算法

  线性表的顺序表示和实现

  线性表的链式表示和实现



### 线性表的顺序存储表示

线性表的顺序表示又称为`顺序存储结构`或`顺序映像`

**顺序存储定义:** 把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构

```
线性表: (a1,a2, ... ,ai-1,ai,ai+1, ... , an)
```

存储线性表:

| a1   | a2   | ...  | ai-1 | ai   | ai+1 | ...  | an   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 无   | 无   | 无   | 无   | 无   | 无   | 无   | 无   |

简言之,逻辑上相邻,物理上也相邻

线性表的第一个数据元素a1 的存储位置,称作线性表的`起始位置`或`基地址`



**例如: 线性表(1,2,3,4,5,6) 的存储结构:**

| 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 无   | 无   | 无   | 无   | 无   | 无   |

依次存储,地址连续---中间没有空出存储单元

是一个典型的线性表顺序存储结构

| 1    | 2    |      |      | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 无   | 无   |      |      | 无   | 无   | 无   | 无   |

地址不连续---中间存在空的存储单元

不是一个线性表顺序存储结构

线性表顺序存储结构`占用一片连续的存储空间`,知道某个元素的存储位置就可以计算其他元素的存储位置



> 如果每个元素占用8个存储单元,ai 存储位置是2000 单元,则ai+1 存储位置是?
>
> 2008 单元



> 假设线性表的每个元素需占用L 个存储单元,则第i+1 个数据元素的存储位置和第i个数据元素的存储位置之间满足关系:
>
> LOC(ai+1)=LOC(ai)+L
>
> 由此,所有数据元素的存储位置均可由第一个数据元素的存储位置得到:
>
> LOC(ai)=LOC(a1)+(i-1) * L
>
> LOC(a1) 为基地址



### 线性表顺序存储结构的图示:

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\1-3.png)



# 顺序表优缺点

- 优点:
  - 存储密度大(结点本身所占存储量/结点结构所占存储量)
  - 可以随机存取表中任一元素
- 缺点:(克服这一缺点-->使用链表)
  - 在插入,删除某一元素时,需要移动大量元素
  - 浪费存储空间
  - 属于静态存储形式,数据元素的个数不能自由扩充



# 知识点回顾

顺序表的特点: 以物理位置相邻表示逻辑关系

顺序表的优点:任意元素均可随机存取

顺序表的缺点:进行插入和删除操作时,需要移动大量的元素;存储空间不灵活



# 线性表的链式表和实现

- 链式存储结构
  - 结点在存储器中的位置是任意的,即逻辑上相邻的数据元素在物理上不一定相邻
- 线性表的链式表示又称为`非顺序映像`或`链式映像`
- 用一组`物理位置任意的存储单元`来存放线性表的数据元素
- 这组存储单元既可以是连续的,也可以是不连续的,甚至是零散分布在内村中的任意位置上的
- 链表中元素的`逻辑次序和物理次序不一定相同`
- 与链式存储有关的术语:
  - 结点:数据元素的存储映像,有数据域和指针域两部分组成
  - 链表:n 个结点由指针链组成一个链表,它是线性表的链式存储映像,称为线性表的链式存储结构



### 单链表,双链表,循环链表:

- 结点只有一个指针域的链表,称为`单链表`或线性链表
- 结点有两个指针域的链表,称为`双链表`
- 首尾相接的链表称为`循环链表`



### 头指针,头结点和首元结点:

- 头指针:是指向链表中第一个结点的指针
- 首元结点:是指链表中存储第一个数据元素a1 的结点
- 头结点:是在链表的首元结点之前附设的一个结点



**前面的例子中的链表的存储结构示意图有以下`两种形式`:**

- 不带 头结点

- 带 头结点



**讨论1:如何表示空表?**

> 无头结点时,`头指针为空`时表示空表
>
> 有头结点时,当`头结点的指针域为空`时表示空表



**讨论2:在链表中设置`头结点`有什么好处?**

> 1. 便于`首元结点`的处理
>
>    首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其他位置一致,无须进行特殊处理
>
> 2. 便于`空表`和`非空表`的统一处理
>
>    无论链表是否为空,头指针都是指向头结点的非空指针,因此空表和非空表的处理也就统一了



**讨论3:头结点的`数据域`内装的是什么?**

> 头结点的`数据域`可以为空,也可以存放`线性表`长度等附加信息,但此结点不能计入链表长度值



### 链表(链式存储结构)的特点

1. 结构在存储器中的位置是任意的,即逻辑上相邻的数据元素在物理上不一定相邻
2. 访问时只能通过头指针进入链表,并通过每个结点的指针域依次向后顺序扫描其余结点,所以寻找第一个结点和最后一个结点所花费的时间不等



# 单链表的定义和表示

### 带头结点的单链表

单链表是由`表头`唯一确定,因此单链表可以用头指针的名字来命名,若头指针名是L,则把链表称为`表L`



# 单链表的初始化(算法2.6) (带头结点的单链表)

- 构造一个空的单链表
- 算法步骤:
  - 生成新结点作头结点,用头指针L 指向头结点
  - 将头结点的指针域置空
- 补充算法:(判断链表是否为空)
  - 空表:链表中无元素,称为空链表(头指针和头结点任然存在)
- 补充算法2:(单链表的销毁:链表销毁后不存在)
  - 从头节点开始,依次释放所有结点
  - 头指针存储一下个结点,释放当前结点
- 补充算法3:(清空链表)
  - 链表存在,但是链表中无元素,成为空链表(头指针和头结点仍然在)
  - 依次释放所有结点,并将头结点指针域设置为空
- 补充算法4:(求链表的表长)
  - 从首元结点开始,依次计数所有结点
- 算法:取值--取单链表中的第i 个元素的内容
  - 从链表的头指针出发,顺着链域next 逐个结点往下搜索,直至搜索到第i 个结点为止,因此,链表不是随机存取结构
  - 算法步骤:
    - 从第一个结点(L->next)顺链扫描,用指针p 指向当前扫描到的结点,p 初始值=p=L->next
    - j 做计数器,累计当前扫描过的节点数,j 初始值为1
    - 当p 指向扫描到的下一结点时,计数器j 加1
    - 当j == i 时,p 所指向的结点就是要找的第i 个结点
- 算法:按值查找--根据指定数据获取该数据所在的位置(地址)
  - 算法步骤:
    - 从第一个结点起,依次和要查找的e 相比较
    - 如果找到一个其值与e 相等的数据元素,则返回其在链表中的`位置`或地址
    - 如果查遍整个链表都没有找到其值和e 相等的元素,则返回0 或`NULL`
- 算法:按值查找--根据指定数据获取该数据位置序号
- 算法:插入--在第i 个结点前插入值为e 的新结点
  - 算法步骤:
    - 首先找到ai-1 的存储位置p
    - 生成一个数据域为e 的新结点s
    - 插入新结点:
      1. 新结点的指针域指向结点ai
      2. 结点ai-1 的指针域指向新结点
    - 思考:步骤1 和2 能互换吗?先执行2 后执行1
      - 不能,链会断掉,找不到ai
- 算法:删除--删除第i 个结点
  - 算法步骤:
    - 首先找到ai-1 的存储位置p,保存要删除的ai 的值(如果需要ai)
    - 令p->next 指向ai+1
    - 释放结点ai 的空间



### 单链表的查找,插入,删除算法的时间效率分析

**查找:**

- 因线性链表只能顺序存取,即在查找时要从头指针找起,查找时间复杂度为`O(n)`

**插入和删除:**

- 因为线性链表不需要移动元素,只要修改指针,一般情况下时间复杂度为`O(1)`
- 但是,如果要在单链表中进行前插或者删除操作,由于要从头查找前驱结点,所耗时间复杂度为`O(n)`



### 建立单链表

**头插法---元素插入在链表头部,也叫前插法**

- 从一个空表开始,重复读入数据
- 生成新结点,将读入数据存放到新结点的数据域中
- 从最后一个结点开始,依次将各结点插入到链表的前端
- 算法的时间复杂度是:`O(n)`

**尾插法--元素插入在链表尾部,也叫后插法**

- 从一个空表L 开始,将新节点逐个插入到链表的尾部,尾指针r 指向链表的尾结点
- 初始时,r 同L 均指向头结点,每读入一个元素则申请一个新节点,将新节点插入到尾结点后,r 指向新结点
- 算法的时间复杂度是:`O(n)`



# 循环列表

循环列表:是一种头尾相接的链表(即:表中的最后一个结点的指针域指向头结点,整个链表形成一个环)

优点:从表中任意结点出发均可找到表中其他结点



**注意:**

> 由于循环链表中没有NULL 指针,故涉及遍历操作时,其`终止条件`就不在像`非循环链表`那样判断`p->next `是否为空,而是`判断他们是否等于头指针`
>
> 表的操作常常在表的首尾位置上进行

- 头指针表示单循环链表(不方便)
  - 找a1 的时间复杂度:O(1)
  - 找an 的时间复杂度:O(n)
- 尾指针表示单循环链表(不方便)
  - a1 的存储位置是:R->next->next
  - an 的存储位置是:R
  - 时间复杂度是:O(1)



### 带尾指针循环链表的合并(将Tb 合并在Ta 之后)

分析有哪些操作?

- p 存表头结点
- Tb 表头连接到Ta 表尾
- 释放Tb 表头结点
- 修改指针
- 时间复杂度:O(1)



**为什么要讨论双向链表?**

单链表的结点->有指示后继的指针域->找后继结点方便

即:查找某结点的后续结点的执行时间为O(1)



单链表的结点->无指示前驱的指针域->找前驱结点难:从表头出发查找

即:查找某结点的前驱结点的执行时间为O(n)



可用双向链表来克服单链表的这种缺点



### 双向链表

在单链表的每个结点里在`增加一个指向其直接前驱的指针域prior`,这样的链表中就形成了有两个方向不同的链,故称为`双向链表`



### 双向循环链表

和单链的循环表类似,双向链表也可以有循环表

- 让头结点的前驱指针指向链表的最后一个结点
- 让最后一个结点的后继指针指向头结点



双向链表结构的对称性(设指针p 指向某一结点)

```
p->prior->next = p =p->next->proir
```

在双向链表中有些操作(如:ListLength,GetElem 等),因仅涉及一个方向的指针,故他们的算法与线性链表的相同,但在插入,删除时,则需要同时修改两个方向上的指针,两者的操作的时间复杂度均为O(n)



### 双向链表的插入

1. 待插入结点s->prior = p->prior
2. p->prior->next=s
3. s->next=p
4. p->prior=s



### 双向链表的删除

1. p->prior->next=p->next   p 为要删除的结点
2. p->next->prior=>p->prior



# 单链表,循环链表和双向链表的时间效率比较

|                                  | 查找表头结点(首元结点)      | 查找表尾结点                               | 查找结点*p 的前驱结点                            |
| -------------------------------- | --------------------------- | ------------------------------------------ | ------------------------------------------------ |
| 带头结点的单链表L                | L->next<br />时间复杂度O(1) | 从L->next 依次向后遍历<br />时间复杂度O(n) | 通过p->next 无法查找到其前驱                     |
| 带头结点仅设头指针L 的循环单链表 | L->next<br />时间复杂度O(1) | 从L->next 依次向后遍历<br />时间复杂度O(n) | 通过p->next 可以找到到其前驱<br />时间复杂度O(n) |
| 带头结点仅设尾指针R 的循环单链表 | R->next<br />时间复杂度O(1) | R<br />时间复杂度O(1)                      | 通过p->next 可以找到到其前驱<br />时间复杂度O(n) |
| 带头结点的双向循环链表L          | L->next<br />时间复杂度O(1) | L->prior<br />时间复杂度O(1)               | p->prior<br />时间复杂度O(1)                     |



# 顺序表和链表的比较

### 链式存储结构的优点:

- 结点空间可以动态申请和释放
- 数据元素的逻辑次序靠结点的指针来指示,插入和删除时不需要移动数据元素

### 链式存储结构的缺点:

- 存储密度小,每个结点的指针域需要额外占用存储空间,当每个结点的数据域所占字节不多时,指针域所占存储空间的比重显得很大
  - 存储密度:
  - 存储密度是指节点数据本身所占的存储量和整个结点结构中所占的存储之比,即:
  - **存储密度=结点数据本身占用空间(数据域)/结点占用的空间总量(数据域+指针域)**
  - **一般的,存储密度越大,存储空间的利用率就越高,显然,顺序表的存储密度为1(100%),而链表的存储密度小于1**
- 链式存储结构是`非随机存取`结构,对任意结点的操作都要从头指针依指针链查找到该结点,这增加了算法的复杂度

| 比较项目/存储结构 |           | 顺序表                                                       | 链表                                                  |
| ----------------- | --------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| 空间              | 存储空间  | 预先分配,会导致空间闲置或溢出现象                            | 动态分配,不会出现存储空间闲置或溢出现象               |
|                   | 存储密度  | 不用为表示结点间的逻辑关系而增加额外的存储开销,存储密度等于1 | 需要借助指针来体现元素间的逻辑关系,存储密度小于1      |
| 时间              | 存取元素  | 随机存取,按位置访问元素的时间复杂度O(1)                      | 顺序存取,按位置访问元素时间复杂度为O(n)               |
|                   | 插入,删除 | 平均移动约表中的一半元素,时间复杂度为O(n)                    | 不需要移动元素,确定插入,删除的位置后,时间复杂度为O(1) |
| 适用情况          |           | 1.表长变化不大,且能事先确定变化的范围<br />2.很少进行插入或删除操作,经常按元素位置序号访问数据元素 | 1.长度变化较大<br />2.频繁进行插入或删除操作          |



# 线性表的应用

- 线性表的合并:

  - 问题描述:

    假设利用两个线性表La 和Lb 分别表示两个集合A和B ,现要求一个新的集合A=AuB

    La=(7,5,3,11) 

    Lb=(2,6,3) 

    La=(7,5,3,11,2,6)

  - 算法步骤:

    - 依次取出Lb 的中每一个元素,执行以下操作:
      - 在La 中查找该元素
      - 如果找不到,则将其插入La 的最后

- 有序表的合并:(用顺序表实现)

  - 问题描述:

    已知线性表La 和Lb 中的数据元素按值非递减有序排列,现要求将La 和Lb 归并为一个新的线性表Lc,且Lc 中的数据元素仍按值非递减有序排序

    La=(1,7,8)

    Lb=(2,4,6,,8,10,11)

    Lc=(1,2,4,6,7,8,8,10,11)
    
  - 算法步骤:
  
    - 创建一个空表Lc
    - 依次从La 或Lb 中`摘取`元素值比较, 小的结点插入到Lc 表的最后,直到其中一个表变为空为止
    - 继续将La 或Lb 其中一个表的剩余结点插入在Lc 表的最后
    - 算法的时间复杂度时:O(ListLength(La)+ListLength(Lb))
  
- 有序表的合并:(用链表实现)

  - 算法步骤:
    - 用La 的头结点作为Lc 的头结点,即Lc 从La 的头结点开始
    - 依次从La 或Lb 中`摘取`元素值比较, 小的结点插入到La 表当前元素的上一个元素的next,,直到其中一个表变为空为止
    - 继续将La 或Lb 其中一个表的剩余结点插入在La 表的最后->next
    - 释放Lb 的头结点
    - 算法的时间复杂度时:O(ListLength(La)+ListLength(Lb))