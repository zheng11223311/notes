# 树和二叉树

1. 树和二叉树的定义
2. 案例引入
3. 树和二叉树的抽象数据类型定义
4. 二叉树的性质和存储结构
5. 遍历二叉树和线索二叉树
6. 树和森林
7. 哈夫曼树及其应用
8. 案例分析与实现



### 知识回顾

数据的逻辑结构

- 线性结构
  - 线性表
  - 栈(特殊线性表)
  - 队列(特殊线性表)
  - 字符串,数组,广义表
- 非线性结构
  - 树形结构
  - 图形结构



###  树形结构(非线性结构)

- 结点之间有分支
- 具有层次关系

例:

- 自然界
  - 树
- 人类社会
  - 家谱
  - 行政组织机构
- 计算机领域
  - 编译:用树表示源程序的语法结构
  - 数据库系统:用树组织信息
  - 算法分析:用树描述执行过程



### 树的定义

`树(Tree) ` 是n(n>=0) 个结点的有限集

- 若 n=0 ,则称为`空树`

- 若n>0 ,则他满足如下两个条件:

  - 有且仅有一个特定的称为`根(Root)`的结点;
  - 其余结点可分为m (m>=0) 个互不相交的`有限集 T1,T2,T3, ...Tm`,其中每一个集合本身又是一课树,并称为根的`子树(SubTree)`
  - 显然,树是一个递归的定义

  ![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-1.png)







### 树的基本术语

`根结点:`非空树中无前驱结点的结点

结点的`度:`结点拥有的子树数

度!=0 `分支结点`,非终端结点,根结点以外的分支结点称为内部结点

度=0,`叶子`,终端结点

`树的度:`树内各结点的度的最大值

结点的子树的根称为该结点的孩子,该结点称为孩子的`双亲`

如果结点之间有共同的双亲,那么这些结点称为`兄弟结点`

如果结点的双亲在同一个层上,此结点

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-3.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-4.png)



`有序树`:

> 树中结点的各子树从左到右有次序(最左边的为第一个孩子)不同排序方式为不同的有序树(T1,T2,T3,)与 (T3,T2,T1) 是不同的有序树

`无序树`:

> 树中结点的各子树无次序

`森林:`

> 是m (m>=0) 课互不相交的树的集合
>
> 把根结点删除,树就变成了森林
>
> 一颗树可以看成是一个特殊的森林
>
> 给森林中的各子树加上一个双亲结点,森林就变成了树



> 树 一定是 森林  , 森林 不一定是 树



![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-5.png)





### 树结构和线性结构的比较

| 线性结构                         | 树结构                                  |
| -------------------------------- | --------------------------------------- |
| 第一个数据元素 (无前驱)          | 根结点(只有`一`个)  (无双亲)            |
| 最后一个数据元素 (无后继)        | 叶子结点(可以有`多`个)  (无孩子)        |
| 其他数据元素 (一个前驱,一个后继) | 其他结点---中间结点 (一个双亲,多个孩子) |
| 一对一                           | 一对多                                  |



# 二叉树的定义

### **为何要重点研究每结点最多只有两个`叉`的树?**

- 二叉树的结构最简单,规律性最强
- 可以证明,所有树都能转为唯一对应的二叉树,不失一般性



普通树(多叉树) 若不转化为二叉树,则运算很难实现



二叉树在树结构的应用中起着非常重要的作用,因为对二叉的许多操作算法简单,而任何树都可以与二叉树相互转换,这样就解决了树的存储结构及其运算中存在的复杂性



`二叉树`是n(n>=0)个结点的有限集,它或是空集(n=0),或者由一个`根结点`以及`两个互不相交`的分别称作这个根的`左子树`和`右子树`的二叉树组成

`特点:`

1. 每个结点最多有两个孩子(`二叉树中不存在度大于2 的结点`)
2. 子树有左右之分,其次序不能颠倒
3. 二叉树可以是空集合,根可以有空的左子树或空的右子树

**注:二叉树`不是`树的特殊情况,他们是两个概念**

二叉树结点的子树要区分`左子树`和`右子树`即使只有一棵树也要进行区分,说明他是左子树,还是有子树

树当结点只有一个孩子时,就`无需区分`他是左还是右的次序,因此二者是不同的,这是二叉树与树的最重要的差别

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-6.png)

(也就是二叉树每个结点位置或者说是次序都是固定的,可以是空,但是不可以说他没有位置,而树的结点位置是相对于别的结点来说,没有结点时,他就无所谓左右了)



### 思考

具有`3 个结点` 的二叉树可能`有几种不同形态`? `普通树`呢?

二叉树有五种形态:

树有两种形态:

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-7.png)



### 二叉树的5 种形态

- 空二叉树
- 根和空的左右子树
- 根和左子树
- 根和右子树
- 根和左右子树

**注:虽然二叉树与树概念不同,但有关树的基本术语对二叉树都适用**





# 案例引入:数据压缩问题

将数据文件转换成由0,1 组成的二进制串,称之为编码

- 等长编码方案
- 不等长编码方案1
- 不等长编码方式2

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-8.png)

此案例等到学过 哈夫曼树 和 哈夫曼编码 在学习



### 案例2:利用二叉树求解表达式的值

以二叉树表示表达式的递归定义如下:

1. 若表达式为数或简单变量,则相应二叉树中仅有一个根结点,其数据域存放该表达式信息
2. 若表达式为`第一个操作数 运算符 第二个操作数` 的形式,则相应的二叉树中以左子树表示第一个操作数,右子树表示第二个操作数,根结点的数据域存放运算符(若为一元运算符,则左子树为空),其中操作数本身又为表达式

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-9.png)



# 树和二叉树的抽象数据类型定义

### 二叉树的抽象数据类型定义

```c
ADT BinaryTree{
    数据对象D: D 是具有相同特性的数据元素的集合
    数据关系R:若D=空集,则R=空集;
    		若D!=空集,则R={H}; H 是如下二元关系:
    			1. root 唯一		//关于根的说明
                2.Dj n Dk=空集 	//关于子树不相交的说明
                3. ...			 //关于数据元素的说明
                4. ...			 // 关于左子树和右子树的说明
    
    基本操作P:  //至少有20 个
}ADT BinaryTree
```



- CreateBiTree(&T,definition)

  初始条件:denfinition 给出二叉树T 的定义

  操作结果:按 definition 构造二叉树T

- PreOrderTraverse(T)

  初始条件:二叉树T 存在

  操作结果:先序遍历T,对每个结点访问一次

- InOrderTraverse(T)

  初始条件:二叉树T 存在

  操作结果:中序遍历T,对每个结点访问一次

- PostOrderTraverse(T)

  初始条件:二叉树T 存在

  操作结果:后序遍历T,对每个结点访问一次



### 二叉树的性质和存储结构

- `性质1:`在二叉树的第i 层上`至多`有 2^(i-2) 个结点(i>=1)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-10.png)

证明:采用归纳法证明此性质

**归纳基:**

当i=1 时,只有一个根结点,2^(i-1)=2^0=1 命题成立

**归纳假设:**

设对所有的 j (1<=j<=i) ,命题成立,即第j 层上至多有2^(j-1) 个结点,那么可以证明j=i 时命题也成立

**归纳证明:**

有归纳假设可知,第i-1 层上至多有2^(i-2) 个结点,由于二叉树每个结点的度最大为2,故在第i 层上最大结点数为第一层i-1 层上最大结点数的2 倍,即:2*2^(i-2)=2^(i-1) ,证毕



**提问:第i 层上至少有__ 个结点?**

> 1 个结点



- `性质2: `深度为k 的二叉树`至多`有2^k  - 1 个结点(K>=1)

证明:由性质1 可知,深度为k 的二叉树的最大结点数为:

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-11.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-12.png)



**提问:深度为K 时至少有__ 个结点?**

> k



**性质3:对任何一颗二叉树T,如果其子叶数为n0 ,结点数为n0 度为2的结点数为n2 , 则n0=n2+1**

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-13.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-14.png)





### 满二叉树

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-15.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-16.png)



### 完全二叉树

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-17.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-18.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-19.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-20.png)



### 完全二叉树的性质

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-21.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-22.png)



> 性质5:如果对一颗有 n 个结点的`完全二叉树(深度为[log2(n)]+1)`的结点按层序编号(从第1 层到第[log2(n)]+1 层,每层从左到右),则对任一结点i(1<=i<=n) ,有:

- 如果 i=1 ,则结点i 是二叉树的根,无双亲;如果i>1 ,则其`双亲是结点[i/2]  ([] 为取底)`
  - 即父子结点关系为2倍
- 如果 2i>n ,则结点i 为叶子结点,无左孩子;否则,其`左孩子是结点2i`
  - 2i 一定是偶数,偶数一定在左边
- 如果 2i+1 >n ,则结点i 无右孩子;否则,其`右孩子是结点2i+1`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-23.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-24.png)



### 二叉树的存储结构

- 顺序存储结构
- 链式存储结构
  - 二叉链表
  - 三叉链表



> 二叉树的顺序存储

`实现 : `按`满二叉树`的结点层次编号,依次存放二叉树中的数据元素

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-25.png)



> 二叉树的顺序存储缺点:

`最坏情况:`深度为k 的且只有k 个结点的单支数需要长度为2^K -1 的一维数组

> 特点:

结点间关系蕴含在其存储位置中,浪费空间,适用于存`满二叉树和完全二叉树`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-26.png)



### 二叉树的链式存储结构

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-27.png)

即每个结点(除根结点)都有一个指针域指向其父结点



### 三叉链表

在二叉树基础上增加一个指向父节点的指针域

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-28.png)



# 遍历二叉树

- `遍历定义`---顺着某一条搜索路径巡防二叉树中的结点,使得每个结点均被访问一次,而且仅被访问依次,而且仅被访问一次(又称周游)

- "访问"的含义很广,可以是对结点作各种处理,如:输出结点的信息,修改结点的数据值等,但要求这种访问不破坏原来的数据结构

- `遍历目的`---得到树中所有结点的一个线性排列

- `遍历用途`---它是树结构插入,删除,修改,查找和排序运算的前提,是二叉树一切运算的基础

- 遍历方法

  - 依次遍历二叉树中的三个组成部分,便是遍历了整个二叉树
  - 假设:L :遍历左子树 D:访问根节点 R:遍历右子树

  则遍历整个二叉树方案共有:

  DLR,LDR,LRD,DRL,RDL,RLD 六种

  若规定`先左后右`,则只有前三种情况:

  `DLR`-------先(根)序遍历

  `LDR`-------中(根)序遍历

  `LRD`--------后(根)序遍历



### 遍历二叉树算法描述

| 先序遍历二叉树                                               | 中序遍历二叉树                                               | 后序遍历二叉树                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 若二叉树为空,则空操作,否则<br>(1)访问`根`结点<br/>(2)`先序遍历`左子树<br/>(3)`先序遍历`右子树 | 若二叉树为空,则空操作,否则<br/>(1)`中序遍历`左子树<br/>(2)访问`根`结点<br/>(3)`中序遍历`右子树 | 若二叉树为空,则空操作,否则<br/>(1)`后序遍历`右子树<br/>(2)`后序遍历`左子树<br/>(3)访问`根`结点<br/> |

由二叉树的递归定义可知,遍历左子树和遍历右子树可如同遍历二叉树一样`递归`进行



### 先序遍历二叉树的操作定义:

- 若二叉树为空,则空操作;否则
  - 访问根结点
  - 先序遍历左子树
  - 先序遍历右子树    

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-29.png)



### 中序遍历二叉树的操作定义:

- 若二叉树为空,则空操作;否则
  - 中序遍历左子树
  - 访问根结点
  - 中序遍历右子树    

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-30.png)



### 后序遍历二叉树的操作定义:

- 若二叉树为空,则空操作;否则
  - 后序遍历左子树
  - 后序遍历右子树 
  - 访问根结点

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-31.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-32.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-33.png)



### 根据遍历序列确定二叉树

- 若二叉树中各节点的值均不相同,则二叉树结点的先序序列,中序序列和后序序列都是唯一的
- 由二叉树的先序序列和中序序列,或由二叉树的后序序列和中序序列可以确定唯一一颗二叉树
  - 只有先序和后序序列是无法确定二叉树的
  - 因为在推导的时候,无法确定左右子树的数量各多少



### 例题--已知先序和中序序列求二叉树

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-34.png)



![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-35.png)



**后序中最后一个为二叉树的根结点,反向推导**



# 二叉树遍历算法的实现

### 先序遍历

```c#
Status PreOrderTraverse(BiTree T){
    if(T==NULL) return ok;  //空二叉树
    else{
        visit(T);	//访问根结点
        PreOrderTraverse(T->lchild);	//递归遍历左子树
        PreOrderTraverse(T->rchild);	//递归遍历右子树
    }
}
```



### 中序遍历

```c#
Status InOrderTraverse(BiTree T){
    if(T==NULL) return ok;  //空二叉树
    else{
        InOrderTraverse(T->lchild);	//递归遍历左子树
        visit(T);	//访问根结点
        InOrderTraverse(T->rchild);	//递归遍历右子树
    }
}
```





### 后序遍历

```c#
Status PostOrderTraverse(BiTree T){
    if(T==NULL) return ok;  //空二叉树
    else{
        PostOrderTraverse(T->lchild);	//递归遍历左子树
        PostOrderTraverse(T->rchild);	//递归遍历右子树
        visit(T);	//访问根结点
    }
}
```



### 遍历算法的分析

- 如果去掉输出语句,从递归的角度看,三种算法是完全相同的,或者说这三种算法的访问路径是相同的,只是访问结点的时机不同
- 从虚线的出发点到终点的路径上,每个结点经过3次
  - `第一次`经过时访问 = `先序`遍历
  - `第二次`经过时访问 = `中序`遍历
  - `第三次`经过时访问 = `后序`遍历

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-37.png)



- 时间效率:`O(n)`  //每个结点只访问一次
- 空间效率:`O(n)` //栈占用的最大辅助空间



# 遍历二叉树的非递归算法

### 中序遍历非递归算法

二叉树`中序遍历的非递归算法的关键`:在中序遍历过某个结点的整个左子树后,如何找到该结点的根以及`右子树`

> 基本思想:

1. 建立一个`栈`
2. `根`结点`进栈`,遍历`左子树`
3. `根`结点`出栈`,输出根结点,遍历`右子树`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-38.png)



```c#
Status InOrderTraverse(BiTree T){
    BiTree p; InitStack(S); p=T;
    while(p||!StackEmpty(S)){
        if(p) {Push(S,p); p=p->lchild; }
        else{
            Pop(S,q);
            printf("%c",q->data);
            p=q->rchild;
        }
        return ok;
    }
}
```



# 二叉树的层次遍历算法

对于一颗二叉树,从根结点开始,按`从下到上`,`从左到右`的顺序访问每一个结点

每个结点仅仅访问一次



> 算法设计思路:使用一个队列

1. 将根结点进队
2. 队不空时循环:从队列中出列一个结点*p,访问它
   1. 若他有左孩子结点,将左孩子结点进队
   2. 若他有右孩子结点,将右孩子结点进队



> 使用队列类型定义如下:

```c
typedef struct{
    BTNode data[MaxSize];	//存放队中的元素
    int front,rear;		//队头和队尾指针
}sqQueue;	//顺序循环队列类型
```

> 二叉树层次遍历算法:

```c
viod Levelorder(BTNode *b){
    BTNode *p;  SqQueue *qu;
    InitQueue(qu);	//初始化队列
    enQueue(qu,b);	//根结点指针进入队列
    while(!QueueEmpty(qu)){	//队不为空,则循环
        deQueue(qu,p);	//出队结点p
        printf("%c",p->data);	//访问结点p
        if(p->lchild!=NULL) enQueue(qu,p->lchild); //有左孩子时将其进队
        if(p->rchild!=NULL) enQueue(qu,->rchild);	//有右孩子时将其进队
    }
}
```



# 二叉树遍历算法的应用

### 二叉树的建立

- 按先序遍历序列建立二叉树的二叉链表

> 例:已知先序序列为:ABCDEGF

- 从键盘输入二叉树的结点信息,建立二叉树的存储结构
- 在建立二叉树的过程中`按照二叉树先序`方式建立

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-39.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-40.png)

以#表示空结点



### 复制二叉树

- 如果是空树,递归结束
- 否则,申请新结点空间,复制根结点
  - 递归复制左子树
  - 递归复制右子树

```c
int Copy(BiTree,BiTree &NewT){
    if(T==NULL){	//如果是空树,返回0
        NewT=NULL;
        return 0;
    }
    else{
        NewT=new BiTNode;
        newT->data=T->data;
        Copy(T-lchild,newT->lchild);
        Copy(T-rchild,newT->rchild);
    }
}
```



### 计算二叉树的深度

- 如果是空树,则深度为0
- 否则,递归计算左子树的深度记为m, 递归计算右子树的深度记为n,二叉树的深度则为m 与n 的较大者加1

```c
int Deepth(BiTree T){
    if(T==NULL) return 0;	//如果是空树返回0
    else{
        m=Deepth(T->lChild);
        n=Deepth(T->rChild);
        if(m>n) return (m+1);
        else return (n+1);
    }
}
```



### 计算二叉树结点总数

- 如果是空树,则结点个数为0;
- 否则,结点个数为左子树的结点+ 右子树的结点个数再 + 1

```c
int NodeCount(BiTree T){
    if(T==NULL)
        return 0;
    else{
        return NodeCount(T->lchild)+NodeCount(T->rchild)+1;
    }
}
```



### 计算二叉树叶子结点数

- 如果是空树,则叶子结点个数为0;
- 否则,为左子树的叶子结点个数+右子树的叶子结点个数

```c
int LeafCount(BiTree T){
    if(T==NULL) //如果是空树返回0
        return 0;
    if(T->lchild==NULL&&T->rchild==NULL){
        return 1;
    }
    else{
        return LeafCount(t->lchild)+LeafCount(t->rchild);
    }
}
```



# 线索二叉树

> 问题:为什么要研究线索二叉树?

当用二叉链表作为二叉树的存储结构时,可以很方便的找出某个结点的左右孩子

但一般情况下,`无法直接找到该结点在某种遍历序列中的前驱和后继结点`

> 提出问题: 如何寻找特定遍历序列中二叉树结点的前驱和后继??

解决的方法:

1. 通过遍历寻找---费时间
2. 再增设前驱,后继指针域--------增加了存储负担
3. `利用二叉链表中的空指针域`



### 回顾

> 二叉树链表中空指针域的数量

具有n 个结点的二叉链表中,一共有`2n` 个指针域,因为n 个结点中有n-1 个孩子,即2n 个指针域中,有n-1 个用来指示结点的左右孩子,其余`n+1 指针域为空`



> 利用二叉链表中的空1指针域:

如果某个结点的左孩子为空,则将空的左孩子指针域改为`指向其前驱`

如果某个结点的右孩子为空,则将空的右孩子指针域改为`指向其后继`

----------------这种`改变指向的指针`称为`线索`

加上了线索的二叉树称为`线索二叉树(Threaded Binary Tree)`

对二叉树按某种遍历次序使其变为线索二叉树的过程叫`线索化`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-41.png)



> 为区分 lchild 和 rchild 指针到底是指向孩子的指针,还是指向前驱或者后继的指针,对二叉链表中`每个结点增设两个标志域`ltag 和rtag ,并约定:

- ltag =0 ,lchild 指向该结点的`左孩子`
- ltag=1 ,lchild 指向该结点的`前驱`
- rtag =0 ,rchild 指向该结点的`右孩子`
- rchild=1,rchild 指向该结点的`后继`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-42.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-43.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-44.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-45.png)



为了避免浪费多余的空指针:在空指针上`增设了一个头节点`

ltag=0,lchild 指向根结点

rtag=1,rchild 指向遍历序列中最后一个结点

遍历序列中第一个结点的lc 域和最后一个结点的rc 域都指向头节点

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-46.png)





# 树和森林

### 树和森林的定义

`树`(Tree) 是n(n>=0) 个结点的有限集,若n=0, 称为`空树`

若n>0 

1. 有且仅有一个特定的称为`根(Root)`的结点
2. `其余结点`可分为m(m>=0) 个互不相交的`有限集T1,T2,T3, ... ,Tm`

`森林: `是m(m>=0) 棵互不相交的树的集合

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-47.png)



### 树的存储结构

1. 双亲表示法

`实现:`

定义结构数组

存放树的结点

每个结点含两个域:

`数据域:`存放结点本身信息

`双亲域: `指示结点的双亲结点在数组中的位置

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-48.png)



> c语言的类型描述:

```c
typedef struct PTNode{
    TElemType data;
    int parent;		//双亲位置域
}PTNode;
```

> 树结构

```c
#define MAX_TREE_SIZE 100
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];
    int r,n;	// 根结点的位置和结点个数
}PTree;
```



### 孩子链表

把每个结点的孩子结点排列起来,看成是一个线性表,用单链表存储,则n 个结点有n 个孩子链表(叶子的孩子链表为空表),而n 个头指针又组成一个线性表,用顺序表(含n 个元素的结构数组)存储

> c 语言类型描述:
>
> 孩子结点结构:

```c
typedef struct CTNode{
    int child;
    struct CTNode *next;
}*ChildPtr;
```

> 双亲结点结构:

```c
typedef struct {
   TElemType data;
    ChildPtr firstchild;	//孩子链表头指针
}CTBox;
```

> 树结构:

```c
typedef struct{
    CTBox nodeds[MAX_TREE_SIZE];
    int n,r;	//结点树和根结点的位置
}CTree;
```

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-49.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-50.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-51.png)



### 孩子兄弟表示法(二叉树表示法,二叉链表表示法)

实现:用二叉链表作树的存储结构,链表中每个结点的两个指针域分别指向其`第一个孩子结点`和`下一个兄弟结点`

```c
typedef struct CSNode{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-52.png)



# 树与二叉树的转换

- 将树转化为二叉树进行处理,利用二叉树的算法来实现对树的操作
- 由于树和二叉树都可以用二叉链表作存储结构,则`以二叉链表作媒介`可以导出树与二叉树之间的一个对应关系

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-53.png)



### 将树转化成二叉树

1. 加线:在兄弟之间加一连线
2. 抹线:对每个结点,除其左孩子外,去除其与其余孩子之间的关系
3. 旋转:以树的根结点为轴心,将整树顺时针转45°

> 树变二叉树:兄弟相连留长子

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-54.png)



### 将二叉树转换成树

1. 加线;若p 结点是双亲结点的左孩子,则将p 的右孩子,右孩子的右孩子 .... 沿分支找到的所有右孩子,都与p 的双亲用线连起来
2. 抹线:抹掉原二叉树中双亲与右孩子之间的连线
3. 调整:将结点按层次排列,形成树结构

> 二叉树变树:
>
> 左孩右右连双亲
>
> 去掉原来右孩线

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-55.png)



# 森林和二叉树

### 森林转换成二叉树

(二叉树与多颗树之间的关系)

1. 将各棵树分别转化成二叉树
2. 将每棵树的根结点用线相连
3. 以第一棵树根结点为二叉树的根,再以根结点为轴心,顺时针旋转,构成二叉树型结构

> 森林变二叉树
>
> 树变二叉根相连

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-56.png)



### 二叉树转换成森林

1. 抹线:将二叉树中根结点与其右孩子连线,及沿右分支搜索到的所有右孩子间连线全部抹掉,使之变成孤立的二叉树
2. 还原:将孤立的二叉树还原成树

> 二叉树变森林:
>
> 去掉全部右孩线,孤立二叉再还原

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-57.png)



# 树和森林的遍历

### 树的遍历(三种方式)

- `先根(次序)遍历:`若树不为空,则先访问根结点,然后依次先根遍历各棵子树
- `后根(次序)遍历; `若树不为空,则先依次后根遍历各棵子树,然后访问根结点
- `按层次遍历: `若树不空,则自上而下自左而右访问树中每个结点
- 没有中序遍历,因为树不是二叉树,树有很多分支,无法指定那个分支为中

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-58.png)



将森林看作由三个部分构成:

1. 森林中第一棵树的根结点
2. 森林中第一棵树的子树森林
3. 森林中其他树构成的森林

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-59.png)





### 先序遍历

若森林不空,则

1. `访问森林第一棵树的根结点`
2. `先序遍历`森林中第一棵树的子树森林
3. `先序遍历`森林中(除第一棵树之外)其余树构成的森林

> 即:依次从左到右对森林中的每一棵树进行先根遍历



### 中序遍历

若森林不空,则

1. `中序遍历`森林中第一棵树的子树森林
2. `访问森林中第一棵树的根结点`
3. `中序遍历`森林中(除第一棵树之外)其余树构成的森林

> 即:依次从左至右对森林中的每一棵树进行后根遍历

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-60.png)



# 哈夫曼树及其应用

哈夫曼(霍夫曼,赫夫曼) David Albert Huffman (August 9, 1925 -October 7 ,1999), 计算机科学的先驱,以他的哈夫曼编码闻名,在他的一生中,对于有限状态自动机,开关电路,异步过程和信号设计有杰出的贡献

他发明的Huffman 编码能够使我们通常的数据结构传输数量减少到最小,这个编码的发明和这个算法一样十分引人入胜,1950年,Huffman 在MIT 的信息理论与编码研究生班学习,Robert Tano 教授让学生们自己决定是参加期末考试还是做一个大作业,而Huffman 选择了后者,原因很简单,因为解决了一个大作业可能比期末考试更容易通过,这个大作业促使了Huffman 算法的诞生

离开了MIT 后,Huffman 来到University of California 的计算机系任教,并为此系的学术做出了许多杰出的工作,而他的算法也广泛应用于传真机,图像压缩和计算机安全领域,但是Hunffman 却从未此算法申请过专利或其他相关能够为他带来经济利益的东西,他将他全部的精力放在教学上,以他自己的话来说,"我所要带来的就是我的学生"

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-61.png)



### 哈夫曼树的基本概念

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-62.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-63.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-64.png)



> `路径`:从树中一个结点到另一个结点之间的`分支`构成这两个结点间的路径
>
> `结点的路径长度: `两结点路径上的`分支数`
>
> `树的路径长度:`从`树根`到每一个结点的`路径长度之和`,记作:TL
>
> **结点数目相同的二叉树中,完全二叉树是路径长度最短的二叉树,路径最短的不一定是完全二叉树(完全二叉树的左孩子变成右孩子)**

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-65.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-66.png)



`权(weight):`将树中结点赋给一个有着某种含义的数值,则这个数值称为该`结点的权`

`结点的带权路径长度: `从`根`结点到该结点之间的`路径长度`与该结点的`权`的`乘积`

`树的带权路径长度:`树中所有`叶子`结点的`带权路径长度之和`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-67.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-68.png)

权重越高放在越前面,带权长度越小





`哈夫曼树`: 最优树 ,带权路径长度(WPL)最短的树

**注:"带权路径长度最短" 是在"度相同"的树中比较而得的结果,因此有最优二叉树,最优三叉树之称等等**

`哈夫曼树`: 最优二叉树 ,带权路径长度(WPL)最短的二叉树

> 满二叉树不一定是哈夫曼树
>
> 哈夫曼树中权越大的叶子离根越近
>
> 具有相同带权结点的哈夫曼树不唯一

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-69.png)



### 哈夫曼树的构造算法

贪心算法:构造哈夫曼树时首先选择权值小的叶子结点



> 哈夫曼算法(构造哈夫曼树的方法)

1. 根据n 个给定的权值{W1,W2, ... ,Wn} 构成n 棵二叉树的森林 F={T1, T2, ... ,Tn}, 其中Ti 只有一个带权为Wi 的根结点
   1. 构造森林全是根
2. 在F 中选取两颗根结点的权值最小的树作为左右子树,构造一颗新的二叉树,且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
   1. 选用两小造新树
3. 在F 中删除这两棵树,同时将新得到的二叉树加入森林中
   1. 删除两小添新人
4. 重复 (2)-(3) 的操作,直到森林中只有一颗树为止,这棵树即为哈夫曼树



### 如何构造哈夫曼树?

哈夫曼算法口诀:

1. 构造森林全是根
2. 选用两小造新树
3. 删除两小添新人
4. 重复2,3 剩单根

![5-70](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-70.png)





![5-71](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-71.png)





![5-72](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-72.png)



### 总结

1. 在哈夫曼算法中,初始时有n 棵二叉树,要经过n-1 次合并最终形成哈夫曼树
2. 经过n-1 次合并产生n-1 个新结点,且这n-1 个新结点都是具有两个孩子的分支结点
3. 可见:哈夫曼树中共有n+n-1=2n-1 个结点,且其所有的分支结点的度均不为1



### 哈夫曼树构造算法的实现

采用顺序存储结构------------ 一维结构数组

结点类型定义

```c
typedef struct{
    int weight;
    int parent,lch,rch;
}HTNode ,*Huffman Tree;
```

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-73.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-74.png)





1. 初始化`HT [1......2n-1]:`lch=rch=parent=0

2. 输入初始值`n 个叶子结点:`置HT[1......n] 的`weight 值`

3. `进行以下n-1 次合并`,依次产生n-1 个结点HT[i] ,i=n+1 .... 2n-1

   1. 在HT[1...i-1] 中选两个`未被选过`(从parent==0 的结点中选)的weight 最小的两个结点`HT[s1]`和`HT[s2],s1 和s2 为两个最小结点下标`

   2. 修改HT[s1] 和HT[s2] 的parent 值,HT[s1].`parent=i; `HT[s2].`parent=i`

   3. 修改新产生的HT[i]

      ```c
      HT[i].weight=HT[s1].weight+HT[s2].weight;
      HT[i].lch=s1;
      HT[s1].rch=s2;
      ```

      

```c
void CreateHuffmanTree(HuffmanTree HT,int n){	//构造哈夫曼树---哈夫曼算法
    if(n<=1) return;
    m=2*n-1;	//数组共2n-1 个元素
    HT=new HTNode[m+1];	//0 号单元未用,HT[m] 表示根结点
    for(i=1;i<=m;++i){	//将2n-1 个元素lch ,rch ,parent 置为0
        HT[i].lch=0;
        HT[i].rch=0;
        HT[i].parent=0;
    }
    for(i=1;i<=n;++i) cin>>HT[i].weight;	//输入前n 个元素的weight 值
    //初始化结束,下面开始建立哈夫曼树
    for(i=n+1;i<=m;i++){	//合并产生n-1 个结点---构造Huffman 树
        Select(HT,i-1,s1,s2);	//在HT[k](1<=k<=i-1) 中选择两个其双亲域为0,且权值最小的结点,并返回它们在HT 中的序号s1 和s2
        HT[s1].parent=i; //表示从F 中删除s1,s2
        HT[s2].parent=i; 	
        HT[i].lch=s1;	//s1,s2 分别作为i 的左右孩子
        HT[i].rch=s2;
        HT[i].weight=HT[s1].weight+HT[s2].weight;	//i 的权值为左右孩子权值之和
    }
}
```

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-75.png)



### 哈夫曼编码

- 在远程通讯中,要将待传字符串转换成由二进制的字符串
- 设要传送的字符为:ABACCDA
  - 若编码为: 
    - A---00
    - B---01
    - C---10
    - D---11
- 若将编码设计为长度不等的二进制编码,即让待传字符串中`出现次数较多的字符采用尽可能短的编码`,则转换的二进制字符串便可能减少
- 设要传送的字符为:ABACCDA
  - 若编码为: 
    - A---0
    - B---00
    - C---1
    - D---01

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-76.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-77.png)

关键:要设计长度不等的编码,必须使任意字符的编码都不是另一个字符的编码的前缀 -----这种编码称作`前缀编码`



> 问题:什么样的前缀码能使得电文总长最短?
>
> 哈夫曼编码

> 方法:

1. `统计`字符集中`每个字符`在电文中`出现的`平均`概率`(概率越大,要求编码越短)

2. 利用哈夫曼树的特点:权越大的叶子离根越近,`将每个字符的概率作为权值,构造哈夫曼树`则概率越大的结点,路径越短

3. 在哈夫曼树的每个分支上标记0 或1:

   结点的`左分支标0,右分支标1`

   把从根到每个叶子的路径上的标号连接起来,作为该叶子代表的`字符的编码`

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-78.png)



> 两个问题:
>
> 1.为什么哈夫曼编码能够保证是前缀编码?
>
> 因为没有一片树叶是另一片叶子的祖先,所以每个叶结点的编码就不可能是其他叶结点编码的前缀
>
> 2.为什么哈夫曼编码能够保证字符串编码总长度最短?
>
> 因为哈夫曼树的带权路径长度最短,故字符编码的总长度最短



- 性质1: 哈夫曼编码是前缀码
- 性质2: 哈夫曼编码是最优前缀码



![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-79.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-80.png)



![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-81.png)



```c
void CreatHuffmanCode(Huffman Tree HT,HuffmanCode &HC,int n){
    //从叶子到根逆向求每个字符的哈弗曼编码,存储在编码表HC 中
    HC=new char *[n+1];	//分配n 个字符编码的头指针矢量
    cd=new char[n];	//分配临时存放编码的动态数组空间
    cd[n-1]='\0';	//编码结束符
    for(i=0;i<=n;++i){	//逐个字符求哈夫曼编码
        start=n-1;c=i;f=HC[i].parent;
        while(f!=0){	//从叶子结点开始向上回溯,直到根结点
            --start;	//回溯一次start 向前指一个位置
            if(HT[f].lchild==c) cd[start]='0';	//结点c 是f 的左孩子,则生成代码0
            else	cd[start]='1';	//结点c 是f 的右孩子,则生成代码1
            c=f;f=HT[f].parent;	//继续向上回溯
        }
        HC[i]=new char [n-start];	//为第i 个字符串编码分配空间
        strcopy(HC[i],&cd[start]);	//将求得的编码从临时空间cd 复制到HC 的当前行中
    }
    delete cd;	//释放临时空间
} //CreatHuffmanCode
```



# 文件的编码和译码

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-82.png)

![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-83.png)



### 编码

1. 输入各字符及其权值
2. 构造哈夫曼树------HT[i]
3. 进行哈夫曼编码-----HC[i]
4. 查HC[i] ,得到各字符的哈夫曼编码



### 解码

- 构造哈夫曼树
- 依次读入二进制码
- 读入0 ,则走向左孩子;读入1 ,则走向右孩子
- 一旦到达某叶子时,即可译出字符
- 然后再从根出发继续译码,直到结束



![](D:\学习\wanye\数据结构与算法\青岛大学-王卓\img\5-84.png)

