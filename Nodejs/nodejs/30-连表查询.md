**外键**

> 思考:怎么保证关系列数据的有效性呢?任何整数都可以吗?
>
> 必须是学生表中的id 列存在的数据,可以通过外键约束进行数据有效性验证
>
> 为stuid 添加外键约束
>
> ```
> alter table scores add constraint stu_sco foreign key(stuid) references students(id);
> ```
>
> 在此插入或修改数据时,如果stuid 的值在student 表中不存在就会报错
>
> 在创建表时可以直接创建约束
>
> ```
> create table scores(
> id int primary key auto_increment,
> stuid int,
> subid int,
> scores decimal(5,2),
> foreifn key(stuid) references students(id),
> foreifn key(subid) references subjects(id),
> );
> ```

**外键的级联操作**

> 在删除students 表的数据时,如果这个id 值在scores 中已经存在,则会抛出异常
>
> 推荐使用逻辑删除,还可以解决这个问题
>
> 语法:
>
> ```
> alter table scores add constraint stu_sco foreign key(stuid) references students(id) on delete cascade;
> ```
>
> 级联操作的类型包括:
>
> resstrict(限制):默认值,抛异常
>
> cascade(级联):如果主表的记录删掉,则从表中相关联的记录都将被删除,则从表中相关联的记录都将被删除
>
> set null:将外键设置为空
>
> no action:什么都不做

**连接查询**

连接查询分类如下:

表A inner join 表B: 表A 与表B 匹配行会出现在结果中

表A keft join 表B:表A 与表B 匹配的行会出现在结果中,外加表A 中独有的数据,未对应的数据使用null 填充

表A keft join 表B:表A 与表B 匹配的行会出现在结果中,外加表B 中独有的数据,未对应的数据使用null 填充

在查询或条件中推荐使用"表名.列名"的语法

如果多个表中列名不重复可以省略"表名."部分

如果表的名称太长,可以在表名后面使用'as 简写名' 或者'简写名',为表起个临时的简写名称

