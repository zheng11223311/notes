**运行js 文件**

> ```js
> //index.js 文件
> class  User{
>      constructor(){
>          this.uesrname='小明'
>      }
> }
> var u1= new User()
> console.log(u1);
> ```
>
> 在node 上运行index.js 文件
>
> 在index.js 文件的当前路径下运行node index.js
>
> 如果在别处的js 则要指定js 的路径

**装饰器**

```js
@zsq
class  User{
     constructor(){
         this.uesrname='小明'
     }
}


function zsq(target){       //这里的target 在这里就是User 这个类
    console.log(target);        
    target.prototype.logger=()=>`${target.name}被调用`
    
}


var u1= new User()
console.log(u1);
ul.logger()     //User 被调用
```

**获取第三方模块**

> npmjs.com :第三方模块的存储和分发仓库

**第三方模块 nodemon**

> nodemon 是一个命令工具,用于辅助项目开发
>
> 在Node.js 中,每一次修改文件都要在命令行工具中重新执行该文件,非常繁琐
>
> **使用步骤**
>
> 1.安装
>
> npm install nodemon -g
>
> 2.使用
>
> 在命令行工具中使用nodemon 命令代替 node 命令执行文件
>
> 比如 node index.js 替换为nodemon index.js 
>
> 3.退出程序
>
> 和node 一样,连续使用2 次 ctrl+c

**第三方模块 nrm**

> nrm(npm registry manager): npm 下载地址切换工具
>
> npm 默认的下载地址在国外,国内下载速度慢
>
> 1.安装
>
> npm install nrm -g
>
> 2.使用
>
> 查询可用的下载地列表: nrm ls
>
> 切换npm 下载地址:nrm use 下载地址名称,比如 nrm use taobao

**第三方模块 Gulp**

> 基于node 平台开发的前端构建工具
>
> 将机械化操作编写成任务,想要执行机械化操作时执行一个命令任务就能自动执行了,用机器代替手工,提高开效率
>
> **Gulp 能做什么?**
>
> 项目上线,HTML,CSS,JS文件压缩
>
> 语法转换(es6,less...)
>
> 公共文件抽离
>
> 修改文件浏览器自动刷新
>
> 1.安装
>
> npm install gulp
>
> 2.使用
>
> 在项目根目录下建立gulpfile.js 文件,src 目录和dist 目录
>
> src 目录放置源代码文件,dist 目录放置构建(打包)后文件
>
> 在gulpfile.js 文件中编写任务
>
> ```js
> //gulpfile.js 文件
> const gulp=require('gulp')
> const htmlmin=require('gulp-htmlmin')
> const fileinclude=require('gulp-file-include')
> const less=require('gulp-less')
> const csso=require('gulp-csso')
> const babel=require('gulp-babel')
> const uglify=require('gulp-uglify')
> 
> 
> 
> //使用gulp.task() 方法建立任务
> gulp.task('first',()=>{     //first     建立的任务的名字
>     //获取要处理的文件
>     gulp.src('./src/css/base.css')
>     // 将处理后的文件输出到dist 目录
>     .pipe(gulp.dest('./dist/css'))
> })
> 
> // html 任务
> // 1.html 文件中代码的压缩操作
> 
> gulp.task('htmlmin',()=>{       //htmlmin     建立的任务的名字
>    
>     gulp.src('./src*.html')
>     // 将抽离的公共代码放到同一个./common/common.html 文件中
>     // ,在被抽离的html 中 要使用的地方使用@@include('./common/common.html')
>     .pipe(fileinclude())
>     //压缩html 文件中的代码     collapseWhitespace  折叠空格
>     .pipe(htmlmin({collapseWhitespace:true}))
>     .pipe(gulp.dest('dist'))
> })
> 
> // 2.抽离html 文件中的公共代码
> 
> 
> 
> // css 任务
> // 1.less 语法转换
> // 2.css 代码压缩
> gulp.task('cssmin',()=>{
>     //选着所有css 文件和less 文件
>     gulp.src(['./src/*.less','./src/css/*.css'])
>         //语法转换
>     .pipe(less())
>     //压缩css
>     .pipe(csso())
>     .pipe(gulp.dest('dist/css'))
> })
> 
> 
> //js 任务
> //1.es6 语法转换
> // 2.代码压缩
> gulp.task('jsmin',()=>{
>     gulp.src('./src/js/*.js')
>         // es6 语法转换
>     .pipe(babel({
>         //它可以判断当前代码的运行环境 将代码转换为当前运行环境所支持的代码
>         presets:['@babel/env']
>     }))
>     // 代码压缩
>     .pipe(uglify())
>     .pipe(gulp.dest('./dist/js'))
> })
> 
> // 复制文件夹
> gulp.task('copy',()=>{
>     gulp.src('./src/images/*')
> 
>     .pipe(gulp.dest('./dist/images'))
> 
>     gulp.src('./src/lib/*')
>     
>     .pipe(gulp.dest('./dist/lib'))
> })
> 
> 
> //构建任务,所有任务一起执行
> gulp.task('default',['htmlmin','cssmin','jsmin','copy'])       
> // 执行gulp default   执行gulp 默认找 default 命令
> ```
>
> **Gulp 中提供的方法**
>
> gulp.src():获取任务要处理的文件
>
> gulp.dest(): 输出文件
>
> gulp. task():建立gulp 任务
>
> gulp.watch(): 监控文件的变化
>
> 在命令行中执行任务
>
> **1.使用gulp-cli 命令行工具执行项目**
>
> 安装
>
> npm install gulp-cli -g
>
> 使用
>
> gulp 任务名字	比如gulp first
>
> **命令行提示结果:**
>
> Using gulpfile  使用gulp 执行任务
>
> Starting 'first'  执行first
>
> **Gulp 插件**
>
> gulp-htmlmin:html 文件压缩
>
> gulp-csso:压缩文件
>
> gulp-less:less 语法转化
>
> gulp-babel:JavaScript 语法转化
>
> gulp-uglify: 压缩混淆JavaScript
>
> gulp-file-include:公共文件包含
>
> browsersync :浏览器实时同步
>
> 安装
>
> npm install gulp-htmlmin
>
> npm install gulp-file-include
>
> npm install gulp-less
>
> npm install gulp-csso
>
> npm install gulp-babel @babel/core @babel/preset-env	//一次下载多个包 @babel/core @babel/preset-env为babel 的依赖
>
> npm install gulp-uglify
>
> 

**模块的导出和导入**

```js
//index.js 文件
let a=require('./index1')
//1. 在没有任何的内容导出去的情况下获取到那个文件时,会得到一个空对象{}
//console.log(1) 却可以导出去,但是函数还不能导出去

//2. require 获取路径时,可以不加后缀名,默认是.js
console.log(a);
```

```js
//index1.js 文件
console.log(1)
function a(){
    console.log(1);
}

let a=1
let b=2

//exports 就是默认导出的对象

exports.a=a     //导出a,被其他模块导入时是一个对象形式
moudle.exports.b=b  //导出b
exports=moudle.exports     
//使用exports,系统找的是moudle.exports,系统默认设置了exports=moudle.exports
exports={
    User:'小明'
}       //exports 导出对象时,不影响其他的导出,比如a 和b,因为系统找的是moudle.exports
moudle.exports={
     User:'小明'
}       //moudle.exports 导出对象是,其他导出无效
//注意使用exports 时,只能当个设置属性exports.a=a
//使用moudle.exports 可以单个设置属性,也可以整个赋值
```

**模块的初始化**

> 一个模块中的js 代码仅在模块第一次被使用执行一次,并且在使用过程中进行初始化,之后缓存起来便于后续继续使用

```js
//index.js 文件
let a=require('./index1')
let b=require('./index1')	//多次导入只执行一次,比如导入的打印只执行一次
console.log(a==b)		//true,a 对象和b 对象是一样的
```

**导入原理模块**

> Node.js 中使用CommonJS 模块化机制,通过npm 下载的第三方包,我们在项目中引入第三方包都是:`let xx=require('第三方包名')`,究竟require 方法加载第三方包的原理机制是什么,今天我们来探讨一下
>
> 1.require('第三方包名') 优先在加载该包的模块的同级目录node_modules 中查找第三方包
>
> ```js
>  let template=require('art-template')    //加载第三方包
> ```
>
> 2.找到该第三方包中的package.json 文件,并且找到里面的main 属性对应的入口模块,该入口模块即为加载的第三方模块  "mian":"dist/jquery"
>
> 3.如果在要加载的第三方包中没有找到package.json 文件或者是package.json 文件中没有main 属性,则默认加载第三方包中的index.js 文件
>
> 4.如果在加载第三方模块的文件的同级目录没有找到node_modules 文件夹,或者以上所有的情况都没有找到,则会依次向上一级父级目录下查找node_modules 文件夹,查找规则如上一致
>
> 5.如果一直找到该模块的根路径都没有找到,则会报错:can not find module xxx

**npm 常见的命令**

> npm -v : 查看npm 版本
>
> npm init : 初始化后会出现一个package.json 配置文件,可以在后面加上 -y,快速跳过问答式界面
>
> npm install: 会根据项目中的package.json 文件自动下载项目所需的全部依赖
>
> npm install 包名  --save-dev 或 npm install 包名 -D :安装的包只用于开发环境,不会用于生产环境,会出现在package.json 文件中的devDependencies 属性中
>
> npm install 包名  --save 或 npm install 包名 -S :安装的包需要发布到生产环境的,会出现在package.json 文件中的dependencies 属性中,不加默认是生产环境
>
> npm install -product  安装package.json 中生产环境所需要的包
>
> npm list: 查看当前目录下已安装的node 包
>
> npm list -g: 查看全局已经安装过的node 包
>
> npm --help:查看npm 帮助命令
>
> npm updata 包名:更新指定的包
>
> npm uninstall 包名:卸载指定的包名
>
> npm config list: 查看配置信息
>
> npm 指定命令 --help: 查看指定命令的帮助
>
> npm info 指定包名:查看远程npm 上指定包的所有版本信息
>
> npm config set registry https://registry.npm.taobao.org : 修改包下载源,此例修改为了淘宝镜像
>
> npm root: 查看当前包的安装路径
>
> npm root -g:查看全局的包的安装路径
>
> npm ls 包名: 查看本地安装的指定包及版本信息,没有则显示empty
>
> npm ls 包名 -g: 查看全局安装的指定包及版本信息,没有则显示empty
>
> 

