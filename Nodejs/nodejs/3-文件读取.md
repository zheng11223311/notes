**文件读取**

> **运行 cmd:** node index.js
>
> 项目运行:node ./bin/www
>
> **同步读取**
>
> ```js
> //index.js 文件
> // 文件读取
> // node 默认的方式是异步
> var fs=require('fs')
> console.log(fs);        //打印出fs 所有的方法
> //导入文件模块
> //node,读写文件也有同步和异步的接口
> 
> //同步
> var content=fs.readFileSync('hello.txt',{flag:'r',encoding:'utf-8'},)   //直接打开并读取   
> // 没有设置encoding,默认返回一个缓冲区,需要encoding 才能读取到
> console.log(content);
> console.log(content.toString());  //将content 转换为字符串类型
> //同步读取文件会阻塞(消耗时间)后面语句的执行
> 
> //同步
> var fd=fs.openSync('hello.txt','r')		//同步打开文件
> console.log(fd);    // 返回3,在内存里打开,3只是一个标识
> ```
>
> ```txt
> //hello.txt 文件
> 这是一段文本
> ```
>
> **异步读取**
>
> ```js
> //index.js 文件
> //readFile 的相对路径是当前命令行的路径的相对路径,而不是当前文件所在的相对路径
> //require 的相对路径是相对于当前文件的路径
> // 异步
> var fs=require('fs')
> var fd=fs.readFile('hello.txt',{flag:'r',encoding:'utf-8'},function(err,data){
> //必须要有回调函数
> if(err){
> console.log(err);
> }else{
> console.log(data);
> }
> 
> })
> console.log(111);
> ```
>
> **封装异步读取文件函数**
>
> ```js
> //index.js 文件
> // 封装函数
> var fs=require('fs')
> function fsRead(path){
> return new Promise(function(reslove,reject){
> fs.readFile(path,{flag:'r',encoding:'utf-8'},function(err,data){
> if(err){
>    // 失败执行的内容
>    reject(err)
> }else{
>    //成功时执行的内容
>    reslove(data)
> }
> })
> })
> }
> 
> var w1=fsRead('hello.txt')
> w1.then(function(res){
> console.log(res);
> })
> ```
>
> **封装异步读取多个文件**
>
> ```js
> //index.js 文件
> // 封装函数
> var fs=require('fs')
> function fsRead(path){
> return new Promise(function(reslove,reject){
> fs.readFile(path,{flag:'r',encoding:'utf-8'},function(err,data){
> if(err){
>    // 失败执行的内容
>    reject(err)
> }else{
>    //成功时执行的内容
>    reslove(data)
> }
> })
> })
> }
> 
> // 封装异步读取多个文件
> async function ReadList(){
> var file=await fsRead('hello.txt')		//内容有空格会报错
> console.log(file);
> var file1=await fsRead(file+'.txt')
> console.log(file1);
> var file2=await fsRead(file1+'.txt')
> console.log(file2);
> }
> ReadList()
> ```
>
> **hello.txt 文件**
>
> ```txt
> hello1
> ```
>
> **hello1.txt 文件**
>
> ```txt
> hello2
> ```
>
> **hello2.txt 文件**
>
> ```txt
> 这是hello3 文件
> ```

**文件的写入**

```js
//index.js 文件
let fs=require('fs')
fs.writeFile('hello.txt','写入的内容',{flag:'w',encoding:'utf-8'},function(err){
//fs.writeFile('hello.txt','写入的内容\n',{flag:'a',encoding:'utf-8'},function(err)			//追加写入
    //write=>w   read=>r  append=>a
    if(err){
        console.log(err);
    }else{
        console.log('写入成功');
    }
})
```



**封装文件的写入**

```js
//index.js 文件
let fs=require('fs')
function writefs(path,content){
    return new Promise(function(resolve,reject){
        //没有文件时自动创建
        fs.writeFile(path,content,{flag:'a',encoding:'utf-8'},function(err){
        if(err){
            reject(err);
        }else{
            resolve(err);
        }
            })
    })
}
// 写入内容
async function writeList(){
    await writefs('lc.txt','1今天吃烧烤\n')      //没有文件时自动创建
    await writefs('lc.txt','2今天吃红烧肉\n')
    await writefs('lc.txt','3红烧肉不好吃\n')
    await writefs('lc.txt','4今天又吃烧烤\n')
}
writeList()
```

**删除文件**

```js
//index.js 文件
// 删除文件
let fs=require('fs')
fs.unlink('lc.txt',function(){
    //没有参数
    console.log('删除成功');
})
```

**buffer**

```js
//index.js 文件
// buffer
//1.解决数组不能进行二进制数据的操作
//2.js 数组不像其他java,python 等语言效率高
//3.buffer 缓冲区,内存空间开辟出固定大小的内存,数据是连接在一起的,内存寻找时方便
//使用二进制来存储数据,使用16进制来显示

//将字符串转换成buffer 对象
var str='helloworld'
let buf=Buffer.from(str)
console.log(buf);   //16进制来显示

// 输出显示buffer 内容
console.log(buf.toString());

// 开辟一个空的buffer 缓存区
let buf1=Buffer.alloc(10)   //10个字节,安全
buf1[0]=10
console.log(buf1);  //<Buffer 0a 00 00 00 00 00 00 00 00 00>
buf1[0]=256
console.log(buf1);   
//256大于255 得到<Buffer 00 00 00 00 00 00 00 00 00 00>  因为buf 只有10个缓存区
// 1 00 00 00 00 00 00 00 00 00 00      中的1被排除在外
```



```js
let buf2=Buffer.allocUnsafe(10)
console.log(buf2);
//不安全的方式,空间不会被清除.遗留数据,会被人读取到内存的数据,赋值后会被覆盖掉
```



























