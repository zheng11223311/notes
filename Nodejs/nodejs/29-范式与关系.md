示例表数据

假设有一个名为employee 的员工表,他有九个属性:id(员工编号),name(员工名称),mobile(电话),zip(邮编),prevince(省份),city(城市),district(区县),deptNo(所属部门编号),deptName(所属部门名称),表总数据如下:

| id   | name | mobile                        | zip   | province | city | distract | deptNo | deptName |
| ---- | ---- | ----------------------------- | ----- | -------- | ---- | -------- | ------ | -------- |
| 101  | 张三 | 139100000001<br>139102340002  | 10001 | 北京     | 北京 | 海定区   | D1     | 部门1    |
| 101  | 张三 | 139100000001<br/>139102340002 | 10001 | 北京     | 北京 | 海定区   | D2     | 部门2    |
| 102  | 李四 | 139100000001<br/>139102340001 | 21001 | 上海     | 上海 | 静安区   | D3     | 部门3    |
| 103  | 王五 | 139102340001                  | 51001 | 广东省   | 广东 | 白云区   | D4     | 部门4    |
| 103  | 王五 | 139102340001                  | 51001 | 广东省   | 广东 | 白云区   | D5     | 部门5    |

由于此员工表是非规范化的,我们将还有面对如下问题

> **修改异常:**上表中张三有两条记录,因为他隶属于两个部门,如果我们需要修改张三的地址,必会修改两行记录,假如一个部门得到了张三的新地址并进行了更新,而另一个部门没有,那么此时张三在表中会存在两个不同的地址,导致了数据的不一样
>
> **新增异常:**假如一个新员工进入公司,他正处于入职培训阶段,还没有被正式分配到某个部门,如果deptNo 字段不允许为空,我们就无法向employee 表中增加该员工的数据
>
> **删除异常:**假设公司撤销了D3 部门,那么在删除deptNo 为D3 的信息时,会将李四的一并删除,因
>
> 为他隶属于D3 这一部门

**第一范式(1NF)**

> 表中的列只能含有原子性(不可再分)的值

表中的张三有两个手机号储存在mobile 列中,违反了1NF 规则.为了使表满足1NF,数据应该修改如下:

| id   | name | mobile       | zip   | province | city | distract | deptNo | deptName |
| ---- | ---- | ------------ | ----- | -------- | ---- | -------- | ------ | -------- |
| 101  | 张三 | 139100000001 | 10001 | 北京     | 北京 | 海定区   | D1     | 部门1    |
| 101  | 张三 | 139100000001 | 10001 | 北京     | 北京 | 海定区   | D1     |          |
| 101  | 张三 | 139102340002 | 10001 | 北京     | 北京 | 海定区   | D2     | 部门2    |
| 101  | 张三 | 139102340002 | 10001 | 北京     | 北京 | 海定区   | D2     |          |
| 102  | 李四 | 139100000001 | 21001 | 上海     | 上海 | 静安区   | D3     | 部门3    |
| 103  | 王五 | 139102340001 | 51001 | 广东省   | 广东 | 白云区   | D4     | 部门4    |
| 103  | 王五 | 139102340001 | 51001 | 广东省   | 广东 | 白云区   | D5     | 部门5    |

**第二范式(2NF)**

> 第二范式要满足下面两个条件
>
> **满足第一个范式**
>
> **没有部分依赖**

例如,员工表的一个候选是{id,mobile,deptNo},而deptName 依赖于deptNo,同样name 依赖于id,因此不是2NF 的.为了满足第二范式的条件,需要将这个表拆分成employee,dept,employee_dept,employee_mobile 四个表,如下:

**员工表enployee**

| id   | name | mobile       | zip   | province | city | distract |
| ---- | ---- | ------------ | ----- | -------- | ---- | -------- |
| 101  | 张三 | 139100000001 | 10001 | 北京     | 北京 | 海定区   |
| 102  | 李四 | 139100000001 | 21001 | 上海     | 上海 | 静安区   |
| 103  | 王五 | 139102340001 | 51001 | 广东省   | 广东 | 白云区   |

**部门表dept**

| deptNo | deptName |
| ------ | -------- |
| D1     | 部门1    |
| D2     | 部门2    |
| D3     | 部门3    |
| D4     | 部门4    |
| D5     | 部门5    |

**员工部门关系employee dept**

| id   | deptNo |
| ---- | ------ |
| 101  | D1     |
| 101  | D2     |
| 103  | D3     |
| 104  | D4     |
| 105  | D5     |

**员工电话表employee_mobile**

| id   | deptNo       |
| ---- | ------------ |
| 101  | 139100000001 |
| 101  | 139102340002 |
| 103  | 139100000001 |
| 104  | 139100000001 |
| 105  | 139100000001 |

**第三范式(3NF)**

> 第三范式要同时满足下面两个条件
>
> **满足第二范式**
>
> **没有传递依赖**

例如,员工表的provice,city,district 依赖于zip,而zip 依赖于id,换句话说,province,city,district 传递依赖于id,违反了3NF 规则,为了满足第三范式的条件,可以将这个表拆分成employee 和zip 两个表,如下

**employee**

| id   | name | zip   |
| ---- | ---- | ----- |
| 101  | 张三 | 10001 |
| 102  | 李四 | 20001 |
| 103  | 王五 | 51001 |

**地区表area**

| zip   | province | city | district |
| ----- | -------- | ---- | -------- |
| 10001 | 北京     | 北京 | 海定区   |
| 20001 | 上海     | 上海 | 静安区   |
| 51001 | 广东区   | 广东 | 白云区   |

在关系数据库模型设计中,一般需要满足第三范式的要求,如果一个表具有良好的主外键设计,就是已改满足3NF 的表,规范化1带来的好处是通过减少数据的冗余提高更新数据的效率,同时保证数据的完整性,然而,我们在实际应用中也要防止过度规范化的问题,规范化程度越高,划分的表就越多,在查询时越有可能使用表连接操作,而如果连接的表过多,会影响查询功能,关键的问题是要一句业务需求,仔细权衡数据查询和数据更新关系,指定最合适的规范化程度,不要为了遵循严格的规范化规则而修改业务需求

**数据库,一对一,一对多,多对多设计**

> 数据库实体间有三种对应的关系:一对一,一对多,多对多
>
> 一对一关系示例:
>
> 一个学生对应一个学生档案材料,每一个人都有唯一的省份证号码
>
> 一对多关系示例:
>
> 一个学生只属于一班,但这个班有多名学生
>
> 多对多关系示例:
>
> 一个学生可以选择多门课程,一门课程也可以有多个学生

