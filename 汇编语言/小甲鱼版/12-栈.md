### 1.栈

- 栈是一种具有特殊的访问方式的存储空间,它的特殊性就在于,最后进入这个空间的数据,最先出去(只有一个口,上面的先出去)
- 栈有两个基本的操作:入栈和出栈
  - 入栈:将一个新的元素放到栈顶
  - 出栈:从栈顶取出一个元素
- 栈顶的元素总是最后入栈,需要出栈时,又是最先被从栈中取出

### 2.CPU 提供栈机制

现今的CPU 中都有栈的设计

8086CPU 提供相关的指令来以栈的方式访问内存空间

这意味着,我们在基于8086CPU 编程的时候,可以将一段内存当作栈来使用

**8086CPU 提供入栈和出栈指令:(最基本的)**

​	PUSH (入栈)

​	POP(出栈)

push ax :将寄存器ax 中的数据送入栈中

pop ax :从栈顶取出数据送入ax

8086CPU 的入栈和出栈操作都是以字位单位进行的,从ax 看出16 位

**注意: 字型数据用两个单元存放,高地址放高8位,低地址放8位**

**1.CPU 如何知道一段内存空间被当作栈使用?**

**CPU 如何知道当前要执行的指令所在的位置**

寄存器CS 和IP 中存放者当前指令的段地址和偏移地址

8086 CPU 中,有两个寄存器:

- 段寄存器SS (stack segment)   存放栈顶的段地址
- 寄存器SP       存放栈顶的偏移地址

**任意时刻,SS:SP 指向栈顶元素**

**2.执行push 和 pop 的时候,如何知道哪个单元是栈顶单元?**

```
push ax
1. sp=sp -2			//先改变sp 指向再存放,向栈顶放,即地址变成低位
2.将ax 中的内容送入SS:SP 指向的内存但单元处,SS:SP 此时指向新栈顶

pop aX   是push 的逆向
不同点是:pop 弹出时,指针移动,逻辑上认为清除数据,但内存中并没有清除数据,当push 到这个内存时,这个值才会被覆盖,真正上的删除
```

**问题**

如果我们将10000H~1000FH 这段空间当作栈,初始状态栈是空的,此时,SS=1000H,SP =?

**sp=10010H,栈空SS:SP 指向栈空间最高地址单元的下一个单元**

- 我们将10000H~1000FH 这段空间当作栈段,SS=1000H,栈空间大小为16 字节,栈最底部的字单元地址为1000:000E(存在一个字)

- 任意时刻,SS:SP 指向栈顶,当栈中只有一个元素的时候,`SS=1000H,SP=000EH`

- 栈为空,就相当于栈中唯一的元素出栈,出栈后,`SP=SP+2`,sp 原来为000EH,加2后`SP=10H`

- 所以,当栈为空的时候,`SS=1000H,SP=10H`

  **换个角度看:**

  任意时刻,SS:SP 指向栈顶元素,当栈为空时,栈中没有元素,也就不存在栈顶元素

  所以SS:SP 只能指向栈的最底部单元下面的单元,该单元的偏移地址为栈的最底部的字单元的偏移地址 + 2

  栈最底部字单元的地址为1000:000E,所以栈空时,SP=0010H

### 3.pop 指令的执行过程

- pop ax
  - 将SS:SP 指向的内存单元处的数据送入ax 中
  - SP=SP+2,SS:SP 指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶
- **注意:**
  - 出栈后,SS:SP 指向新的栈顶1000EH,pop 操作前的栈顶元素,1000CH 处的2266H 依然在,但是,他已经不在栈中了
  - 当再次执行push 等入栈指令后,SS:SP 移至1000CH,并在里面写入新的数据,它将被覆盖

