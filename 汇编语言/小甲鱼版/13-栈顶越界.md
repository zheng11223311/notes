### 1.栈顶越界

- SS:SP只记录了栈顶的地址,依靠SS和 SP 可以保证在入栈和出栈时找到栈顶
- 可是,如何能够保证在入栈,出栈时,栈顶不会超出栈空间

**当栈满的时候在使用push 指令入栈,栈空的时候在使用pop 指令出栈,都将发生栈顶越界问题**

**栈顶越界是危险的**

因为我们既然将一段空间安排为栈,那么在栈空间之外的空间里很可能存放了具有其他用途的数据,代码等,这些数据,代码可能是我们自己的程序中的问题,也可能是别人程序中的

(毕竟一个计算机系统并不是只有我们自己的程序在运行)

但是由于我们在入栈出栈时的不小心,而将这些数据,代码意外的改写,将会引发一连串的错误

我们当然希望CPU 可以帮我们解决这个问题

比如说在CPU 中有记录栈顶上限和下限的寄存器,我们可以通过填写这些寄存器来指定栈空间的范围,然后,CPU 再执行push 指令的时候靠检测栈顶上限寄存器,在执行pop 指令的时候靠检测栈顶下限寄存器保证不会超界

**实际情况:8086CPU 中并没有这样的寄存器**

8086CPU 不保证对栈的操作不会超界,这就是说,8086CPU 只知道栈顶在何处(由SS:SP 指示),而不知道读者安排的栈空间有多大,这点就好像,CPU 只知道当前要执行的指令在何处(由CS:SP 指示)而不知道读者要执行的指令有多少

从这两点我们可以看出:

8086CPU 的工作原理,只考虑当前的情况:

当前栈顶在何处

当前要执行的指令是那一条

**结论**

我们在编程的时候自己要小心栈顶超界的问题,要根据可能用到的最大栈空间,来安排栈的大小,防止入栈的数据太多而导致的超界

执行出栈操作的时候也要注意,以防栈空的时候继续出栈而导致的超界

### 2.push 和pop 指令

push 和pop 指令时可以在寄存器和内存之间传送数据的

栈空间当然也是内存空间的一部分,它只是一段可以以一种特殊的方式进行访问的内存空间

**push 和pop 指令的格式(1)**

**push寄存器:**将一个寄存器中的数据入栈,push ax

**pop 寄存器:**出栈,用一个寄存器接收出栈的数据,pop ax

**push 和pop 指令的格式(2)**

**push 段寄存器:**将一个段寄存器中的数据入栈,push ds

**pop 段寄存器:**出栈,用一个段寄存器接收出栈的数据,pop ds

段寄存器以s 结尾,ds ,通用寄存器以x 结尾,ax

**push 和pop 指令的格式(3)**

**push 内存单元:**将一个内存单元处的字入栈(栈操作都是以字为单位), push [0]

**pop 内存单元:**出栈,用一个内存字单元接收出栈的数据 ,pop [0]

指令执行时,CPU 要知道内存单元的地址,可以在push,pop 指令中给出内存单元的偏移地址,段地址在指令执行时,CPU 从ds 中取得
