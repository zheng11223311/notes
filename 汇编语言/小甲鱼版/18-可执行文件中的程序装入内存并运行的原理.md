### 1.可执行文件中的程序装入内存并运行的原理

在DOS 中,可执行文件中的程序p1,若要运行,必须有一个正在运行的程序p2,将p1 从可执行文件中加载入内存,将CPU 的控制权交给它,p1 才能得以运行

当p1 运行完毕后,应该将CPU 的控制权交还给使他得以运行的程序p2

### 2.操作系统的外壳

> 操作系统是由多个功能强大模块组成的庞大,复杂的软件系统,任何通用的操作系统,都要提供一个称为shell(外壳) 	的程序,用户(操作人员) 使用这个程序来操作计算机系统工作
>
> DOS 中由一个程序command.com(即 cmd),这个程序在DOS 中称为命令解释器,也就是DOS 系统的shell

> 我们在DOS 中直接执行1.exe 时,是正在运行的command 将1.exe 中的程序加载入内存
>
> command 设置CPU 的CS:IP 指向程序的第一条指令(即程序的入口),从而使得程序得以运行
>
> 程序运行结束后,返回到command 中,CPU 继续运行command

**1.汇编程序从写出到执行的过程:**

```
编译(Edit)  --->1.asm ---> 编译(masm) ---> 1.obj --->连接(link) --->1.exe --->加载(command) --->内存中的程序 --->运行(CPU)
```

为了观察程序的运行过程,我们可以使用Debug

Debug 可以将程序加载入内存,设置CS:IP 指向程序的入口,但Debug 并不放弃对CPU 的控制,这样,我们就可以使用Debug 的相关命令来单步执行程序,查看每条指令的执行结果

```
assume cs:codesg			//假设 代码段的名称为 codesg

codesg segment				//codesg 开始

start: mov ax,0123H			//start 程序入口,可以为任意名称
	  mov bx,0456H
	  add ax,bx
	  add ax,bx
	  
	  mov ax,4c00h
	  int 21h
codesg ends					//codesg 结束
end	start						//程序结束
```

```
debug 1.exe             //调试
可以看到,Debug 将程序从可执行文件加载入内存后,cx 中存放的是程序的长度,1.exe 中程序的机器码共有15个字节
```

**总结:**

程序加载后,ds 中存放着程序所在内存区的段地址,这个内存区的偏移地址为0,则程序所在的内存地址区的地址为: ds:0;

这个内存区的前256 个字节中存放的是PSP ,DOS 用来和程序进行通信

从256 字节处向后的空间存放的是程序

所以,我们可以从ds 得到PSP 的段地址SA,PSP 的偏移地址为0,则物理地址为SAx16+0

因为PSP 占 256 个字节(100H),所以程序的物理地址是:

```
SA x 16+0+256=SA x 16+16x16=(SA+16)x16+0
```

可用段地址和偏移地址表示为:SA +10:0 

### 3.程序执行过程的跟踪

> 用U 命令查看一下其他指令:
>
> 用T 命令单步执行程序中的每一条指令,并观察每条指令的执行结果
>
> 到了 int 21H ,我们要用P 命令执行
>
> int 21H 执行结束后,显示Program terminated mormally (程序正常停止) 返回到Debug 中

我们在DOS 中用"Debug 1.exe" 运行Debug 对1.exe 进行跟踪时,程序加载的顺序是:command 加载Debug ,Debug 加载1.exe

返回的顺序是:从1.exe 中的程序返回到Debug,从Debug 返回到command

