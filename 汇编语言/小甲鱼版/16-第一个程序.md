### 1.第一个程序

**目录**

1. 一个源程序从写出到执行的过程
2. 源程序
3. 编辑源程序
4. 编译
5. 连接
6. 以简化的方式进行编译和连接
7. 1.exe 的执行
8. 可执行文件中的程序装入内存并运行的原理
9. 程序执行过程的跟踪

现在我们将开始编写完整的汇编语言程序,用编译器将他们编译成可执行文件(如: *.exe 文件),在操作系统中运行

### 2.一个源程序从写出到执行的过程

一个汇编语言程序从写出到最终执行的简要过程:

**编写**

使用文本编辑器(如记事本,Nodepad++,UltraEdit 等),用汇编语言编写汇编源程序

**编译和连接**

使用汇编语言编译程序(MASM.EXE) 对源程序文件中的源程序进行编译,产生目标文件

再用连接程序(LIKE.EXE) 对目标文件进行连接,生成可在操作系统中直接运行的可执行文件

### 3.可执行文件

可执行文件包含两个部分内容:

程序(从源程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据)

相关的描述信息(比如:程序有多大,要占多少内存空间等)

**执行**

**执行可执行文件中的程序**

在操作系统中,执行可执行文件中的程序

操作系统依照可执行文件中的描述信息,将可执行文件中的机器码和数据加载入内存,并进行相关的初始化(比如:设置CS:IP 指向第一条要执行的指令),然后由CPU 执行程序

### 4.源程序

```
assume cs:codesg			//假设 代码段的名称为 codesg

codesg segment				//codesg 开始

start mov ax,0123H
	  mov bx,0456H
	  add ax,bx
	  add ax,bx
	  
	  mov ax,4c00h
	  int 21h
codesg ends					//codesg 结束
end							//程序结束
```

**汇编指令**

有对应的机器码的指令,可以被编译为机器指令,最重被CPU 所执行,比如mov,add 等

**伪指令**

没有对应机器码的指令,最终不被CPU 所执行

> 谁来执行伪指令呢?
>
> 伪指令是由编译器来执行的指令,编译器根据伪指令来进行相关的编译工作(告诉编译器将代码当作代码段,数据段等)
>
> 形式  XXX segment     XXX ends

**定义一个段**

> segment 和ends 是一对成对使用的伪指令,这是在写可被编译器编译的汇编程序时,必须要用到的一对伪指令    
>
> segment 和ends 的功能是定义一个段,segment 说明一个段的开始,ends 说明是一个段的结束

**一个段必须有一个名称来标识,使用格式为:**

```
段名 segment
段名 ends
```

一个汇编程序是由多个段组成的,这些段被用来存放代码,数据或当作占空间来使用

一个有意义的汇编程序中至少要有一个段,这个段用来存放代码

**End 是一个汇编程序的结束标记,编译器在编译汇编程序的过程中,如果碰到了伪指令end ,就结束对源程序的编译**

如果程序写完了,要在结尾处加上伪指令end ,否则,编译器在编译程序时,无法知道程序在何处结束,这段代码将会永远存在内存中

**切记:不要搞混了end 和ends**

**寄存器与段的关联假设**

**assume : 含义为"假设"**

它假设某一段寄存器和程序中的某一用segment ... ends 定义的段相关联

通过assume 说明这种关联,在需要的情况下,编译程序可以将段寄存器和某一个具体的段相联系

**源程序中的"程序"**

汇编源程序:

- 伪指令(编译器处理)
- 汇编指令(编译为机器码)

程序:源程序中最终由计算机执行,处理的指令或数据

**注意:**
我们可以将源程序文件中的所有内容称为源程序,将源程序中最终由计算机执行处理的指令或数据称之为程序

程序最先以汇编指令的形式存在源程序中,经编译,连接后转变为机器码,存储在可执行文件中