### 1.栈的案例

**问题1**

将10000H~1000FH 这段空间当作栈,初始状态是空的,将ax,bx,ds 中的数据入栈

```
mov ax,1000H
mov ss,ax		//设置栈的段地址,ss=1000H,不能直接向段寄存器ss 送入数据,所以用ax 中转
mov sp,0010H    //设置栈顶的偏移地址,因为栈为空,所以sp =0010H
//上面三条指令设置栈顶地址,编程中要注意栈的大小
push ax
push bx
push ds
```

**问题2**

1. 将10000H~1000FH 这段空间当作栈,初始状态是空的
2. 设置AX =001AH,BX=001BH
3. 将AX,BX 中的数据入栈
4. 然后将AX,BX 清零
5. 从栈中恢复AX,BX 原来的内容

```
mov ax,1000H
mov ss,ax		//设置栈的段地址,ss=1000H,不能直接向段寄存器ss 送入数据,所以用ax 中转
mov sp,0010H    //设置栈顶的偏移地址,因为栈为空,所以sp =0010H
//上面三条指令设置栈顶地址,编程中要注意栈的大小
mov ax,001AH
mov bx,001BH
push ax
push bx			//ax,bx 入栈,栈的情况如图
sub ax,bx		//将ax 清零,也可以用mov ax,0,sub ax,ax 的机器码为两个字节,mov ax,0 的机器码为3个字节
sub bx,bx
pop ax			//从栈中恢复ax,bx 原来的数据,当前栈顶的内容是bx 中原来的内容:001BH,ax 中原来的内容001AH 在栈顶的下面,所以要先pop bx ,然后再pop ax
pop bx
```

从上面的程序我们可以看到,用栈来暂存以后需要恢复的寄存器中的内容时,出栈的顺序要和入栈的顺序相反,因为最后入栈的寄存器的内容在栈顶,所以在恢复时,要最先出栈

**问题3**

1. 将10000H~1000FH 这段空间地址当作栈,初始状态是空的
2. 设置AX=002AH,BX=002BH
3. 利用栈,交换AX 和BX 中的数据

```
mov ax,1000H
mov ss,ax
mov sp,0010H	//初始化栈顶
mov ax,002AH
mov bx,002BH
push ax
push bx			//ax,bx 入栈
pop ax					
pop bx			//出栈
```

**结论:**

push,pop 实质上就是一种内存传送指令,可以在寄存器和内存之间传送数据,于mov 指令不同的是,push 和pop 指令访问的内存单元的地址不是在指令中给出的,而是由SS:SP 指出的

同时,push 和pop 指令还要改变SP 中的内容

- 我们十分清除的是,push 和pop 指令同mov 指令不同,CPU 执行mov 指令只需要一步操作,就是传送,而执行push,pop 指令却需要两部操作
- 执行push 时:
  - 先改变SP ,后向SS:SP 处传送
- 执行POP 时
  - 先读取SS:SP 处的数据,后改变SP

**注意:**

push ,pop 等栈操作指令,修改的是SP,也就是说,栈顶的变化范围最大为0~FFFFH

**提示:**

SS:SP 指示栈顶,改变SP 后写入内存的入栈指令,读内存后改变SP 的出栈指令

这就是8086CPU 提供的栈操作机制

**总结:**

1. 8086CPU 提供了栈操作机制,方案如下:
   1. 在SS:SP 中存放栈顶的段地址和偏移地址,提供入栈和出栈指令,他们根据SS:SP 指示的地址,按照栈的方式访问内存单元
2. push 指令的执行步骤
   1. SP=SP-2
   2. 向SS:SP 指向的字单元中送入数据
3. pop 指令的执行步骤
   1. 从SS:SP 指向的字单元中读取数据
   2. SP=SP+2
4. 任意时刻,SS:SP 指向栈顶元素
5. 8086CPU 只记录栈顶,栈空间大小我们要自己管理
6. 用栈来暂存以后需要恢复的寄存器的内容时,寄存器出栈的顺序要和入栈的顺序相反
7. push ,pop 实质上是一种内存传送指令,注意他们的灵活应用
8. 栈是一种非常重要的机制,一定要深入理解,灵活掌握