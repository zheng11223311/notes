### 1.寄存器(内存访问)

**目录**

- 内存中字的存储
- DS 和[address]
- 字的传送
- mov , add , sub 指令
- 数据段
- 栈
- CPU 提供的栈机制
- 栈顶超界的问题
- push,pop 指令
- 栈段

### 2.内存中字的存储

在0 地址处开始存放2000(即十六进制的4E20H):

| 地址     | 数据       |
| -------- | ---------- |
| 0 (低号) | 20H(低位)  |
| 1(高号)  | 4EH (高位) |

**注意:0号单元是低地址单元,1号单元是高地址单元,低号存低位,高号存高位**

 字型:16位,字节型:8位



| 地址     | 数据       |
| -------- | ---------- |
| 0 (低号) | 20H(低位)  |
| 1(高号)  | 4EH (高位) |
| 2        | 12H        |
| 3        | 00H        |

**问题:**

1. 0地址单元(代表字节型)中存放的字节型数据是多少?
   1. 20H
2. 0 地址字单元(代表字型)中存放的字型数据是多少?
   1. 4E20H
3. 2 地址字单元中存放的字节型数据是多少?
   1. 12H
4. 2 地址单元中存放的字型数据是多少?
   1. 0012H        //2被认为是低位,3位是高位,地址3比地址2大(3>2)
5. 1 地址单元中存放的字型数据是多少?
   1. 124EH

**结论:**

任何两个地址连续的内存单元,N 号单元和N+1 单元,可以将它们看成两个内存单元,也可以看成一个地址位N 的字节单元中的高位字节单元和低位字节单元

### 3.DS 和[address]

- CPU 要读取一个内存单元的时候,必须先给出这个内存单元的地址
- 在 8086PC 中,内存地址由段地址和偏移地址组成
- 8086CPU 中有一个DS 寄存器,通常用来存放要访问的数据的段地址

**例如:**

我们要读取10000H 单元的内容可以用如下程序段进行

```
mov bx,1000H
mov ds,bx			//必须先经过bx,在传送到ds,不能直接赋值1000H
mov al,[0]          //将内存偏移单元为0 的单元送入寄存器al

已知的mov 指令可完成的两种传送功能:
1.将数据直接送入寄存器;
2.将一个寄存器中的内容送入另一个寄存器中
除此之外,mov 指令还可以将一个内存单元中的内容送入一个寄存器

上面三条指令将10000H(1000:0) 中的数据读取到al 中
```

**mov 的指令格式**

```
mov 寄存器名,内存单元地址
```

[...] 表示一个内存单元,[...] 中的0 表示内存单元的偏移地址

**那么内存单元的段地址是多少呢?**

执行指令时,8086 CPU 自动获取DS 中的数据为内存的单元的段地址

**如何mov 指令从10000H 中读取数据?**

- 10000H 表示为1000:0(段地址:偏移地址)
- 将段地址1000H 放入DS
- 用mov al,[0] 完成传送(mov 指令中的[] 说明操作对象是一个内存单元,[] 中的0 说明这个内存单元的偏移地址是0, 它的段地址默认放在DS 中)

**如何把1000H 送入DS**

8086CPU 不支持将数据直接送入段寄存器的操作,DS 是一个段寄存器(硬件设计的问题),即不能使用 mov ds,1000H 是非法的

**过程**

数据 --> 通用寄存器 --->段寄存器

**怎样将数据从寄存器送入内存单元?**

结论:

```
mov bx,1000H
mov ds,bx
mov [0],al
```

### 4.字的传送

**因为8086 CPU 是16 位的结构,有16根数据线,所以,可以一次性传送1位的数据,也就是一次性传送一个字(即2 个字节)**

比如:

```
mov bx,1000H
mov ds,bx		//送入段地址
mov ax,[0]		//1000:0 处的字型数据送入ax
mov [0],cx		//cx 中的16 位数据送到1000:0 处
```

**问题1:**

内存中的情况如下图,写出下面指令执行后寄存器ax,bx,cx 中的值

```
mov ax,1000H			//ax =1000H
mov ds,ax				//dx =1000H
mov ax,[0]				//ax =1123		将地址1000H,1001H 值给ax,因为 ax 为2字节
mov bx,[2]				//bx =6622
mov cx,[1]				//cx =2211
add bx,[1]				// bx =8833
add cx,[2]				// cx =8833
```

**内存情况示意图**

| 地址   | 数据 |
| ------ | ---- |
| 10000H | 23   |
| 10001H | 11   |
| 10002H | 22   |
| 10003H | 66   |

**问题2**

内存中的情况如下图,写出下面指令执行后寄存器ax,bx,cx 中的值

```
mov ax,1000H      		//ax=1000
mov ds,ax				//dx =1000
mov ax,2C34				//ax=2C34
mov [0],ax				//内存地址0中存放ax 的值 34 2c 
mov bx,[0]				//将[0]存放到bx
sub bx,[2]				//相减bx-[2]
mov [2],bx				//将bx 存放到[2]
```

**内存情况示意图**

| 地址   | 数据 |
| ------ | ---- |
| 10000H | 23   |
| 10001H | 11   |
| 10002H | 22   |
| 10003H | 11   |

